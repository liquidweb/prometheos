{{ define "foot" }}
  <style>
    /* ========================================
       DATA TABLE STYLES
       ======================================== */

    .tab-panel {
      animation: fadeIn 0.2s ease;
    }

    .table-container {
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-lg);
      overflow: hidden;
    }

    .data-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    .data-table thead {
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border-default);
    }

    .data-table th {
      padding: 14px 16px;
      text-align: left;
      font-weight: 600;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-secondary);
      white-space: nowrap;
      user-select: none;
    }

    .data-table th.sortable {
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .data-table th.sortable:hover {
      color: var(--text-primary);
      background: var(--bg-elevated);
    }

    .data-table th.sortable span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .sort-icon {
      opacity: 0.4;
      font-size: 12px;
      transition: opacity 0.15s ease;
    }

    .data-table th.sortable:hover .sort-icon,
    .data-table th.sortable.asc .sort-icon,
    .data-table th.sortable.desc .sort-icon {
      opacity: 1;
    }

    .data-table th.sortable.asc .sort-icon::after { content: ' ↑'; }
    .data-table th.sortable.desc .sort-icon::after { content: ' ↓'; }

    .data-table tbody tr {
      border-bottom: 1px solid var(--border-subtle);
      transition: background 0.1s ease;
    }

    .data-table tbody tr:last-child {
      border-bottom: none;
    }

    .data-table tbody tr:hover {
      background: var(--bg-tertiary);
    }

    .data-table tbody tr.selected {
      background: var(--accent-bg);
    }

    .data-table tbody tr.filtered-out {
      display: none;
    }

    .data-table tbody tr.quick-filtered-out {
      display: none;
    }

    .data-table td {
      padding: 14px 16px;
      vertical-align: middle;
    }

    /* Checkbox column */
    .col-checkbox {
      width: 40px;
      text-align: center;
    }

    .cell-checkbox {
      text-align: center;
    }

    .row-checkbox,
    .row-checkbox-header {
      width: 16px;
      height: 16px;
      cursor: pointer;
      accent-color: var(--accent);
    }

    /* Cell types */
    .cell-mono {
      font-family: var(--font-mono);
      font-size: 12px;
    }

    .cell-text {
      color: var(--text-primary);
    }

    .cell-muted {
      color: var(--text-muted);
    }

    .cell-primary {
      font-weight: 500;
    }

    /* UID Badge */
    .uid-badge {
      display: inline-block;
      padding: 4px 8px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-default);
      border-radius: var(--radius-sm);
      font-size: 11px;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .uid-badge.silenced {
      background: var(--silenced-bg);
      border-color: var(--silenced);
      color: var(--silenced);
    }

    /* Hostname with status dot */
    .hostname {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .status-dot.critical {
      background: var(--critical);
      box-shadow: 0 0 8px var(--critical);
      animation: pulse-critical 2s ease-in-out infinite;
    }

    .status-dot.silenced {
      background: var(--silenced);
    }

    @keyframes pulse-critical {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Time badge */
    .time-badge {
      display: inline-block;
      padding: 4px 8px;
      background: var(--bg-tertiary);
      border-radius: var(--radius-sm);
      font-size: 12px;
      color: var(--text-secondary);
    }

    /* Duration badge */
    .duration-badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: var(--radius-sm);
      font-size: 12px;
      font-weight: 500;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
    }

    .duration-badge.short {
      background: var(--healthy-bg);
      color: var(--healthy);
    }

    .duration-badge.medium {
      background: var(--warning-bg);
      color: var(--warning);
    }

    .duration-badge.long {
      background: var(--critical-bg);
      color: var(--critical);
    }

    .duration-badge.silenced {
      background: var(--silenced-bg);
      color: var(--silenced);
    }

    .duration-badge.new {
      background: linear-gradient(135deg, #3b82f6, #8b5cf6);
      color: white;
      animation: pulse-new 1.5s ease-in-out infinite;
    }

    @keyframes pulse-new {
      0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4); }
      50% { opacity: 0.9; box-shadow: 0 0 8px 2px rgba(139, 92, 246, 0.3); }
    }

    /* New alert row highlighting */
    .alert-row.new-alert {
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.08) 0%, transparent 100%);
      border-left: 3px solid #3b82f6;
    }

    .alert-row.new-alert:hover {
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.12) 0%, var(--bg-tertiary) 100%);
    }

    /* ========================================
       GROUPED ROWS (Location/Account Focus)
       ======================================== */

    .group-header-row {
      background: var(--bg-tertiary) !important;
      border-left: 3px solid var(--accent);
      cursor: pointer;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .group-header-row:hover {
      background: var(--bg-elevated) !important;
    }

    .group-header-row td {
      padding: 10px 16px !important;
    }

    .group-header-content {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .group-expand-icon {
      width: 16px;
      height: 16px;
      color: var(--text-secondary);
      transition: transform 0.2s ease;
    }

    .group-header-row.collapsed .group-expand-icon {
      transform: rotate(-90deg);
    }

    .group-label {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .group-icon {
      width: 16px;
      height: 16px;
      color: var(--accent);
    }

    .group-name {
      font-size: 14px;
      font-weight: 600;
    }

    .group-count {
      padding: 2px 8px;
      background: var(--accent-bg);
      border-radius: var(--radius-sm);
      font-size: 11px;
      font-weight: 600;
      color: var(--accent);
    }

    .group-summary {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 16px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .group-summary-item {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .group-summary-item.critical {
      color: var(--critical);
    }

    .group-summary-item.new {
      color: #3b82f6;
    }

    .grouped-row {
      border-left: 3px solid transparent;
    }

    .grouped-row.indent-1 {
      border-left-color: rgba(99, 102, 241, 0.3);
    }

    .grouped-row.indent-1 td:first-child {
      padding-left: 32px !important;
    }

    .grouped-row.indent-2 {
      border-left-color: rgba(99, 102, 241, 0.15);
    }

    .grouped-row.indent-2 td:first-child {
      padding-left: 48px !important;
    }

    /* Collapse behavior handled via JavaScript for proper group scoping */

    /* Subgroup header (e.g., section within datacenter) */
    .subgroup-header-row {
      background: var(--bg-secondary) !important;
      border-left: 3px solid rgba(99, 102, 241, 0.5);
      cursor: pointer;
    }

    .subgroup-header-row:hover {
      background: var(--bg-tertiary) !important;
    }

    .subgroup-header-row td {
      padding: 8px 16px !important;
      padding-left: 32px !important;
    }

    .subgroup-header-content {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
      font-size: 13px;
      color: var(--text-secondary);
    }

    .subgroup-expand-icon {
      width: 14px;
      height: 14px;
      color: var(--text-muted);
      transition: transform 0.2s ease;
    }

    .subgroup-header-row.collapsed .subgroup-expand-icon {
      transform: rotate(-90deg);
    }

    .subgroup-name {
      color: var(--text-primary);
    }

    .subgroup-count {
      padding: 1px 6px;
      background: var(--bg-tertiary);
      border-radius: var(--radius-sm);
      font-size: 10px;
      font-weight: 500;
    }

    /* Row-level header (row/rack within section) */
    .row-header-row {
      background: var(--bg-primary) !important;
      border-left: 3px solid rgba(99, 102, 241, 0.3);
      cursor: pointer;
    }

    .row-header-row:hover {
      background: var(--bg-secondary) !important;
    }

    .row-header-row td {
      padding: 6px 16px !important;
      padding-left: 48px !important;
    }

    .row-header-content {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .row-expand-icon {
      width: 12px;
      height: 12px;
      color: var(--text-muted);
      transition: transform 0.2s ease;
    }

    .row-header-row.collapsed .row-expand-icon {
      transform: rotate(-90deg);
    }

    .row-header-name {
      color: var(--text-primary);
      font-weight: 500;
    }

    .row-header-count {
      padding: 1px 5px;
      background: var(--bg-tertiary);
      border-radius: var(--radius-sm);
      font-size: 9px;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .grouped-row.indent-3 {
      border-left-color: rgba(99, 102, 241, 0.1);
    }

    .grouped-row.indent-3 td:first-child {
      padding-left: 64px !important;
    }

    /* Stale Alerts Collapsing */
    .stale-alerts-header {
      background: linear-gradient(135deg, rgba(255, 193, 7, 0.08) 0%, rgba(255, 152, 0, 0.05) 100%);
      border-left: 3px solid var(--warning);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .stale-alerts-header:hover {
      background: linear-gradient(135deg, rgba(255, 193, 7, 0.12) 0%, rgba(255, 152, 0, 0.08) 100%);
    }

    .stale-alerts-header td {
      padding: 12px 16px !important;
    }

    .stale-header-content {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .stale-expand-icon {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      border-radius: var(--radius-sm);
      background: rgba(255, 193, 7, 0.15);
      color: var(--warning);
      transition: transform 0.2s ease;
    }

    .stale-alerts-header.collapsed .stale-expand-icon {
      transform: rotate(-90deg);
    }

    .stale-header-icon {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
      background: rgba(255, 193, 7, 0.15);
      border-radius: var(--radius-sm);
      color: var(--warning);
    }

    .stale-header-text {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .stale-header-title {
      font-weight: 600;
      font-size: 13px;
      color: var(--text-primary);
    }

    .stale-header-subtitle {
      font-size: 11px;
      color: var(--text-secondary);
    }

    .stale-header-count {
      margin-left: auto;
      padding: 4px 10px;
      background: rgba(255, 193, 7, 0.2);
      border-radius: 12px;
      font-size: 12px;
      font-weight: 600;
      color: var(--warning);
    }

    .stale-alert-row {
      opacity: 0.7;
      background: repeating-linear-gradient(
        -45deg,
        transparent,
        transparent 10px,
        rgba(255, 193, 7, 0.02) 10px,
        rgba(255, 193, 7, 0.02) 20px
      );
    }

    .stale-alert-row:hover {
      opacity: 0.9;
    }

    .stale-alert-row .cell-duration {
      color: var(--warning);
    }

    /* Stale alerts toggle in toolbar */
    .stale-toggle-container {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: var(--bg-tertiary);
      border-radius: var(--radius);
      border: 1px solid var(--border-subtle);
      font-size: 12px;
    }

    .stale-toggle-label {
      color: var(--text-secondary);
      white-space: nowrap;
    }

    .stale-toggle-switch {
      position: relative;
      width: 36px;
      height: 20px;
      background: var(--bg-secondary);
      border-radius: 10px;
      border: 1px solid var(--border-default);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .stale-toggle-switch.active {
      background: var(--accent);
      border-color: var(--accent);
    }

    .stale-toggle-switch::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 14px;
      height: 14px;
      background: white;
      border-radius: 50%;
      transition: transform 0.2s ease;
    }

    .stale-toggle-switch.active::after {
      transform: translateX(16px);
    }

    .stale-threshold-select {
      padding: 4px 8px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-default);
      border-radius: var(--radius-sm);
      font-size: 11px;
      color: var(--text-primary);
      cursor: pointer;
    }

    /* Service tags */
    .cell-services {
      max-width: 300px;
    }

    .service-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .service-tag {
      display: inline-block;
      padding: 4px 10px;
      background: var(--critical-bg);
      border: 1px solid rgba(255, 107, 107, 0.3);
      border-radius: 20px;
      font-size: 11px;
      font-weight: 500;
      color: var(--critical);
    }

    .service-tag.silenced {
      background: var(--silenced-bg);
      border-color: rgba(139, 92, 246, 0.3);
      color: var(--silenced);
    }

    /* Actions column */
    .col-actions {
      width: 120px;
      text-align: right !important;
    }

    .cell-actions {
      text-align: right;
    }

    .action-form {
      display: inline;
    }

    .btn-action {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      font-family: var(--font-sans);
      font-size: 12px;
      font-weight: 500;
      border: 1px solid transparent;
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .btn-silence {
      background: var(--silenced-bg);
      border-color: rgba(139, 92, 246, 0.3);
      color: var(--silenced);
    }

    .btn-silence:hover {
      background: var(--silenced);
      color: white;
      transform: translateY(-1px);
    }

    .btn-unsilence {
      background: var(--healthy-bg);
      border-color: rgba(74, 222, 128, 0.3);
      color: var(--healthy);
    }

    .btn-unsilence:hover {
      background: var(--healthy);
      color: var(--bg-primary);
      transform: translateY(-1px);
    }

    /* Silenced row styling */
    .silenced-row {
      opacity: 0.7;
    }

    .silenced-row:hover {
      opacity: 1;
    }

    /* Empty state */
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-lg);
    }

    .empty-icon {
      margin-bottom: 16px;
      color: var(--text-muted);
    }

    .empty-state h3 {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--text-primary);
    }

    .empty-state p {
      color: var(--text-muted);
      font-size: 14px;
    }

    /* ========================================
       SKIP LINK FOR ACCESSIBILITY
       ======================================== */

    .skip-link {
      position: absolute;
      top: -100%;
      left: 16px;
      padding: 8px 16px;
      background: var(--accent);
      color: white;
      border-radius: var(--radius-md);
      z-index: 1000;
      transition: top 0.2s ease;
      text-decoration: none;
    }

    .skip-link:focus {
      top: 16px;
    }

    /* ========================================
       TOAST NOTIFICATIONS
       ======================================== */

    .toast-container {
      position: fixed;
      bottom: 24px;
      right: 24px;
      z-index: 1100;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .toast {
      padding: 12px 20px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-default);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-lg);
      font-size: 13px;
      color: var(--text-primary);
      animation: slideInRight 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .toast.success {
      border-color: var(--healthy);
    }

    .toast.error {
      border-color: var(--critical);
    }

    @keyframes slideInRight {
      from { opacity: 0; transform: translateX(20px); }
      to { opacity: 1; transform: translateX(0); }
    }

    /* ========================================
       RESPONSIVE DESIGN
       ======================================== */

    @media (max-width: 1200px) {
      .status-grid {
        grid-template-columns: repeat(2, 1fr);
      }

      .widgets-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 768px) {
      .dashboard-header {
        padding: 0 16px;
      }

      .header-meta {
        gap: 8px;
      }

      .last-update {
        display: none;
      }

      .status-overview {
        padding: 16px;
      }

      .status-grid {
        grid-template-columns: 1fr;
      }

      .controls-bar {
        flex-direction: column;
        align-items: stretch;
      }

      .search-form {
        min-width: 100%;
      }

      .filter-controls {
        justify-content: space-between;
      }

      .search-hint {
        display: none;
      }

      .main-content {
        padding: 0 16px 16px;
      }

      .table-container {
        overflow-x: auto;
      }

      .data-table {
        min-width: 900px;
      }

      .filters-grid {
        grid-template-columns: 1fr;
      }
    }

    /* ========================================
       KEYBOARD FOCUS STYLES
       ======================================== */

    .search-input:focus,
    .btn:focus,
    .btn-action:focus,
    .tab-btn:focus,
    .header-btn:focus,
    .filter-select:focus {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }
  </style>

  <!-- Toast Container -->
  <div class="toast-container" id="toast-container"></div>

  <script>
    // ========================================
    // THEME MANAGEMENT
    // ========================================

    const ThemeManager = {
      init() {
        const savedTheme = localStorage.getItem('prometheos-theme') || 'dark';
        this.setTheme(savedTheme);

        document.getElementById('theme-toggle').addEventListener('click', () => {
          const currentTheme = document.documentElement.getAttribute('data-theme');
          const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
          this.setTheme(newTheme);
          showToast(`Switched to ${newTheme} mode`, 'success');
        });
      },

      setTheme(theme) {
        document.documentElement.setAttribute('data-theme', theme);
        localStorage.setItem('prometheos-theme', theme);
      },

      toggle() {
        const currentTheme = document.documentElement.getAttribute('data-theme');
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
        this.setTheme(newTheme);
      }
    };

    // ========================================
    // AUTO-REFRESH MANAGEMENT
    // ========================================

    const RefreshManager = {
      interval: null,
      currentInterval: 60,

      init() {
        const savedInterval = localStorage.getItem('prometheos-refresh-interval');
        if (savedInterval !== null) {
          this.currentInterval = parseInt(savedInterval);
        }
        this.updateUI();
        this.startRefresh();

        // Dropdown toggle
        const refreshBtn = document.getElementById('refresh-btn');
        const dropdown = document.getElementById('refresh-dropdown');

        refreshBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          dropdown.classList.toggle('show');
        });

        // Option selection
        document.querySelectorAll('.refresh-option').forEach(option => {
          option.addEventListener('click', () => {
            const interval = parseInt(option.dataset.interval);
            this.setInterval(interval);
            dropdown.classList.remove('show');
          });
        });

        // Close dropdown on outside click
        document.addEventListener('click', () => {
          dropdown.classList.remove('show');
        });
      },

      setInterval(seconds) {
        this.currentInterval = seconds;
        localStorage.setItem('prometheos-refresh-interval', seconds);
        this.updateUI();
        this.startRefresh();

        if (seconds === 0) {
          showToast('Auto-refresh disabled', 'success');
        } else {
          showToast(`Auto-refresh set to ${seconds < 60 ? seconds + ' seconds' : (seconds / 60) + ' minute(s)'}`, 'success');
        }
      },

      updateUI() {
        const refreshBtn = document.getElementById('refresh-btn');
        document.querySelectorAll('.refresh-option').forEach(option => {
          const interval = parseInt(option.dataset.interval);
          option.classList.toggle('selected', interval === this.currentInterval);
        });

        if (this.currentInterval > 0) {
          refreshBtn.classList.add('active');
        } else {
          refreshBtn.classList.remove('active');
        }
      },

      startRefresh() {
        if (this.interval) {
          clearInterval(this.interval);
        }

        if (this.currentInterval > 0) {
          this.interval = setInterval(() => {
            this.refresh();
          }, this.currentInterval * 1000);
        }
      },

      refresh() {
        const indicator = document.getElementById('update-indicator');
        indicator.classList.add('refreshing');

        // Reload the page to get fresh data
        setTimeout(() => {
          window.location.reload();
        }, 500);
      }
    };

    // ========================================
    // SHORTCUTS MODAL
    // ========================================

    const ShortcutsModal = {
      init() {
        const modal = document.getElementById('shortcuts-modal');
        const openBtn = document.getElementById('shortcuts-btn');
        const closeBtn = document.getElementById('modal-close');

        openBtn.addEventListener('click', () => this.open());
        closeBtn.addEventListener('click', () => this.close());

        modal.addEventListener('click', (e) => {
          if (e.target === modal) this.close();
        });
      },

      open() {
        document.getElementById('shortcuts-modal').classList.add('show');
      },

      close() {
        document.getElementById('shortcuts-modal').classList.remove('show');
      },

      toggle() {
        const modal = document.getElementById('shortcuts-modal');
        modal.classList.toggle('show');
      }
    };

    // ========================================
    // HELP MODAL
    // ========================================

    const HelpModal = {
      modal: null,
      currentTab: 'overview',

      init() {
        this.modal = document.getElementById('help-modal');
        const openBtn = document.getElementById('help-btn');

        if (openBtn) {
          openBtn.addEventListener('click', () => this.open());
        }

        if (this.modal) {
          this.modal.addEventListener('click', (e) => {
            if (e.target === this.modal) this.close();
          });
        }
      },

      open() {
        if (this.modal) {
          this.modal.classList.add('show');
        }
      },

      close() {
        if (this.modal) {
          this.modal.classList.remove('show');
        }
      },

      toggle() {
        if (this.modal) {
          this.modal.classList.toggle('show');
        }
      },

      showTab(tabName) {
        this.currentTab = tabName;

        // Update tab buttons
        document.querySelectorAll('.help-tab').forEach(tab => {
          tab.classList.toggle('active', tab.dataset.tab === tabName);
        });

        // Update content visibility
        document.querySelectorAll('.help-content').forEach(content => {
          content.style.display = 'none';
        });

        const activeContent = document.getElementById(`help-content-${tabName}`);
        if (activeContent) {
          activeContent.style.display = 'block';
        }
      }
    };

    // ========================================
    // ALERT DETAILS DRAWER
    // ========================================

    const AlertDrawer = {
      overlay: null,
      currentAlert: null,
      currentIndex: 0,
      alerts: [],

      init() {
        this.overlay = document.getElementById('alert-drawer-overlay');

        // Close on overlay click
        if (this.overlay) {
          this.overlay.addEventListener('click', (e) => {
            if (e.target === this.overlay) this.close();
          });
        }

        // Make alert rows clickable
        this.bindRowClicks();

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
          if (!this.overlay?.classList.contains('show')) return;

          if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
            e.preventDefault();
            this.previous();
          } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
            e.preventDefault();
            this.next();
          }
        });
      },

      bindRowClicks() {
        document.querySelectorAll('.alert-row').forEach(row => {
          row.addEventListener('click', (e) => {
            // Don't open drawer if clicking on checkbox, button, or link
            if (e.target.closest('input, button, a, .row-checkbox')) return;
            this.openFromRow(row);
          });
        });
      },

      openFromRow(row) {
        // Build alerts array from visible rows
        const table = row.closest('table');
        this.alerts = Array.from(table.querySelectorAll('tbody tr:not(.filtered-out)'));
        this.currentIndex = this.alerts.indexOf(row);

        this.populateFromRow(row);
        this.open();
      },

      open() {
        if (this.overlay) {
          this.overlay.classList.add('show');
          this.updateNavigation();
        }
      },

      close() {
        if (this.overlay) {
          this.overlay.classList.remove('show');
        }
      },

      populateFromRow(row) {
        this.currentAlert = {
          uid: row.querySelector('.uid-badge')?.textContent || '',
          account: row.querySelector('.cell-primary')?.textContent || '',
          hostname: row.querySelector('.hostname')?.textContent?.trim() || '',
          location: row.dataset.location || '',
          prom: row.dataset.prom || '',
          time: row.dataset.time || '',
          services: row.dataset.services || '',
          isSilenced: row.closest('#silenced') !== null
        };

        // Populate fields
        document.getElementById('drawer-hostname').textContent = this.currentAlert.hostname;
        document.getElementById('drawer-uid').textContent = this.currentAlert.uid;
        document.getElementById('drawer-account').textContent = this.currentAlert.account;
        document.getElementById('drawer-hostname-full').textContent = this.currentAlert.hostname;
        document.getElementById('drawer-location').textContent = this.currentAlert.location || '—';
        document.getElementById('drawer-prom').textContent = this.currentAlert.prom || '—';
        document.getElementById('drawer-time').textContent = this.currentAlert.time || '—';

        // Calculate duration
        if (this.currentAlert.time) {
          const start = new Date(this.currentAlert.time.replace(' ', 'T'));
          const now = new Date();
          const diffMs = now - start;
          const hours = Math.floor(diffMs / (1000 * 60 * 60));
          const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
          document.getElementById('drawer-duration').textContent =
            hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;
        } else {
          document.getElementById('drawer-duration').textContent = '—';
        }

        // Populate services
        const servicesContainer = document.getElementById('drawer-services');
        const services = this.currentAlert.services.split(',').filter(s => s.trim());
        servicesContainer.innerHTML = services.length > 0
          ? services.map(s => `<span class="drawer-service-tag">${this.escapeHtml(s.trim())}</span>`).join('')
          : '<span class="drawer-info-value">No services</span>';

        // Populate labels from data attributes
        const labelsContainer = document.getElementById('drawer-labels');
        const labels = [];
        Object.keys(row.dataset).forEach(key => {
          if (!['time', 'services', 'location', 'prom', 'uid'].includes(key)) {
            labels.push({ key, value: row.dataset[key] });
          }
        });

        if (labels.length > 0) {
          labelsContainer.innerHTML = labels.map(l => `
            <span class="drawer-label">
              <span class="drawer-label-key">${this.escapeHtml(l.key)}:</span>
              <span class="drawer-label-value">${this.escapeHtml(l.value)}</span>
            </span>
          `).join('');
          document.getElementById('drawer-labels-section').style.display = 'block';
        } else {
          document.getElementById('drawer-labels-section').style.display = 'none';
        }

        // Update silence button
        const silenceBtn = document.getElementById('drawer-silence-btn');
        const silenceText = document.getElementById('drawer-silence-text');
        if (this.currentAlert.isSilenced) {
          silenceBtn.classList.remove('danger');
          silenceBtn.classList.add('secondary');
          silenceText.textContent = 'Unsilence Alert';
        } else {
          silenceBtn.classList.remove('secondary');
          silenceBtn.classList.add('danger');
          silenceText.textContent = 'Silence Alert';
        }
      },

      updateNavigation() {
        const prevBtn = document.getElementById('drawer-prev-btn');
        const nextBtn = document.getElementById('drawer-next-btn');
        const position = document.getElementById('drawer-position');

        prevBtn.disabled = this.currentIndex === 0;
        nextBtn.disabled = this.currentIndex === this.alerts.length - 1;
        position.textContent = `${this.currentIndex + 1} of ${this.alerts.length}`;
      },

      previous() {
        if (this.currentIndex > 0) {
          this.currentIndex--;
          this.populateFromRow(this.alerts[this.currentIndex]);
          this.updateNavigation();
        }
      },

      next() {
        if (this.currentIndex < this.alerts.length - 1) {
          this.currentIndex++;
          this.populateFromRow(this.alerts[this.currentIndex]);
          this.updateNavigation();
        }
      },

      silenceAlert() {
        if (!this.currentAlert) return;

        const form = document.createElement('form');
        form.method = 'POST';
        form.style.display = 'none';

        const input = document.createElement('input');
        input.name = this.currentAlert.isSilenced ? 'remove-silence' : 'silence-alert';
        input.value = this.currentAlert.hostname;
        form.appendChild(input);

        document.body.appendChild(form);
        form.submit();
      },

      copyAsText() {
        if (!this.currentAlert) return;

        const text = `Alert: ${this.currentAlert.hostname}
UID: ${this.currentAlert.uid}
Account: ${this.currentAlert.account}
Location: ${this.currentAlert.location}
Prom Node: ${this.currentAlert.prom}
Started: ${this.currentAlert.time}
Services: ${this.currentAlert.services}`;

        navigator.clipboard.writeText(text).then(() => {
          showToast('Alert details copied to clipboard', 'success');
        }).catch(() => {
          showToast('Failed to copy to clipboard', 'error');
        });
      },

      copyAsJSON() {
        if (!this.currentAlert) return;

        const json = JSON.stringify(this.currentAlert, null, 2);
        navigator.clipboard.writeText(json).then(() => {
          showToast('Alert JSON copied to clipboard', 'success');
        }).catch(() => {
          showToast('Failed to copy to clipboard', 'error');
        });
      },

      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
    };

    // ========================================
    // BULK ACTIONS
    // ========================================

    const BulkActions = {
      selectedRows: new Set(),
      bar: null,

      init() {
        this.bar = document.getElementById('bulk-actions-bar');
        this.bindCheckboxes();
      },

      bindCheckboxes() {
        // Row checkboxes
        document.querySelectorAll('.row-checkbox').forEach(checkbox => {
          checkbox.addEventListener('change', (e) => {
            e.stopPropagation();
            const row = checkbox.closest('tr');
            if (checkbox.checked) {
              this.selectedRows.add(row);
              row.classList.add('selected');
            } else {
              this.selectedRows.delete(row);
              row.classList.remove('selected');
            }
            this.updateBar();
          });
        });

        // Header checkboxes (select all)
        document.querySelectorAll('.row-checkbox-header').forEach(headerCheckbox => {
          headerCheckbox.addEventListener('change', () => {
            const table = headerCheckbox.closest('table');
            const checkboxes = table.querySelectorAll('tbody .row-checkbox');
            checkboxes.forEach(checkbox => {
              const row = checkbox.closest('tr');
              if (!row.classList.contains('filtered-out')) {
                checkbox.checked = headerCheckbox.checked;
                if (headerCheckbox.checked) {
                  this.selectedRows.add(row);
                  row.classList.add('selected');
                } else {
                  this.selectedRows.delete(row);
                  row.classList.remove('selected');
                }
              }
            });
            this.updateBar();
          });
        });
      },

      updateBar() {
        const count = this.selectedRows.size;
        document.getElementById('bulk-count').textContent = count;

        if (count > 0) {
          this.bar.classList.add('show');
        } else {
          this.bar.classList.remove('show');
        }
      },

      clearSelection() {
        this.selectedRows.forEach(row => {
          row.classList.remove('selected');
          const checkbox = row.querySelector('.row-checkbox');
          if (checkbox) checkbox.checked = false;
        });
        this.selectedRows.clear();

        // Uncheck header checkboxes
        document.querySelectorAll('.row-checkbox-header').forEach(cb => cb.checked = false);

        this.updateBar();
      },

      getSelectedData() {
        return Array.from(this.selectedRows).map(row => ({
          uid: row.querySelector('.uid-badge')?.textContent || '',
          account: row.querySelector('.cell-primary')?.textContent || '',
          hostname: row.querySelector('.hostname')?.textContent?.trim() || '',
          location: row.dataset.location || '',
          prom: row.dataset.prom || '',
          time: row.dataset.time || '',
          services: row.dataset.services || ''
        }));
      },

      silenceSelected() {
        const hostnames = this.getSelectedData().map(a => a.hostname);
        if (hostnames.length === 0) return;

        // For now, silence one at a time (could be batched with API)
        const form = document.createElement('form');
        form.method = 'POST';
        form.style.display = 'none';

        hostnames.forEach(hostname => {
          const input = document.createElement('input');
          input.name = 'silence-alert';
          input.value = hostname;
          form.appendChild(input);
        });

        document.body.appendChild(form);
        showToast(`Silencing ${hostnames.length} alert(s)...`, 'success');
        form.submit();
      },

      unsilenceSelected() {
        const hostnames = this.getSelectedData().map(a => a.hostname);
        if (hostnames.length === 0) return;

        const form = document.createElement('form');
        form.method = 'POST';
        form.style.display = 'none';

        hostnames.forEach(hostname => {
          const input = document.createElement('input');
          input.name = 'remove-silence';
          input.value = hostname;
          form.appendChild(input);
        });

        document.body.appendChild(form);
        showToast(`Unsilencing ${hostnames.length} alert(s)...`, 'success');
        form.submit();
      },

      createIncident() {
        const data = this.getSelectedData();
        if (data.length < 2) {
          showToast('Select at least 2 alerts to create an incident', 'error');
          return;
        }

        // Use IncidentManager to create incident
        IncidentManager.createFromAlerts(data);
        this.clearSelection();
        showToast(`Created incident with ${data.length} alerts`, 'success');
      },

      copySelected() {
        const data = this.getSelectedData();
        if (data.length === 0) return;

        const text = data.map(a =>
          `${a.hostname} | ${a.account} | ${a.services} | ${a.time}`
        ).join('\n');

        navigator.clipboard.writeText(text).then(() => {
          showToast(`Copied ${data.length} alert(s) to clipboard`, 'success');
        }).catch(() => {
          showToast('Failed to copy to clipboard', 'error');
        });
      }
    };

    // ========================================
    // NEW ALERTS INDICATOR
    // ========================================

    const NewAlertsIndicator = {
      banner: null,
      knownAlerts: new Set(),
      newAlerts: [],
      storageKey: 'prometheos-known-alerts',

      init() {
        this.banner = document.getElementById('new-alerts-banner');

        // Load known alerts from localStorage
        this.loadKnownAlerts();

        // Check for new alerts on page load
        this.checkForNewAlerts();

        // Save current alerts before page unload
        window.addEventListener('beforeunload', () => this.saveKnownAlerts());
      },

      loadKnownAlerts() {
        try {
          const saved = localStorage.getItem(this.storageKey);
          if (saved) {
            const data = JSON.parse(saved);
            // Only use saved data if it's less than 1 hour old
            if (data.timestamp && (Date.now() - data.timestamp) < 3600000) {
              this.knownAlerts = new Set(data.alerts || []);
              return;
            }
          }
        } catch (e) {
          console.warn('Failed to load known alerts:', e);
        }

        // If no valid saved data, initialize from current alerts (first load)
        this.initializeFromCurrentAlerts();
      },

      initializeFromCurrentAlerts() {
        document.querySelectorAll('#active-table tbody tr').forEach(row => {
          const id = this.getAlertId(row);
          if (id) this.knownAlerts.add(id);
        });
        this.saveKnownAlerts();
      },

      saveKnownAlerts() {
        try {
          // Keep only alerts that still exist in the DOM plus new ones
          const currentIds = new Set();
          document.querySelectorAll('#active-table tbody tr').forEach(row => {
            const id = this.getAlertId(row);
            if (id) currentIds.add(id);
          });

          // Merge with known (in case some alerts were dismissed but still exist)
          const toSave = [...currentIds];

          localStorage.setItem(this.storageKey, JSON.stringify({
            alerts: toSave,
            timestamp: Date.now()
          }));
        } catch (e) {
          console.warn('Failed to save known alerts:', e);
        }
      },

      getAlertId(row) {
        const hostname = row.querySelector('.hostname')?.textContent?.trim();
        const time = row.dataset.time;
        return hostname && time ? `${hostname}-${time}` : null;
      },

      checkForNewAlerts() {
        this.newAlerts = [];

        document.querySelectorAll('#active-table tbody tr').forEach(row => {
          const id = this.getAlertId(row);
          if (id && !this.knownAlerts.has(id)) {
            this.newAlerts.push(row);
            row.classList.add('new-alert');
          }
        });

        if (this.newAlerts.length > 0) {
          this.show();
        }
      },

      show() {
        if (this.banner) {
          document.getElementById('new-alerts-count').textContent = this.newAlerts.length;
          this.banner.classList.add('show');
        }
      },

      dismiss() {
        if (this.banner) {
          this.banner.classList.remove('show');
          // Add new alerts to known set
          this.newAlerts.forEach(row => {
            const id = this.getAlertId(row);
            if (id) this.knownAlerts.add(id);
            row.classList.remove('new-alert');
          });
          this.newAlerts = [];
          this.saveKnownAlerts();
        }
      },

      scrollToNew() {
        if (this.newAlerts.length > 0) {
          this.newAlerts[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
          this.dismiss();
        }
      }
    };

    // ========================================
    // URL STATE MANAGER
    // ========================================

    const URLState = {
      init() {
        // Read state from URL on load
        this.loadFromURL();

        // Update URL when state changes (debounced)
        this.setupListeners();

        // Handle browser back/forward
        window.addEventListener('popstate', () => this.loadFromURL());
      },

      loadFromURL() {
        const params = new URLSearchParams(window.location.search);

        // Tab
        const tab = params.get('tab');
        if (tab === 'silenced') {
          document.querySelectorAll('.tab-btn')[1]?.click();
        }

        // Search
        const search = params.get('q');
        if (search) {
          const searchBox = document.getElementById('search-box');
          if (searchBox) {
            searchBox.value = search;
          }
        }

        // Time range
        const range = params.get('range');
        if (range && TimeRangeManager.rangeMs[range]) {
          TimeRangeManager.setRange(range);
        }

        // Theme
        const theme = params.get('theme');
        if (theme === 'dark' || theme === 'light') {
          ThemeManager.setTheme(theme);
        }

        // Density
        const density = params.get('density');
        if (['compact', 'comfortable', 'spacious'].includes(density)) {
          DensityManager.setDensity(density);
        }

        // Filters
        const location = params.get('location');
        const account = params.get('account');
        const service = params.get('service');
        const prom = params.get('prom');

        if (location || account || service || prom) {
          // Open filters panel and set values
          if (location) {
            const el = document.getElementById('filter-location');
            if (el) el.value = location;
          }
          if (account) {
            const el = document.getElementById('filter-account');
            if (el) el.value = account;
          }
          if (service) {
            const el = document.getElementById('filter-service');
            if (el) el.value = service;
          }
          if (prom) {
            const el = document.getElementById('filter-prom');
            if (el) el.value = prom;
          }
        }

        // Apply filters if any URL state was loaded (including search)
        if (search || location || account || service || prom) {
          setTimeout(() => FilterManager.apply(), 100);
        }
      },

      setupListeners() {
        // Search box
        const searchBox = document.getElementById('search-box');
        if (searchBox) {
          searchBox.addEventListener('input', this.debounce(() => this.updateURL(), 500));
        }

        // Tab buttons
        document.querySelectorAll('.tab-btn').forEach(btn => {
          btn.addEventListener('click', () => this.updateURL());
        });

        // Filter changes
        ['filter-location', 'filter-account', 'filter-service', 'filter-prom'].forEach(id => {
          const el = document.getElementById(id);
          if (el) {
            el.addEventListener('change', () => this.updateURL());
          }
        });
      },

      updateURL() {
        const params = new URLSearchParams();

        // Tab
        const activeTab = document.querySelector('.tab-btn.active');
        if (activeTab?.textContent?.toLowerCase().includes('silenced')) {
          params.set('tab', 'silenced');
        }

        // Search
        const search = document.getElementById('search-box')?.value;
        if (search) params.set('q', search);

        // Time range
        if (TimeRangeManager.current !== '24h') {
          params.set('range', TimeRangeManager.current);
        }

        // Filters
        const location = document.getElementById('filter-location')?.value;
        const account = document.getElementById('filter-account')?.value;
        const service = document.getElementById('filter-service')?.value;
        const prom = document.getElementById('filter-prom')?.value;

        if (location) params.set('location', location);
        if (account) params.set('account', account);
        if (service) params.set('service', service);
        if (prom) params.set('prom', prom);

        // Update URL without reload
        const newURL = params.toString()
          ? `${window.location.pathname}?${params.toString()}`
          : window.location.pathname;

        window.history.replaceState({}, '', newURL);
      },

      getShareableURL() {
        this.updateURL();
        return window.location.href;
      },

      copyShareableURL() {
        const url = this.getShareableURL();
        navigator.clipboard.writeText(url).then(() => {
          showToast('Dashboard URL copied to clipboard', 'success');
        }).catch(() => {
          showToast('Failed to copy URL', 'error');
        });
      },

      debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }
    };

    // ========================================
    // TAB SWITCHING
    // ========================================

    function openAlerts(evt, alertType) {
      const panels = document.querySelectorAll('.tab-panel');
      panels.forEach(panel => {
        panel.style.display = 'none';
      });

      const tabs = document.querySelectorAll('.tab-btn');
      tabs.forEach(tab => {
        tab.classList.remove('active');
      });

      document.getElementById(alertType).style.display = 'block';
      evt.currentTarget.classList.add('active');
    }

    // ========================================
    // TABLE SORTING
    // ========================================

    // Helper function to parse duration strings to seconds for sorting
    function parseDurationToSeconds(durationStr) {
      if (!durationStr || durationStr === 'new' || durationStr === '--') return 0;

      let totalSeconds = 0;
      const str = durationStr.toLowerCase();

      // Parse days: "1d", "2d 5h"
      const dayMatch = str.match(/(\d+)d/);
      if (dayMatch) totalSeconds += parseInt(dayMatch[1]) * 24 * 60 * 60;

      // Parse hours: "5h", "2h 30m"
      const hourMatch = str.match(/(\d+)h/);
      if (hourMatch) totalSeconds += parseInt(hourMatch[1]) * 60 * 60;

      // Parse minutes: "30m"
      const minMatch = str.match(/(\d+)m/);
      if (minMatch) totalSeconds += parseInt(minMatch[1]) * 60;

      // Parse seconds: "45s"
      const secMatch = str.match(/(\d+)s/);
      if (secMatch) totalSeconds += parseInt(secMatch[1]);

      return totalSeconds;
    }

    const sortStates = {};

    function sortTable(tableId, columnIndex) {
      const table = document.getElementById(tableId);
      const tbody = table.querySelector('tbody');
      const rows = Array.from(tbody.querySelectorAll('tr:not(.filtered-out)'));
      const th = table.querySelectorAll('th')[columnIndex];

      const stateKey = `${tableId}-${columnIndex}`;
      if (!sortStates[stateKey]) {
        sortStates[stateKey] = 'asc';
      } else {
        sortStates[stateKey] = sortStates[stateKey] === 'asc' ? 'desc' : 'asc';
      }

      const direction = sortStates[stateKey];

      // Save sort preference for current preset (so it persists when switching presets)
      if (typeof ViewPresets !== 'undefined') {
        ViewPresets.saveCurrentSort(columnIndex, direction);
      }

      table.querySelectorAll('th').forEach(header => {
        header.classList.remove('asc', 'desc');
      });
      th.classList.add(direction);

      rows.sort((a, b) => {
        const aVal = a.cells[columnIndex].textContent.trim().toLowerCase();
        const bVal = b.cells[columnIndex].textContent.trim().toLowerCase();

        // Special handling for duration column - parse duration values
        const durationPattern = /^(\d+)([smhd])\s*(?:(\d+)([mh]))?$/i;
        const aIsNew = aVal === 'new' || aVal === '--';
        const bIsNew = bVal === 'new' || bVal === '--';

        // Handle NEW alerts - they should always come first in ascending (newest first)
        if (aIsNew && bIsNew) return 0;
        if (aIsNew) return direction === 'asc' ? -1 : 1;
        if (bIsNew) return direction === 'asc' ? 1 : -1;

        // Parse duration values like "5m", "2h 30m", "1d 5h"
        const aDurMatch = aVal.match(durationPattern);
        const bDurMatch = bVal.match(durationPattern);

        if (aDurMatch && bDurMatch) {
          const aSeconds = parseDurationToSeconds(aVal);
          const bSeconds = parseDurationToSeconds(bVal);
          return direction === 'asc' ? aSeconds - bSeconds : bSeconds - aSeconds;
        }

        const datePattern = /^\d{4}-\d{2}-\d{2}/;
        if (datePattern.test(aVal) && datePattern.test(bVal)) {
          const aDate = new Date(aVal.replace(' ', 'T'));
          const bDate = new Date(bVal.replace(' ', 'T'));
          return direction === 'asc' ? aDate - bDate : bDate - aDate;
        }

        if (aVal < bVal) return direction === 'asc' ? -1 : 1;
        if (aVal > bVal) return direction === 'asc' ? 1 : -1;
        return 0;
      });

      rows.forEach(row => tbody.appendChild(row));
    }

    // ========================================
    // FILTERING
    // ========================================

    const FilterManager = {
      filters: {
        datacenter: '',
        section: '',
        row: '',
        rack: '',
        prom: '',
        time: '',
        service: '',
        search: ''  // Client-side text search
      },

      searchDebounceTimer: null,

      init() {
        this.populateFilterOptions();

        document.getElementById('filter-toggle').addEventListener('click', () => {
          this.togglePanel();
        });

        // Apply filters when search changes (with debounce for performance)
        const searchBox = document.getElementById('search-box');
        if (searchBox) {
          searchBox.addEventListener('input', () => {
            // Debounce search filtering to avoid filtering on every keystroke
            clearTimeout(this.searchDebounceTimer);
            this.searchDebounceTimer = setTimeout(() => {
              this.apply();
            }, 150);
          });
        }
      },

      togglePanel() {
        const panel = document.getElementById('filters-panel');
        panel.classList.toggle('show');
      },

      // Parse location code: B3S2R9K8U27 -> { datacenter, section, row, rack }
      parseLocation(location) {
        if (!location) return null;
        const match = location.match(/^B(\d+)S(\d+)R(\d+)K(\d+)(?:U(\d+))?$/i);
        if (!match) return null;
        return {
          datacenter: `B${match[1]}`,
          section: `B${match[1]}S${match[2]}`,
          row: `B${match[1]}S${match[2]}R${match[3]}`,
          rack: `B${match[1]}S${match[2]}R${match[3]}K${match[4]}`
        };
      },

      // Parse search string into include/exclude terms (! prefix for exclusion)
      parseSearchTerms(searchStr) {
        const include = [];
        const exclude = [];
        if (!searchStr) return { include, exclude };

        // Split by spaces, respecting the ! prefix
        const terms = searchStr.split(/\s+/).filter(t => t.length > 0);
        terms.forEach(term => {
          if (term.startsWith('!') && term.length > 1) {
            exclude.push(term.substring(1));
          } else {
            include.push(term);
          }
        });

        return { include, exclude };
      },

      populateFilterOptions() {
        const rows = document.querySelectorAll('#active-table tbody tr, #silenced-table tbody tr');
        const datacenters = new Set();
        const sections = new Set();
        const rowsSet = new Set();
        const racks = new Set();
        const proms = new Set();
        const services = new Set();

        rows.forEach(row => {
          if (row.dataset.location) {
            const parsed = this.parseLocation(row.dataset.location);
            if (parsed) {
              datacenters.add(parsed.datacenter);
              sections.add(parsed.section);
              rowsSet.add(parsed.row);
              racks.add(parsed.rack);
            }
          }
          if (row.dataset.prom) proms.add(row.dataset.prom);
          if (row.dataset.services) {
            row.dataset.services.split(',').forEach(s => {
              if (s.trim()) services.add(s.trim());
            });
          }
        });

        this.populateSelect('filter-datacenter', Array.from(datacenters).sort());
        this.populateSelect('filter-section', Array.from(sections).sort());
        this.populateSelect('filter-row', Array.from(rowsSet).sort());
        this.populateSelect('filter-rack', Array.from(racks).sort());
        this.populateSelect('filter-prom', Array.from(proms).sort());
        this.populateSelect('filter-service', Array.from(services).sort());
      },

      populateSelect(selectId, options) {
        const select = document.getElementById(selectId);
        const currentValue = select.value;

        // Keep the first "All" option
        while (select.options.length > 1) {
          select.remove(1);
        }

        options.forEach(opt => {
          const option = document.createElement('option');
          option.value = opt;
          option.textContent = opt;
          select.appendChild(option);
        });

        select.value = currentValue;
      },

      apply() {
        this.filters.datacenter = document.getElementById('filter-datacenter')?.value || '';
        this.filters.section = document.getElementById('filter-section')?.value || '';
        this.filters.row = document.getElementById('filter-row')?.value || '';
        this.filters.rack = document.getElementById('filter-rack')?.value || '';
        this.filters.prom = document.getElementById('filter-prom')?.value || '';
        this.filters.time = document.getElementById('filter-time')?.value || '';
        this.filters.service = document.getElementById('filter-service')?.value || '';
        this.filters.search = document.getElementById('search-box')?.value?.trim() || '';

        const rows = document.querySelectorAll('#active-table tbody tr, #silenced-table tbody tr');

        // Parse search terms (support ! for exclusion)
        const searchTerms = this.filters.search ? this.parseSearchTerms(this.filters.search) : { include: [], exclude: [] };

        rows.forEach(row => {
          let show = true;
          const location = row.dataset.location || '';
          const parsed = this.parseLocation(location);

          // Location hierarchy filters
          if (this.filters.datacenter && parsed) {
            if (parsed.datacenter !== this.filters.datacenter) show = false;
          }
          if (this.filters.section && parsed) {
            if (parsed.section !== this.filters.section) show = false;
          }
          if (this.filters.row && parsed) {
            if (parsed.row !== this.filters.row) show = false;
          }
          if (this.filters.rack && parsed) {
            if (parsed.rack !== this.filters.rack) show = false;
          }

          if (this.filters.prom && row.dataset.prom !== this.filters.prom) {
            show = false;
          }

          if (this.filters.service) {
            const rowServices = row.dataset.services ? row.dataset.services.split(',') : [];
            if (!rowServices.includes(this.filters.service)) {
              show = false;
            }
          }

          if (this.filters.time && row.dataset.time) {
            const alertTime = new Date(row.dataset.time.replace(' ', 'T'));
            const now = new Date();
            let cutoff;

            switch (this.filters.time) {
              case '1h': cutoff = new Date(now - 60 * 60 * 1000); break;
              case '6h': cutoff = new Date(now - 6 * 60 * 60 * 1000); break;
              case '24h': cutoff = new Date(now - 24 * 60 * 60 * 1000); break;
              case '7d': cutoff = new Date(now - 7 * 24 * 60 * 60 * 1000); break;
            }

            if (cutoff && alertTime < cutoff) {
              show = false;
            }
          }

          // Client-side text search filter
          if (show && (searchTerms.include.length > 0 || searchTerms.exclude.length > 0)) {
            const rowText = row.textContent.toLowerCase();

            // Must include all include terms
            for (const term of searchTerms.include) {
              if (!rowText.includes(term.toLowerCase())) {
                show = false;
                break;
              }
            }

            // Must not include any exclude terms
            if (show) {
              for (const term of searchTerms.exclude) {
                if (rowText.includes(term.toLowerCase())) {
                  show = false;
                  break;
                }
              }
            }
          }

          row.classList.toggle('filtered-out', !show);
        });

        this.updateActiveFilterTags();
        this.updateFilterBadge();
        this.updateClearAllButton();
        updateCounts();

        // Reapply stale alerts grouping after filter changes
        if (typeof StaleAlertsManager !== 'undefined') {
          StaleAlertsManager.refresh();
        }
      },

      updateActiveFilterTags() {
        const container = document.getElementById('active-filters');
        container.innerHTML = '';

        const activeFilters = [];

        if (this.filters.datacenter) {
          activeFilters.push({ type: 'datacenter', label: `DC: ${this.filters.datacenter}` });
        }
        if (this.filters.section) {
          activeFilters.push({ type: 'section', label: `Section: ${this.filters.section}` });
        }
        if (this.filters.row) {
          activeFilters.push({ type: 'row', label: `Row: ${this.filters.row}` });
        }
        if (this.filters.rack) {
          activeFilters.push({ type: 'rack', label: `Rack: ${this.filters.rack}` });
        }
        if (this.filters.prom) {
          activeFilters.push({ type: 'prom', label: `Node: ${simplifyPromName(this.filters.prom)}` });
        }
        if (this.filters.time) {
          const timeLabels = { '1h': 'Last 1 Hour', '6h': 'Last 6 Hours', '24h': 'Last 24 Hours', '7d': 'Last 7 Days' };
          activeFilters.push({ type: 'time', label: timeLabels[this.filters.time] });
        }
        if (this.filters.service) {
          activeFilters.push({ type: 'service', label: `Service: ${this.filters.service}` });
        }
        if (this.filters.search) {
          // Truncate long search terms for display
          const displaySearch = this.filters.search.length > 20
            ? this.filters.search.substring(0, 20) + '...'
            : this.filters.search;
          activeFilters.push({ type: 'search', label: `Search: ${displaySearch}` });
        }

        activeFilters.forEach(filter => {
          const tag = document.createElement('div');
          tag.className = 'active-filter-tag';
          tag.innerHTML = `
            <span>${filter.label}</span>
            <button type="button" onclick="removeFilter('${filter.type}')">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
          `;
          container.appendChild(tag);
        });
      },

      updateFilterBadge() {
        const count = Object.values(this.filters).filter(v => v).length;
        const badge = document.getElementById('filter-badge');
        badge.textContent = count;
        badge.classList.toggle('show', count > 0);
      },

      clearAll() {
        // Clear filter dropdowns
        const filterIds = ['filter-datacenter', 'filter-section', 'filter-row', 'filter-rack', 'filter-prom', 'filter-time', 'filter-service'];
        filterIds.forEach(id => {
          const el = document.getElementById(id);
          if (el) el.value = '';
        });

        // Clear search box
        const searchBox = document.getElementById('search-box');
        if (searchBox) {
          searchBox.value = '';
        }

        // Reset all filter state including search
        this.filters = { datacenter: '', section: '', row: '', rack: '', prom: '', time: '', service: '', search: '' };

        // Remove filtered-out class from all rows to show everything
        document.querySelectorAll('#active-table tbody tr, #silenced-table tbody tr').forEach(row => {
          row.classList.remove('filtered-out');
        });

        this.updateActiveFilterTags();
        this.updateFilterBadge();
        this.updateClearAllButton();
        // Note: updateCounts() and StaleAlertsManager.refresh() are called by clearAllFilters()
        // after all view changes are complete to ensure correct final state
      },

      updateClearAllButton() {
        // Check if any filter is active (including search which is now part of filters)
        const hasFilters = Object.values(this.filters).some(v => v);
        // Also check if grouping is active (Location/Account Focus views)
        const hasGrouping = typeof GroupingManager !== 'undefined' && GroupingManager.currentGrouping;
        // Also check if quick filters are active
        const hasQuickFilter = typeof QuickFilters !== 'undefined' && QuickFilters.isActive();
        const clearBtn = document.getElementById('clear-all-btn');
        if (clearBtn) {
          clearBtn.classList.toggle('show', hasFilters || hasGrouping || hasQuickFilter);
        }
      }
    };

    function applyFilters() {
      FilterManager.apply();
    }

    function clearAllFilters() {
      // Clear all filter dropdowns
      const filterIds = ['filter-datacenter', 'filter-section', 'filter-row', 'filter-rack', 'filter-prom', 'filter-time', 'filter-service'];
      filterIds.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.value = '';
      });

      // Clear search box
      const searchBox = document.getElementById('search-box');
      if (searchBox) {
        searchBox.value = '';
      }

      // Clear quick filters (priority-based filtering)
      if (typeof QuickFilters !== 'undefined') {
        QuickFilters.clear(false);
      }

      // Use FilterManager.apply() to properly update the data table
      // This ensures the same code path as individual filter clears
      FilterManager.apply();

      // Also reset to Detailed view if in a grouped view
      if (typeof GroupingManager !== 'undefined' && GroupingManager.currentGrouping) {
        ViewPresets.apply('detailed');
      }

      showToast('All filters and search cleared', 'success');
    }

    function removeFilter(type) {
      if (type === 'search') {
        // Handle search box specially
        const searchBox = document.getElementById('search-box');
        if (searchBox) {
          searchBox.value = '';
        }
        FilterManager.filters.search = '';
      } else {
        const el = document.getElementById(`filter-${type}`);
        if (el) {
          el.value = '';
          FilterManager.filters[type] = '';
        }
      }
      FilterManager.apply();
    }

    function toggleFiltersPanel() {
      FilterManager.togglePanel();
    }

    // ========================================
    // PROM NAME SIMPLIFICATION
    // ========================================

    // Simplify full prom name to short form: n01.b3.alertmanager.pro.mon.liquidweb.com -> n01.b3
    function simplifyPromName(fullName) {
      if (!fullName) return '';
      const parts = fullName.split('.');
      if (parts.length >= 2) {
        return `${parts[0]}.${parts[1]}`;
      }
      return fullName;
    }

    // Initialize prom display names in table cells
    function initPromDisplayNames() {
      document.querySelectorAll('.cell-prom').forEach(cell => {
        const fullName = cell.dataset.promFull || '';
        const shortName = simplifyPromName(fullName);
        const display = cell.querySelector('.prom-display');
        if (display) {
          display.innerHTML = `<span class="prom-short">${shortName}</span>`;
          display.title = fullName; // Show full name on hover
        }
      });
    }

    // Parse location code and populate separate location columns
    function initLocationDisplayCells() {
      // Parse location code: B3S2R9K8U27 -> { datacenter: B3, section: S2, row: R9, rack: K8 }
      function parseLocationParts(location) {
        if (!location) return null;
        const match = location.match(/^B(\d+)S(\d+)R(\d+)K(\d+)(?:U(\d+))?$/i);
        if (!match) return null;
        return {
          datacenter: `B${match[1]}`,
          section: `S${match[2]}`,
          row: `R${match[3]}`,
          rack: `K${match[4]}`
        };
      }

      // Process all rows that have location cells
      document.querySelectorAll('.cell-datacenter').forEach(cell => {
        const location = cell.dataset.location || '';
        const parsed = parseLocationParts(location);
        cell.textContent = parsed ? parsed.datacenter : '-';
        cell.title = location; // Show full location on hover
      });

      document.querySelectorAll('.cell-section').forEach(cell => {
        const location = cell.dataset.location || '';
        const parsed = parseLocationParts(location);
        cell.textContent = parsed ? parsed.section : '-';
        cell.title = location;
      });

      document.querySelectorAll('.cell-row').forEach(cell => {
        const location = cell.dataset.location || '';
        const parsed = parseLocationParts(location);
        cell.textContent = parsed ? parsed.row : '-';
        cell.title = location;
      });

      document.querySelectorAll('.cell-rack').forEach(cell => {
        const location = cell.dataset.location || '';
        const parsed = parseLocationParts(location);
        cell.textContent = parsed ? parsed.rack : '-';
        cell.title = location;
      });
    }

    // ========================================
    // STATUS CARDS NAVIGATION
    // ========================================

    const StatusCards = {
      goToActiveAlerts() {
        // Switch to active tab and scroll to table
        const activeTab = document.querySelector('.tab-btn');
        if (activeTab) activeTab.click();

        const table = document.getElementById('active-table');
        if (table) {
          table.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        showToast('Viewing active alerts', 'info');
      },

      goToAffectedServers() {
        // Switch to active tab and focus on unique hostnames
        const activeTab = document.querySelector('.tab-btn');
        if (activeTab) activeTab.click();

        // Show unique servers count
        const rows = document.querySelectorAll('#active-table tbody tr:not(.filtered-out)');
        const hosts = new Set();
        rows.forEach(row => {
          const hostname = row.querySelector('.hostname')?.textContent.trim();
          if (hostname) hosts.add(hostname);
        });

        const table = document.getElementById('active-table');
        if (table) {
          table.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        showToast(`${hosts.size} unique servers affected`, 'info');
      },

      goToIncidents() {
        // Expand incidents section and scroll to it
        const incidentsSection = document.getElementById('incidents-section');
        if (incidentsSection) {
          // Ensure section is expanded
          const content = incidentsSection.querySelector('.section-content');
          if (content && content.style.display === 'none') {
            SectionManager.toggle('incidents');
          }
          incidentsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        showToast('Viewing incidents', 'info');
      },

      goToSilenced() {
        // Switch to silenced tab
        const silencedTab = document.querySelectorAll('.tab-btn')[1];
        if (silencedTab) silencedTab.click();

        const table = document.getElementById('silenced-table');
        if (table) {
          table.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        showToast('Viewing silenced alerts', 'info');
      }
    };

    // ========================================
    // ALERT MANAGERS MODAL
    // ========================================

    const AlertManagersModal = {
      alertManagers: [
        'c01.b3.alertmanager.pro.mon.liquidweb.com',
        'c02.b3.alertmanager.pro.mon.liquidweb.com',
        'n01.b2.alertmanager.pro.mon.liquidweb.com',
        'n01.b3.alertmanager.pro.mon.liquidweb.com',
        'n01.b4.alertmanager.pro.mon.liquidweb.com',
        'n01.b5.alertmanager.pro.mon.liquidweb.com',
        'n02.b2.alertmanager.pro.mon.liquidweb.com',
        'n02.b3.alertmanager.pro.mon.liquidweb.com',
        'n02.b4.alertmanager.pro.mon.liquidweb.com',
        'n02.b5.alertmanager.pro.mon.liquidweb.com',
        'n03.b3.alertmanager.pro.mon.liquidweb.com',
        'n04.b3.alertmanager.pro.mon.liquidweb.com',
        'n05.b3.alertmanager.pro.mon.liquidweb.com',
        'n06.b3.alertmanager.pro.mon.liquidweb.com',
        'n07.b3.alertmanager.pro.mon.liquidweb.com',
        'n08.b3.alertmanager.pro.mon.liquidweb.com'
      ],

      promStats: {},

      init() {
        this.collectStats();
      },

      collectStats() {
        this.promStats = {};
        const rows = document.querySelectorAll('#active-table tbody tr, #silenced-table tbody tr');

        // Count alerts per prometheus node
        rows.forEach(row => {
          const prom = row.dataset.prom;
          const timeStr = row.dataset.time;

          if (prom) {
            if (!this.promStats[prom]) {
              this.promStats[prom] = { count: 0, lastSeen: null };
            }
            this.promStats[prom].count++;
            if (timeStr) {
              const alertTime = new Date(timeStr.replace(' ', 'T'));
              if (!this.promStats[prom].lastSeen || alertTime > this.promStats[prom].lastSeen) {
                this.promStats[prom].lastSeen = alertTime;
              }
            }
          }
        });
      },

      open() {
        this.collectStats();
        this.render();
        document.getElementById('alert-managers-modal').classList.add('show');
      },

      close() {
        document.getElementById('alert-managers-modal').classList.remove('show');
      },

      render() {
        const amList = document.getElementById('am-list');
        const promList = document.getElementById('prom-list');
        const amCount = document.getElementById('am-total-count');
        const promCount = document.getElementById('prom-total-count');
        const totalAlerts = document.getElementById('am-total-alerts');

        // Render Alert Managers (simple list)
        amList.innerHTML = this.alertManagers.map(am => {
          const shortName = simplifyPromName(am);
          return `<span class="am-tag" title="${am}">${shortName}</span>`;
        }).join('');

        amCount.textContent = this.alertManagers.length;

        // Render Prometheus Nodes with alerts
        const promNodes = Object.keys(this.promStats);
        let totalAlertCount = 0;

        // Sort by alert count descending
        const sortedProms = promNodes.sort((a, b) => {
          return (this.promStats[b]?.count || 0) - (this.promStats[a]?.count || 0);
        });

        promList.innerHTML = sortedProms.map(prom => {
          const stat = this.promStats[prom];
          const shortName = simplifyPromName(prom);
          totalAlertCount += stat.count;

          return `
            <div class="prom-item" onclick="AlertManagersModal.filterByProm('${prom}')">
              <span class="prom-name" title="${prom}">${shortName}</span>
              <span class="prom-alert-count">${stat.count}</span>
            </div>
          `;
        }).join('');

        if (sortedProms.length === 0) {
          promList.innerHTML = '<div class="prom-empty">No active alerts from any Prometheus node</div>';
        }

        promCount.textContent = sortedProms.length;
        totalAlerts.textContent = totalAlertCount;

        // Update the card count
        const cardCount = document.getElementById('alert-managers-count');
        if (cardCount) cardCount.textContent = this.alertManagers.length;
      },

      filterByProm(prom) {
        this.close();

        // Set the prom filter and apply
        const promFilter = document.getElementById('filter-prom');
        if (promFilter) {
          promFilter.value = prom;
          FilterManager.apply();
        }

        showToast(`Filtered by ${simplifyPromName(prom)}`, 'success');
      }
    };

    // ========================================
    // INSIGHT CARDS
    // ========================================

    const InsightCards = {
      alertData: [],

      init() {
        // Insight cards are updated via updateInsightCards() called from updateMetrics()
      },

      update(alertData) {
        this.alertData = alertData;
        this.updateOldestAlerts();
        this.updateRecurringSystems();
        this.updateRecentAlerts();
        this.updateAffectedAccounts();
      },

      updateOldestAlerts() {
        const card = document.getElementById('oldest-alerts-card');
        const list = document.getElementById('oldest-alerts-list');
        const badge = document.getElementById('oldest-alerts-badge');

        if (this.alertData.length === 0) {
          card.classList.remove('show');
          return;
        }

        // Sort by duration descending and get top 5
        const sorted = [...this.alertData].sort((a, b) => b.duration - a.duration).slice(0, 5);

        // Only show if there are alerts > 1 hour old
        const oldAlerts = sorted.filter(a => a.duration >= 60 * 60 * 1000);
        if (oldAlerts.length === 0) {
          card.classList.remove('show');
          return;
        }

        badge.textContent = oldAlerts.length;
        list.innerHTML = oldAlerts.map((alert, i) => `
          <li class="insight-list-item" onclick="InsightCards.openAlert('${alert.hostname}')">
            <span class="insight-rank ${i === 0 ? 'top' : ''}">${i + 1}</span>
            <div class="insight-item-info">
              <div class="insight-item-primary">${alert.hostname}</div>
              <div class="insight-item-secondary">${alert.account}</div>
            </div>
            <span class="insight-item-value">${formatDuration(alert.duration)}</span>
            <button class="insight-filter-btn" onclick="event.stopPropagation(); InsightCards.filterByHostname('${alert.hostname}')">Filter</button>
          </li>
        `).join('');

        card.classList.add('show');
      },

      updateRecurringSystems() {
        const card = document.getElementById('recurring-systems-card');
        const list = document.getElementById('recurring-systems-list');
        const badge = document.getElementById('recurring-systems-badge');

        // Group alerts by hostname and count unique services
        const hostServices = {};
        this.alertData.forEach(alert => {
          if (!hostServices[alert.hostname]) {
            hostServices[alert.hostname] = {
              services: new Set(),
              account: alert.account,
              alertCount: 0
            };
          }
          alert.services.split(',').forEach(s => {
            if (s.trim()) hostServices[alert.hostname].services.add(s.trim());
          });
          hostServices[alert.hostname].alertCount++;
        });

        // Filter to hosts with 2+ services
        const recurring = Object.entries(hostServices)
          .filter(([_, data]) => data.services.size >= 2)
          .map(([hostname, data]) => ({
            hostname,
            account: data.account,
            serviceCount: data.services.size,
            services: Array.from(data.services).slice(0, 3).join(', ')
          }))
          .sort((a, b) => b.serviceCount - a.serviceCount)
          .slice(0, 5);

        if (recurring.length === 0) {
          card.classList.remove('show');
          return;
        }

        badge.textContent = recurring.length;
        list.innerHTML = recurring.map((item, i) => `
          <li class="insight-list-item" onclick="InsightCards.openAlert('${item.hostname}')">
            <span class="insight-rank ${i === 0 ? 'top' : ''}">${i + 1}</span>
            <div class="insight-item-info">
              <div class="insight-item-primary">${item.hostname}</div>
              <div class="insight-item-secondary">${item.services}${item.serviceCount > 3 ? '...' : ''}</div>
            </div>
            <span class="insight-item-value" style="color: var(--warning);">${item.serviceCount} svc</span>
            <button class="insight-filter-btn" onclick="event.stopPropagation(); InsightCards.filterByHostname('${item.hostname}')">Filter</button>
          </li>
        `).join('');

        card.classList.add('show');
      },

      updateRecentAlerts() {
        const card = document.getElementById('recent-alerts-card');
        const list = document.getElementById('recent-alerts-list');
        const badge = document.getElementById('recent-alerts-badge');

        if (this.alertData.length === 0) {
          card.classList.remove('show');
          return;
        }

        // Sort by time descending (most recent first) and get top 5
        const now = new Date();
        const oneHourAgo = new Date(now - 60 * 60 * 1000);
        const recentAlerts = [...this.alertData]
          .filter(a => a.time >= oneHourAgo)
          .sort((a, b) => b.time - a.time)
          .slice(0, 5);

        if (recentAlerts.length === 0) {
          card.classList.remove('show');
          return;
        }

        badge.textContent = recentAlerts.length;
        list.innerHTML = recentAlerts.map((alert, i) => {
          const ago = Math.floor((now - alert.time) / 60000); // minutes ago
          const agoStr = ago < 60 ? `${ago}m ago` : `${Math.floor(ago / 60)}h ago`;
          return `
            <li class="insight-list-item" onclick="InsightCards.openAlert('${alert.hostname}')">
              <span class="insight-rank ${i === 0 ? 'top' : ''}">${i + 1}</span>
              <div class="insight-item-info">
                <div class="insight-item-primary">${alert.hostname}</div>
                <div class="insight-item-secondary">${alert.services.split(',')[0] || 'alert'}</div>
              </div>
              <span class="insight-item-value info">${agoStr}</span>
              <button class="insight-filter-btn" onclick="event.stopPropagation(); InsightCards.filterByHostname('${alert.hostname}')">Filter</button>
            </li>
          `;
        }).join('');

        card.classList.add('show');
      },

      updateAffectedAccounts() {
        const card = document.getElementById('affected-accounts-card');
        const list = document.getElementById('affected-accounts-list');
        const badge = document.getElementById('affected-accounts-badge');

        if (this.alertData.length === 0) {
          card.classList.remove('show');
          return;
        }

        // Group by account
        const accountStats = {};
        this.alertData.forEach(alert => {
          if (!accountStats[alert.account]) {
            accountStats[alert.account] = { alertCount: 0, hosts: new Set() };
          }
          accountStats[alert.account].alertCount++;
          accountStats[alert.account].hosts.add(alert.hostname);
        });

        // Get top 5 by alert count
        const topAccounts = Object.entries(accountStats)
          .map(([account, data]) => ({
            account,
            alertCount: data.alertCount,
            hostCount: data.hosts.size
          }))
          .sort((a, b) => b.alertCount - a.alertCount)
          .slice(0, 5);

        if (topAccounts.length <= 1) {
          // Don't show if only 1 account (not interesting)
          card.classList.remove('show');
          return;
        }

        badge.textContent = topAccounts.length;
        list.innerHTML = topAccounts.map((item, i) => `
          <li class="insight-list-item" onclick="InsightCards.filterByAccount('${item.account}')">
            <span class="insight-rank ${i === 0 ? 'top' : ''}">${i + 1}</span>
            <div class="insight-item-info">
              <div class="insight-item-primary">${item.account}</div>
              <div class="insight-item-secondary">${item.hostCount} server${item.hostCount !== 1 ? 's' : ''}</div>
            </div>
            <span class="insight-item-value warning">${item.alertCount} alerts</span>
            <button class="insight-filter-btn" onclick="event.stopPropagation(); InsightCards.filterByAccount('${item.account}')">Filter</button>
          </li>
        `).join('');

        card.classList.add('show');
      },

      openAlert(hostname) {
        // Find the row and open the drawer
        const row = document.querySelector(`#active-table tbody tr .hostname`);
        const rows = document.querySelectorAll('#active-table tbody tr');
        for (const r of rows) {
          const hn = r.querySelector('.hostname')?.textContent.trim();
          if (hn === hostname) {
            AlertDrawer.openFromRow(r);
            return;
          }
        }
      },

      filterByHostname(hostname) {
        const searchBox = document.getElementById('search-box');
        searchBox.value = hostname;
        // Apply immediately for programmatic filter
        FilterManager.apply();
        showToast(`Filtered by: ${hostname}`, 'success');
      },

      filterByAccount(account) {
        const searchBox = document.getElementById('search-box');
        searchBox.value = account;
        // Apply immediately for programmatic filter
        FilterManager.apply();
        showToast(`Filtered by account: ${account}`, 'success');
      },

      sortByDuration() {
        sortTable('active-table', 11); // Duration column
        showToast('Sorted by duration', 'success');
      },

      sortByTime() {
        sortTable('active-table', 10); // Start Time column
        showToast('Sorted by start time', 'success');
      },

      sortByAccount() {
        sortTable('active-table', 2); // Account column
        showToast('Sorted by account', 'success');
      }
    };

    // ========================================
    // METRIC MODALS
    // ========================================

    const MetricModals = {
      alertData: [],
      oldestAlert: null,
      healthBreakdown: null,

      update(alertData) {
        this.alertData = alertData;
        if (alertData.length > 0) {
          this.oldestAlert = alertData.reduce((max, a) => a.duration > max.duration ? a : max);
        }
      },

      open(modalId) {
        document.getElementById(`${modalId}-modal`).classList.add('show');
      },

      close(modalId) {
        document.getElementById(`${modalId}-modal`).classList.remove('show');
      },

      openAvgDuration() {
        if (this.alertData.length === 0) {
          showToast('No active alerts', 'info');
          return;
        }

        const avgDuration = this.alertData.reduce((sum, a) => sum + a.duration, 0) / this.alertData.length;
        document.getElementById('modal-avg-duration').textContent = formatDuration(avgDuration);

        // Calculate distribution
        const buckets = {
          '< 1h': { count: 0, class: 'info' },
          '1-4h': { count: 0, class: 'info' },
          '4-12h': { count: 0, class: 'warning' },
          '12-24h': { count: 0, class: 'warning' },
          '> 24h': { count: 0, class: 'critical' }
        };

        this.alertData.forEach(a => {
          const hours = a.duration / (60 * 60 * 1000);
          if (hours < 1) buckets['< 1h'].count++;
          else if (hours < 4) buckets['1-4h'].count++;
          else if (hours < 12) buckets['4-12h'].count++;
          else if (hours < 24) buckets['12-24h'].count++;
          else buckets['> 24h'].count++;
        });

        const maxCount = Math.max(...Object.values(buckets).map(b => b.count), 1);
        const total = this.alertData.length;

        const distribution = document.getElementById('duration-distribution');
        distribution.innerHTML = Object.entries(buckets).map(([label, data]) => {
          const pct = Math.round((data.count / total) * 100);
          const width = Math.round((data.count / maxCount) * 100);
          return `
            <div class="metric-dist-row">
              <span class="metric-dist-label">${label}</span>
              <div class="metric-dist-bar-container">
                <div class="metric-dist-bar ${data.class}" style="width: ${Math.max(width, 5)}%"></div>
              </div>
              <span class="metric-dist-count">${data.count} (${pct}%)</span>
            </div>
          `;
        }).join('');

        this.open('avg-duration');
      },

      openOldestAlert() {
        if (!this.oldestAlert) {
          showToast('No active alerts', 'info');
          return;
        }

        document.getElementById('modal-oldest-duration').textContent = formatDuration(this.oldestAlert.duration);

        const details = document.getElementById('oldest-alert-details');
        details.innerHTML = `
          <li class="metric-detail-item">
            <span class="metric-detail-name">Hostname</span>
            <span class="metric-detail-value">${this.oldestAlert.hostname}</span>
          </li>
          <li class="metric-detail-item">
            <span class="metric-detail-name">Account</span>
            <span class="metric-detail-value">${this.oldestAlert.account}</span>
          </li>
          <li class="metric-detail-item">
            <span class="metric-detail-name">Services</span>
            <span class="metric-detail-value">${this.oldestAlert.services || '--'}</span>
          </li>
          <li class="metric-detail-item">
            <span class="metric-detail-name">Location</span>
            <span class="metric-detail-value">${this.oldestAlert.location || '--'}</span>
          </li>
          <li class="metric-detail-item">
            <span class="metric-detail-name">Started</span>
            <span class="metric-detail-value">${this.oldestAlert.time.toLocaleString()}</span>
          </li>
          <li class="metric-detail-item">
            <span class="metric-detail-name">Prom Node</span>
            <span class="metric-detail-value">${this.oldestAlert.prom || '--'}</span>
          </li>
        `;

        this.open('oldest-alert');
      },

      openVelocity() {
        const rangeMs = TimeRangeManager.getRangeMs();
        const now = new Date();
        const rangeStart = new Date(now - rangeMs);

        const recentAlerts = this.alertData.filter(a => a.time >= rangeStart);
        document.getElementById('modal-velocity-count').textContent = recentAlerts.length;

        // Time breakdown by hour buckets
        const buckets = {};
        const bucketSize = rangeMs > 24 * 60 * 60 * 1000 ? 6 : (rangeMs > 6 * 60 * 60 * 1000 ? 1 : 0.25); // hours per bucket

        recentAlerts.forEach(a => {
          const hoursAgo = Math.floor((now - a.time) / (bucketSize * 60 * 60 * 1000));
          const label = bucketSize >= 1
            ? `${hoursAgo * bucketSize}-${(hoursAgo + 1) * bucketSize}h ago`
            : `${hoursAgo * bucketSize * 60}-${(hoursAgo + 1) * bucketSize * 60}m ago`;
          buckets[label] = (buckets[label] || 0) + 1;
        });

        const breakdown = document.getElementById('velocity-breakdown');
        const entries = Object.entries(buckets).slice(0, 8);

        if (entries.length === 0) {
          breakdown.innerHTML = '<li class="metric-detail-item"><span class="metric-detail-name">No alerts in this period</span></li>';
        } else {
          breakdown.innerHTML = entries.map(([label, count]) => `
            <li class="metric-detail-item">
              <span class="metric-detail-name">${label}</span>
              <span class="metric-detail-value">${count} alert${count !== 1 ? 's' : ''}</span>
            </li>
          `).join('');
        }

        this.open('velocity');
      },

      openRecurring() {
        // Group by hostname
        const hostServices = {};
        this.alertData.forEach(alert => {
          if (!hostServices[alert.hostname]) {
            hostServices[alert.hostname] = { services: new Set(), account: alert.account };
          }
          alert.services.split(',').forEach(s => {
            if (s.trim()) hostServices[alert.hostname].services.add(s.trim());
          });
        });

        const recurring = Object.entries(hostServices)
          .filter(([_, data]) => data.services.size >= 2)
          .map(([hostname, data]) => ({
            hostname,
            account: data.account,
            serviceCount: data.services.size,
            services: Array.from(data.services)
          }))
          .sort((a, b) => b.serviceCount - a.serviceCount);

        document.getElementById('modal-recurring-count').textContent = recurring.length;

        const details = document.getElementById('recurring-systems-details');
        if (recurring.length === 0) {
          details.innerHTML = '<li class="metric-detail-item"><span class="metric-detail-name">No recurring systems detected</span></li>';
        } else {
          details.innerHTML = recurring.slice(0, 10).map(item => `
            <li class="metric-detail-item" style="cursor: pointer;" onclick="InsightCards.filterByHostname('${item.hostname}'); MetricModals.close('recurring');">
              <span class="metric-detail-name">${item.hostname}</span>
              <span class="metric-detail-value">${item.serviceCount} services</span>
            </li>
          `).join('');
        }

        this.open('recurring');
      },

      openHealthScore() {
        const breakdown = this.calculateHealthBreakdown();

        document.getElementById('modal-health-score').textContent = breakdown.score;

        // Update icon color based on score
        const icon = document.getElementById('health-modal-icon');
        icon.className = 'metric-modal-icon';
        if (breakdown.score >= 80) icon.classList.add('healthy');
        else if (breakdown.score >= 50) icon.classList.add('warning');
        else icon.classList.add('critical');

        const breakdownEl = document.getElementById('health-breakdown');
        breakdownEl.innerHTML = breakdown.items.map(item => `
          <div class="health-item">
            <span class="health-item-label">${item.label}</span>
            <span class="health-item-detail">${item.detail}</span>
            <span class="health-item-impact ${item.impact === 0 ? 'none' : ''}">${item.impact === 0 ? '+0' : '-' + item.impact}</span>
          </div>
        `).join('');

        const finalEl = document.getElementById('health-final-value');
        finalEl.textContent = breakdown.score;
        finalEl.className = 'health-final-score';
        if (breakdown.score >= 80) finalEl.classList.add('healthy');
        else if (breakdown.score >= 50) finalEl.classList.add('warning');
        else finalEl.classList.add('critical');

        this.open('health-score');
      },

      calculateHealthBreakdown() {
        let score = 100;
        const items = [];

        // Alert count deduction
        const alertCount = this.alertData.length;
        const alertDeduction = Math.min(alertCount * 2, 30);
        score -= alertDeduction;
        items.push({
          label: 'Alert Count',
          detail: `${alertCount} alerts`,
          impact: alertDeduction
        });

        // Long-running alerts
        const longRunning = this.alertData.filter(a => a.duration >= 60 * 60 * 1000).length;
        const longDeduction = Math.min(longRunning * 5, 20);
        score -= longDeduction;
        items.push({
          label: 'Long-running (>1h)',
          detail: `${longRunning} alerts`,
          impact: longDeduction
        });

        // Recurring systems
        const hostServices = {};
        this.alertData.forEach(a => {
          if (!hostServices[a.hostname]) hostServices[a.hostname] = new Set();
          a.services.split(',').forEach(s => { if (s.trim()) hostServices[a.hostname].add(s.trim()); });
        });
        const recurringCount = Object.values(hostServices).filter(s => s.size >= 2).length;
        const recurringDeduction = Math.min(recurringCount * 5, 20);
        score -= recurringDeduction;
        items.push({
          label: 'Recurring Systems',
          detail: `${recurringCount} systems`,
          impact: recurringDeduction
        });

        // Recent velocity
        const now = new Date();
        const oneHourAgo = new Date(now - 60 * 60 * 1000);
        const recentCount = this.alertData.filter(a => a.time >= oneHourAgo).length;
        const velocityDeduction = Math.min(recentCount * 3, 15);
        score -= velocityDeduction;
        items.push({
          label: 'Recent Alerts (1h)',
          detail: `${recentCount} alerts`,
          impact: velocityDeduction
        });

        // Incidents
        const incidentCount = parseInt(document.getElementById('incidents-count')?.textContent || '0');
        const incidentDeduction = Math.min(incidentCount * 3, 15);
        score -= incidentDeduction;
        items.push({
          label: 'Active Incidents',
          detail: `${incidentCount} incidents`,
          impact: incidentDeduction
        });

        return { score: Math.max(0, score), items };
      },

      filterOldestAlert() {
        if (this.oldestAlert) {
          InsightCards.filterByHostname(this.oldestAlert.hostname);
          this.close('oldest-alert');
        }
      },

      silenceOldestAlert() {
        if (this.oldestAlert) {
          // Find the row and trigger silence
          const rows = document.querySelectorAll('#active-table tbody tr');
          for (const row of rows) {
            const hn = row.querySelector('.hostname')?.textContent.trim();
            if (hn === this.oldestAlert.hostname) {
              const btn = row.querySelector('.silence-btn');
              if (btn) btn.click();
              this.close('oldest-alert');
              return;
            }
          }
        }
      },

      filterByDuration(range) {
        // Clear existing filters first
        const searchBox = document.getElementById('search-box');

        // Apply duration-based filtering via the time filter
        const timeFilter = document.getElementById('filter-time');
        if (timeFilter) {
          if (range === '1h') {
            // For < 1h, we just show recent
            timeFilter.value = '1h';
          } else if (range === '1h+') {
            // Long-running: > 1 hour - no direct filter, use search
            showToast('Showing long-running alerts (>1h)', 'info');
          }
          applyFilters();
        }
        this.close('avg-duration');
        showToast(`Filtering by duration: ${range}`, 'success');
      },

      filterByTimeRange(range) {
        const timeFilter = document.getElementById('filter-time');
        if (timeFilter) {
          timeFilter.value = range;
          applyFilters();
        }
        this.close('velocity');
        showToast(`Filtering by time range: ${range}`, 'success');
      }
    };

    // ========================================
    // VIEW PRESETS
    // ========================================

    const ViewPresets = {
      current: 'detailed',

      presets: {
        detailed: {
          name: 'Detailed',
          columns: ['checkbox', 'uid', 'account', 'hostname', 'datacenter', 'section', 'row', 'rack', 'location', 'prom', 'time', 'duration', 'services', 'actions']
        },
        compact: {
          name: 'Compact',
          columns: ['checkbox', 'hostname', 'services', 'duration', 'actions']
        },
        location: {
          name: 'Location Focus',
          columns: ['checkbox', 'hostname', 'datacenter', 'section', 'row', 'rack', 'duration', 'actions']
        },
        account: {
          name: 'Account Focus',
          columns: ['checkbox', 'account', 'hostname', 'services', 'duration', 'actions']
        },
        triage: {
          name: 'Triage',
          columns: ['checkbox', 'hostname', 'services', 'duration', 'prom', 'actions']
        }
      },

      columnIndexMap: {
        'checkbox': 0,
        'uid': 1,
        'account': 2,
        'hostname': 3,
        'datacenter': 4,
        'section': 5,
        'row': 6,
        'rack': 7,
        'location': 8,
        'prom': 9,
        'time': 10,
        'duration': 11,
        'services': 12,
        'actions': 13
      },

      init() {
        // Load saved preset
        const saved = localStorage.getItem('prometheos-view-preset');
        if (saved && this.presets[saved]) {
          this.current = saved;
          this.apply(saved, false);
        }
      },

      toggle() {
        // Now handled by the combined presets dropdown
        const dropdown = document.getElementById('presets-dropdown');
        dropdown?.classList.toggle('show');
      },

      apply(presetId, showToastMsg = true) {
        if (!this.presets[presetId]) return;

        this.current = presetId;
        localStorage.setItem('prometheos-view-preset', presetId);

        const preset = this.presets[presetId];
        const visibleColumns = new Set(preset.columns);

        // Update both active and silenced tables
        ['active-table', 'silenced-table'].forEach(tableId => {
          const table = document.getElementById(tableId);
          if (!table) return;

          // Update header visibility
          const headers = table.querySelectorAll('thead th');
          headers.forEach((th, i) => {
            const colName = Object.keys(this.columnIndexMap).find(k => this.columnIndexMap[k] === i);
            if (colName) {
              th.style.display = visibleColumns.has(colName) ? '' : 'none';
            }
          });

          // Update row cell visibility
          const rows = table.querySelectorAll('tbody tr');
          rows.forEach(row => {
            const cells = row.querySelectorAll('td');
            cells.forEach((td, i) => {
              const colName = Object.keys(this.columnIndexMap).find(k => this.columnIndexMap[k] === i);
              if (colName) {
                td.style.display = visibleColumns.has(colName) ? '' : 'none';
              }
            });
          });
        });

        // Update UI - current view indicator in Presets button
        const viewIndicator = document.getElementById('current-view-indicator');
        if (viewIndicator) viewIndicator.textContent = preset.name;

        // Update active state in dropdown (new combined structure)
        document.querySelectorAll('.view-preset-item').forEach(opt => {
          opt.classList.toggle('active', opt.dataset.preset === presetId);
        });

        // Close combined presets dropdown
        document.getElementById('presets-dropdown')?.classList.remove('show');

        // Apply grouping for Location Focus and Account Focus views
        if (presetId === 'location') {
          GroupingManager.applyLocationGrouping();
        } else if (presetId === 'account') {
          GroupingManager.applyAccountGrouping();
        } else {
          GroupingManager.clearGrouping();
        }

        // Update clear all button state based on new view
        FilterManager.updateClearAllButton();

        // Always reapply default sort (newest/shortest duration first) unless preset has saved sort
        // Check if there's a saved sort preference for this preset
        const savedSort = localStorage.getItem(`prometheos-preset-sort-${presetId}`);
        if (savedSort) {
          try {
            const sortConfig = JSON.parse(savedSort);
            applySavedSort(sortConfig.columnIndex, sortConfig.direction);
          } catch (e) {
            applyDefaultSort();
          }
        } else {
          applyDefaultSort();
        }

        if (showToastMsg) {
          showToast(`View: ${preset.name}`, 'success');
        }
      },

      // Save current sort preference for the active preset
      saveCurrentSort(columnIndex, direction) {
        const sortConfig = { columnIndex, direction };
        localStorage.setItem(`prometheos-preset-sort-${this.current}`, JSON.stringify(sortConfig));
      }
    };

    // ========================================
    // GROUPING MANAGER (Location/Account Focus)
    // ========================================

    const GroupingManager = {
      currentGrouping: null, // 'location', 'account', or null

      // Parse location code: B3S2R9K8U27 -> { datacenter, section, row, rack }
      parseLocation(location) {
        if (!location) return null;
        const match = location.match(/^B(\d+)S(\d+)R(\d+)K(\d+)(?:U(\d+))?$/i);
        if (!match) return null;
        return {
          datacenter: `B${match[1]}`,
          section: `S${match[2]}`,
          row: `R${match[3]}`,
          rack: `K${match[4]}`,
          fullDC: `B${match[1]}`,
          fullSection: `B${match[1]}S${match[2]}`
        };
      },

      clearGrouping() {
        if (!this.currentGrouping) return;

        ['active-table', 'silenced-table'].forEach(tableId => {
          const table = document.getElementById(tableId);
          if (!table) return;

          const tbody = table.querySelector('tbody');

          // Remove all group/subgroup/row header rows
          tbody.querySelectorAll('.group-header-row, .subgroup-header-row, .row-header-row').forEach(row => row.remove());

          // Remove grouping classes and data attributes from alert rows
          tbody.querySelectorAll('.grouped-row').forEach(row => {
            row.classList.remove('grouped-row', 'indent-1', 'indent-2', 'indent-3');
            delete row.dataset.parentGroup;
            delete row.dataset.parentSubgroup;
            delete row.dataset.parentRowgroup;
          });

          // Show all rows
          tbody.querySelectorAll('tr').forEach(row => {
            row.style.display = '';
          });
        });

        this.currentGrouping = null;
      },

      applyLocationGrouping() {
        this.clearGrouping();
        this.currentGrouping = 'location';

        ['active-table', 'silenced-table'].forEach(tableId => {
          const table = document.getElementById(tableId);
          if (!table) return;

          const tbody = table.querySelector('tbody');
          const rows = Array.from(tbody.querySelectorAll('tr.alert-row:not(.filtered-out)'));

          if (rows.length === 0) return;

          // Group by datacenter > section > row
          const groups = new Map();

          rows.forEach(row => {
            const location = row.dataset.location || '';
            const parsed = this.parseLocation(location);
            const dc = parsed?.fullDC || 'Unknown';
            const section = parsed?.fullSection || 'Unknown';
            const rowKey = parsed ? `${parsed.fullSection}${parsed.row}` : 'Unknown';

            if (!groups.has(dc)) {
              groups.set(dc, new Map());
            }
            if (!groups.get(dc).has(section)) {
              groups.get(dc).set(section, new Map());
            }
            if (!groups.get(dc).get(section).has(rowKey)) {
              groups.get(dc).get(section).set(rowKey, []);
            }
            groups.get(dc).get(section).get(rowKey).push(row);
          });

          // Sort groups by datacenter and section
          const sortedGroups = new Map([...groups.entries()].sort());

          // Rebuild tbody with grouped structure
          const fragment = document.createDocumentFragment();
          const colCount = table.querySelectorAll('thead th').length;

          sortedGroups.forEach((sections, dc) => {
            // Calculate datacenter stats
            let dcTotalAlerts = 0;
            let dcNewAlerts = 0;
            sections.forEach(sectionRows => {
              sectionRows.forEach(rowAlerts => {
                dcTotalAlerts += rowAlerts.length;
                rowAlerts.forEach(row => {
                  const duration = row.querySelector('.duration-badge')?.textContent.trim().toLowerCase();
                  if (duration === 'new') dcNewAlerts++;
                });
              });
            });

            // Create datacenter header (collapsed by default)
            const dcHeader = document.createElement('tr');
            dcHeader.className = 'group-header-row collapsed';
            dcHeader.dataset.group = dc;
            dcHeader.dataset.level = 'datacenter';
            dcHeader.onclick = (e) => { e.stopPropagation(); this.toggleGroup(dcHeader); };

            dcHeader.innerHTML = `
              <td colspan="${colCount}">
                <div class="group-header-content">
                  <svg class="group-expand-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="6 9 12 15 18 9"></polyline>
                  </svg>
                  <div class="group-label">
                    <svg class="group-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                      <circle cx="12" cy="10" r="3"></circle>
                    </svg>
                    <span class="group-name">Datacenter ${dc}</span>
                  </div>
                  <span class="group-count">${dcTotalAlerts} alert${dcTotalAlerts !== 1 ? 's' : ''}</span>
                  <div class="group-summary">
                    ${dcNewAlerts > 0 ? `<span class="group-summary-item new">🆕 ${dcNewAlerts} new</span>` : ''}
                    <span class="group-summary-item">${sections.size} section${sections.size !== 1 ? 's' : ''}</span>
                  </div>
                </div>
              </td>
            `;
            fragment.appendChild(dcHeader);

            // Sort sections
            const sortedSections = new Map([...sections.entries()].sort());

            sortedSections.forEach((sectionRowsMap, section) => {
              // Calculate section stats
              let sectionTotalAlerts = 0;
              let sectionNewAlerts = 0;
              sectionRowsMap.forEach(rowAlerts => {
                sectionTotalAlerts += rowAlerts.length;
                rowAlerts.forEach(row => {
                  const duration = row.querySelector('.duration-badge')?.textContent.trim().toLowerCase();
                  if (duration === 'new') sectionNewAlerts++;
                });
              });

              // Create section subheader (collapsed by default, hidden initially)
              const sectionHeader = document.createElement('tr');
              sectionHeader.className = 'subgroup-header-row grouped-row indent-1 collapsed';
              sectionHeader.dataset.subgroup = section;
              sectionHeader.dataset.parentGroup = dc;
              sectionHeader.dataset.level = 'section';
              sectionHeader.style.display = 'none'; // Hidden because parent is collapsed
              sectionHeader.onclick = (e) => { e.stopPropagation(); this.toggleSubgroup(sectionHeader); };

              const sectionDisplay = section.replace(dc, ''); // Show just "S2" instead of "B3S2"
              sectionHeader.innerHTML = `
                <td colspan="${colCount}">
                  <div class="subgroup-header-content">
                    <svg class="subgroup-expand-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <polyline points="6 9 12 15 18 9"></polyline>
                    </svg>
                    <span class="subgroup-name">Section ${sectionDisplay}</span>
                    <span class="subgroup-count">${sectionTotalAlerts}</span>
                    ${sectionNewAlerts > 0 ? `<span class="group-summary-item new" style="margin-left: auto;">🆕 ${sectionNewAlerts}</span>` : ''}
                    <span class="group-summary-item" style="margin-left: ${sectionNewAlerts > 0 ? '8px' : 'auto'};">${sectionRowsMap.size} row${sectionRowsMap.size !== 1 ? 's' : ''}</span>
                  </div>
                </td>
              `;
              fragment.appendChild(sectionHeader);

              // Sort rows within section
              const sortedRowsMap = new Map([...sectionRowsMap.entries()].sort());

              sortedRowsMap.forEach((rowAlerts, rowKey) => {
                // Get row display name (e.g., "R9" from "B3S2R9")
                const rowMatch = rowKey.match(/R(\d+)$/i);
                const rowDisplay = rowMatch ? `R${rowMatch[1]}` : rowKey.replace(section, '');

                // Calculate rack info
                const racks = new Set();
                rowAlerts.forEach(row => {
                  const loc = row.dataset.location || '';
                  const parsed = this.parseLocation(loc);
                  if (parsed?.rack) racks.add(parsed.rack);
                });

                // Create row header (collapsed by default, hidden initially)
                const rowHeader = document.createElement('tr');
                rowHeader.className = 'row-header-row grouped-row indent-2 collapsed';
                rowHeader.dataset.rowgroup = rowKey;
                rowHeader.dataset.parentGroup = dc;
                rowHeader.dataset.parentSubgroup = section;
                rowHeader.dataset.level = 'row';
                rowHeader.style.display = 'none'; // Hidden because parent is collapsed
                rowHeader.onclick = (e) => { e.stopPropagation(); this.toggleRowGroup(rowHeader); };

                rowHeader.innerHTML = `
                  <td colspan="${colCount}">
                    <div class="row-header-content">
                      <svg class="row-expand-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="6 9 12 15 18 9"></polyline>
                      </svg>
                      <span class="row-header-name">Row ${rowDisplay}</span>
                      <span class="row-header-count">${rowAlerts.length} alert${rowAlerts.length !== 1 ? 's' : ''}</span>
                      <span class="row-header-count" style="margin-left: 4px;">${racks.size} rack${racks.size !== 1 ? 's' : ''}</span>
                    </div>
                  </td>
                `;
                fragment.appendChild(rowHeader);

                // Add alert rows (hidden initially)
                rowAlerts.forEach(row => {
                  row.classList.add('grouped-row', 'indent-3');
                  row.dataset.parentGroup = dc;
                  row.dataset.parentSubgroup = section;
                  row.dataset.parentRowgroup = rowKey;
                  row.style.display = 'none'; // Hidden because parent is collapsed
                  fragment.appendChild(row);
                });
              });
            });
          });

          // Clear and append grouped content
          tbody.innerHTML = '';
          tbody.appendChild(fragment);
        });
      },

      applyAccountGrouping() {
        this.clearGrouping();
        this.currentGrouping = 'account';

        ['active-table', 'silenced-table'].forEach(tableId => {
          const table = document.getElementById(tableId);
          if (!table) return;

          const tbody = table.querySelector('tbody');
          const rows = Array.from(tbody.querySelectorAll('tr.alert-row:not(.filtered-out)'));

          if (rows.length === 0) return;

          // Group by account
          const groups = new Map();

          rows.forEach(row => {
            const account = row.querySelector('.cell-primary')?.textContent.trim() || 'Unknown';

            if (!groups.has(account)) {
              groups.set(account, []);
            }
            groups.get(account).push(row);
          });

          // Sort groups by alert count (descending) then alphabetically
          const sortedGroups = new Map([...groups.entries()].sort((a, b) => {
            if (b[1].length !== a[1].length) return b[1].length - a[1].length;
            return a[0].localeCompare(b[0]);
          }));

          // Rebuild tbody with grouped structure
          const fragment = document.createDocumentFragment();
          const colCount = table.querySelectorAll('thead th').length;

          sortedGroups.forEach((accountRows, account) => {
            // Calculate stats
            let newAlerts = 0;
            const services = new Set();

            accountRows.forEach(row => {
              const duration = row.querySelector('.duration-badge')?.textContent.trim().toLowerCase();
              if (duration === 'new') newAlerts++;

              const rowServices = row.dataset.services?.split(',') || [];
              rowServices.forEach(s => { if (s.trim()) services.add(s.trim()); });
            });

            // Create account header (collapsed by default)
            const accountHeader = document.createElement('tr');
            accountHeader.className = 'group-header-row collapsed';
            accountHeader.dataset.group = account;
            accountHeader.dataset.level = 'account';
            accountHeader.onclick = (e) => { e.stopPropagation(); this.toggleGroup(accountHeader); };

            accountHeader.innerHTML = `
              <td colspan="${colCount}">
                <div class="group-header-content">
                  <svg class="group-expand-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="6 9 12 15 18 9"></polyline>
                  </svg>
                  <div class="group-label">
                    <svg class="group-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                      <circle cx="9" cy="7" r="4"></circle>
                    </svg>
                    <span class="group-name">${this.escapeHtml(account)}</span>
                  </div>
                  <span class="group-count">${accountRows.length} alert${accountRows.length !== 1 ? 's' : ''}</span>
                  <div class="group-summary">
                    ${newAlerts > 0 ? `<span class="group-summary-item new">🆕 ${newAlerts} new</span>` : ''}
                    <span class="group-summary-item">${services.size} service${services.size !== 1 ? 's' : ''}</span>
                  </div>
                </div>
              </td>
            `;
            fragment.appendChild(accountHeader);

            // Add rows for this account (hidden by default since parent is collapsed)
            accountRows.forEach(row => {
              row.classList.add('grouped-row', 'indent-1');
              row.dataset.parentGroup = account;
              row.style.display = 'none'; // Hidden because parent is collapsed
              fragment.appendChild(row);
            });
          });

          // Clear and append grouped content
          tbody.innerHTML = '';
          tbody.appendChild(fragment);
        });
      },

      // Toggle datacenter/account group (top level)
      toggleGroup(headerRow) {
        const isCollapsed = headerRow.classList.toggle('collapsed');
        const groupId = headerRow.dataset.group;
        const tbody = headerRow.closest('tbody');

        // Find all direct children of this group (sections or alert rows)
        tbody.querySelectorAll(`tr[data-parent-group="${groupId}"]`).forEach(row => {
          if (isCollapsed) {
            // Collapse: hide all children
            row.style.display = 'none';
          } else {
            // Expand: show only direct children (subgroups/sections)
            // For location grouping, show section headers only (they remain collapsed)
            // For account grouping, show alert rows directly
            if (row.classList.contains('subgroup-header-row') || row.classList.contains('alert-row')) {
              row.style.display = '';
            }
          }
        });

        // Also hide deeper nested items when collapsing datacenter
        if (isCollapsed) {
          tbody.querySelectorAll(`tr.row-header-row[data-parent-group="${groupId}"]`).forEach(row => {
            row.style.display = 'none';
          });
          tbody.querySelectorAll(`tr.alert-row[data-parent-group="${groupId}"]`).forEach(row => {
            row.style.display = 'none';
          });
        }
      },

      // Toggle section subgroup (second level in location grouping)
      toggleSubgroup(headerRow) {
        const isCollapsed = headerRow.classList.toggle('collapsed');
        const subgroupId = headerRow.dataset.subgroup;
        const tbody = headerRow.closest('tbody');

        // Find all direct children of this subgroup (row headers)
        tbody.querySelectorAll(`tr[data-parent-subgroup="${subgroupId}"]`).forEach(row => {
          if (isCollapsed) {
            // Collapse: hide all children
            row.style.display = 'none';
          } else {
            // Expand: show row headers only (they remain collapsed)
            if (row.classList.contains('row-header-row')) {
              row.style.display = '';
            }
          }
        });

        // Also hide alert rows when collapsing section
        if (isCollapsed) {
          tbody.querySelectorAll(`tr.alert-row[data-parent-subgroup="${subgroupId}"]`).forEach(row => {
            row.style.display = 'none';
          });
        }
      },

      // Toggle row group (third level in location grouping - shows individual alerts)
      toggleRowGroup(headerRow) {
        const isCollapsed = headerRow.classList.toggle('collapsed');
        const rowgroupId = headerRow.dataset.rowgroup;
        const tbody = headerRow.closest('tbody');

        // Find all alert rows belonging to this row group
        tbody.querySelectorAll(`tr.alert-row[data-parent-rowgroup="${rowgroupId}"]`).forEach(row => {
          row.style.display = isCollapsed ? 'none' : '';
        });
      },

      escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
    };

    // ========================================
    // STALE ALERTS MANAGER
    // ========================================

    const StaleAlertsManager = {
      enabled: true,
      thresholdDays: 7,
      collapsed: true,

      init() {
        // Load settings from localStorage
        const savedEnabled = localStorage.getItem('prometheos-stale-alerts-enabled');
        const savedThreshold = localStorage.getItem('prometheos-stale-alerts-threshold');
        const savedCollapsed = localStorage.getItem('prometheos-stale-alerts-collapsed');

        if (savedEnabled !== null) {
          this.enabled = savedEnabled === 'true';
        }
        if (savedThreshold !== null) {
          this.thresholdDays = parseInt(savedThreshold) || 7;
        }
        if (savedCollapsed !== null) {
          this.collapsed = savedCollapsed === 'true';
        }

        // Initialize toggle UI
        this.updateToggleUI();

        // Apply stale alerts grouping on initial load
        if (this.enabled) {
          this.apply();
        }
      },

      updateToggleUI() {
        const toggle = document.getElementById('stale-toggle-switch');
        const select = document.getElementById('stale-threshold-select');

        if (toggle) {
          toggle.classList.toggle('active', this.enabled);
        }
        if (select) {
          select.value = this.thresholdDays.toString();
        }
      },

      toggle() {
        this.enabled = !this.enabled;
        localStorage.setItem('prometheos-stale-alerts-enabled', this.enabled);
        this.updateToggleUI();

        if (this.enabled) {
          this.apply();
        } else {
          this.clear();
        }

        showToast(this.enabled ? 'Stale alerts collapsed' : 'Showing all alerts', 'success');
      },

      setThreshold(days) {
        this.thresholdDays = parseInt(days) || 7;
        localStorage.setItem('prometheos-stale-alerts-threshold', this.thresholdDays);

        if (this.enabled) {
          this.clear();
          this.apply();
        }
      },

      getThresholdMs() {
        return this.thresholdDays * 24 * 60 * 60 * 1000;
      },

      apply() {
        if (!this.enabled) return;

        const now = new Date();
        const thresholdMs = this.getThresholdMs();

        ['active-table', 'silenced-table'].forEach(tableId => {
          const table = document.getElementById(tableId);
          if (!table) return;

          const tbody = table.querySelector('tbody');
          const rows = Array.from(tbody.querySelectorAll('tr.alert-row:not(.filtered-out)'));

          if (rows.length === 0) return;

          // Separate stale and fresh alerts
          const staleAlerts = [];
          const freshAlerts = [];

          rows.forEach(row => {
            const timeStr = row.dataset.time;
            if (timeStr) {
              const alertTime = new Date(timeStr.replace(' ', 'T'));
              const age = now - alertTime;

              if (age >= thresholdMs) {
                staleAlerts.push(row);
              } else {
                freshAlerts.push(row);
              }
            } else {
              freshAlerts.push(row);
            }
          });

          // Only create stale section if there are stale alerts
          if (staleAlerts.length === 0) return;

          // Remove any existing stale header
          tbody.querySelectorAll('.stale-alerts-header').forEach(h => h.remove());

          // Create stale alerts header
          const colCount = table.querySelectorAll('thead th').length;
          const staleHeader = document.createElement('tr');
          staleHeader.className = `stale-alerts-header ${this.collapsed ? 'collapsed' : ''}`;
          staleHeader.dataset.tableId = tableId;
          staleHeader.onclick = () => this.toggleStaleSection(staleHeader, tableId);

          // Calculate age summary
          const oldestStale = staleAlerts.reduce((max, row) => {
            const time = new Date(row.dataset.time.replace(' ', 'T'));
            return time < max ? time : max;
          }, new Date());
          const oldestDays = Math.floor((now - oldestStale) / (24 * 60 * 60 * 1000));

          staleHeader.innerHTML = `
            <td colspan="${colCount}">
              <div class="stale-header-content">
                <div class="stale-expand-icon">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                    <polyline points="6 9 12 15 18 9"></polyline>
                  </svg>
                </div>
                <div class="stale-header-icon">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <polyline points="12 6 12 12 16 14"></polyline>
                  </svg>
                </div>
                <div class="stale-header-text">
                  <span class="stale-header-title">Stale Alerts</span>
                  <span class="stale-header-subtitle">Older than ${this.thresholdDays} days • May require review or closure</span>
                </div>
                <span class="stale-header-count">${staleAlerts.length} alert${staleAlerts.length !== 1 ? 's' : ''} (oldest: ${oldestDays}d)</span>
              </div>
            </td>
          `;

          // Rebuild tbody: fresh alerts first, then stale header, then stale alerts
          const fragment = document.createDocumentFragment();

          // Add fresh alerts first (maintaining their current order)
          freshAlerts.forEach(row => {
            row.classList.remove('stale-alert-row');
            fragment.appendChild(row);
          });

          // Add stale header
          fragment.appendChild(staleHeader);

          // Add stale alerts (hidden if collapsed)
          staleAlerts.forEach(row => {
            row.classList.add('stale-alert-row');
            row.style.display = this.collapsed ? 'none' : '';
            fragment.appendChild(row);
          });

          tbody.innerHTML = '';
          tbody.appendChild(fragment);
        });
      },

      toggleStaleSection(header, tableId) {
        this.collapsed = header.classList.toggle('collapsed');
        localStorage.setItem('prometheos-stale-alerts-collapsed', this.collapsed);

        const table = document.getElementById(tableId);
        if (!table) return;

        const tbody = table.querySelector('tbody');
        tbody.querySelectorAll('.stale-alert-row').forEach(row => {
          row.style.display = this.collapsed ? 'none' : '';
        });
      },

      clear() {
        ['active-table', 'silenced-table'].forEach(tableId => {
          const table = document.getElementById(tableId);
          if (!table) return;

          const tbody = table.querySelector('tbody');

          // Remove stale headers
          tbody.querySelectorAll('.stale-alerts-header').forEach(h => h.remove());

          // Remove stale styling from rows
          tbody.querySelectorAll('.stale-alert-row').forEach(row => {
            row.classList.remove('stale-alert-row');
            row.style.display = '';
          });
        });
      },

      // Called after filters change to reapply stale grouping
      refresh() {
        if (this.enabled) {
          this.clear();
          this.apply();
        }
      }
    };

    // ========================================
    // EXPORT FUNCTIONALITY
    // ========================================

    const ExportManager = {
      init() {
        const exportBtn = document.getElementById('export-btn');
        const exportMenu = document.getElementById('export-menu');

        exportBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          exportMenu.classList.toggle('show');
        });

        document.addEventListener('click', () => {
          exportMenu.classList.remove('show');
        });
      }
    };

    function exportData(format) {
      const activePanel = document.querySelector('.tab-panel[style*="block"]') || document.getElementById('active');
      const table = activePanel.querySelector('.data-table');

      if (!table) return;

      const rows = table.querySelectorAll('tbody tr:not(.filtered-out)');
      const data = [];

      rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        data.push({
          uid: cells[1]?.textContent.trim() || '',
          account: cells[2]?.textContent.trim() || '',
          hostname: cells[3]?.textContent.trim() || '',
          datacenter: cells[4]?.textContent.trim() || '',
          section: cells[5]?.textContent.trim() || '',
          row: cells[6]?.textContent.trim() || '',
          rack: cells[7]?.textContent.trim() || '',
          location: cells[8]?.textContent.trim() || '',
          promNode: cells[9]?.textContent.trim() || '',
          startTime: cells[10]?.textContent.trim() || '',
          duration: cells[11]?.textContent.trim() || '',
          services: Array.from(cells[12]?.querySelectorAll('.service-tag') || []).map(t => t.textContent.trim())
        });
      });

      if (format === 'json') {
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        downloadBlob(blob, `prometheos-alerts-${new Date().toISOString().slice(0, 10)}.json`);
        showToast('Exported as JSON', 'success');
      } else if (format === 'csv') {
        let csv = 'UID,Account,Hostname,DC,Section,Row,Rack,Location,Prom Node,Start Time,Duration,Services\n';
        data.forEach(row => {
          csv += `"${row.uid}","${row.account}","${row.hostname}","${row.datacenter}","${row.section}","${row.row}","${row.rack}","${row.location}","${row.promNode}","${row.startTime}","${row.duration}","${row.services.join('; ')}"\n`;
        });
        const blob = new Blob([csv], { type: 'text/csv' });
        downloadBlob(blob, `prometheos-alerts-${new Date().toISOString().slice(0, 10)}.csv`);
        showToast('Exported as CSV', 'success');
      }

      document.getElementById('export-menu').classList.remove('show');
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // ========================================
    // DASHBOARD WIDGETS
    // ========================================

    function updateDashboardWidgets() {
      // Update advanced analytics
      updateAdvancedAnalytics();
    }

    function filterByService(service) {
      document.getElementById('filter-service').value = service;
      FilterManager.apply();

      // Open filters panel if not open
      const panel = document.getElementById('filters-panel');
      if (!panel.classList.contains('show')) {
        panel.classList.add('show');
      }

      showToast(`Filtered by service: ${service}`, 'success');
    }

    function filterByHostname(hostname) {
      const searchBox = document.getElementById('search-box');
      searchBox.value = hostname;
      // Apply immediately for programmatic filter (no debounce needed)
      FilterManager.apply();
      showToast(`Filtered by hostname: ${hostname}`, 'success');
    }

    function filterByAccount(account) {
      const searchBox = document.getElementById('search-box');
      searchBox.value = account;
      // Apply immediately for programmatic filter (no debounce needed)
      FilterManager.apply();
      showToast(`Filtered by account: ${account}`, 'success');
    }

    function filterRecurringSystems() {
      // Find hosts with 2+ services and filter to show them
      const rows = document.querySelectorAll('#active-table tbody tr');
      const hostServiceCounts = {};

      rows.forEach(row => {
        const hostname = row.querySelector('.hostname')?.textContent.trim();
        if (hostname) {
          const services = row.dataset.services ? row.dataset.services.split(',').filter(s => s.trim()) : [];
          hostServiceCounts[hostname] = (hostServiceCounts[hostname] || 0) + services.length;
        }
      });

      // Get recurring hosts (2+ services)
      const recurringHosts = Object.entries(hostServiceCounts)
        .filter(([_, count]) => count >= 2)
        .map(([host]) => host);

      if (recurringHosts.length > 0) {
        const searchBox = document.getElementById('search-box');
        searchBox.value = recurringHosts[0]; // Filter to first recurring host
        // Apply immediately for programmatic filter
        FilterManager.apply();
        showToast(`Showing recurring system: ${recurringHosts[0]} (${recurringHosts.length} total)`, 'success');
      } else {
        showToast('No recurring systems found', 'info');
      }
    }

    function filterOldestAlert() {
      const hostname = document.getElementById('oldest-hostname').textContent;
      if (hostname && hostname !== '--') {
        filterByHostname(hostname);
      } else {
        showToast('No oldest alert to filter', 'info');
      }
    }

    // ========================================
    // ADVANCED ANALYTICS
    // ========================================

    function updateAdvancedAnalytics() {
      const rows = document.querySelectorAll('#active-table tbody tr:not(.filtered-out)');
      const now = new Date();

      // Collect alert data
      const alertData = [];
      rows.forEach(row => {
        const timeStr = row.dataset.time;
        if (timeStr) {
          const alertTime = new Date(timeStr.replace(' ', 'T'));
          const hostname = row.querySelector('.hostname')?.textContent.trim() || '';
          const account = row.querySelector('.cell-primary')?.textContent.trim() || '';
          const services = row.dataset.services || '';

          alertData.push({
            time: alertTime,
            hostname,
            account,
            services,
            duration: now - alertTime
          });
        }
      });

      // Update Quick Stats
      updateQuickStats(alertData, now);

      // Update Oldest Alert (legacy)
      updateOldestAlert(alertData);

      // Update Insight Cards and Metric Modals
      InsightCards.update(alertData);
      MetricModals.update(alertData);

      // Update Alert Velocity with Trend
      updateAlertVelocity(alertData, now);

      // Update Operational Insights (new actionable widgets)
      updatePriorityQueue(alertData, now);
      updateResponseMetrics(alertData, now);
      updateServiceImpact(alertData);

      // Update Quick Filters badge counts
      if (typeof QuickFilters !== 'undefined') {
        QuickFilters.updateBadges();
      }
    }

    // Wrapper function to refresh operational insights (called by PriorityQueueManager)
    function refreshOperationalInsights() {
      updateAdvancedAnalytics();
    }

    function formatDuration(ms) {
      const seconds = Math.floor(ms / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);

      if (days > 0) {
        return `${days}d ${hours % 24}h`;
      } else if (hours > 0) {
        return `${hours}h ${minutes % 60}m`;
      } else if (minutes > 0) {
        return `${minutes}m`;
      } else {
        return `${seconds}s`;
      }
    }

    function updateQuickStats(alertData, now) {
      // Average time open
      if (alertData.length > 0) {
        const avgDuration = alertData.reduce((sum, a) => sum + a.duration, 0) / alertData.length;
        document.getElementById('avg-alert-time').textContent = formatDuration(avgDuration);
      } else {
        document.getElementById('avg-alert-time').textContent = '--';
      }

      // Oldest alert time
      if (alertData.length > 0) {
        const oldest = alertData.reduce((max, a) => a.duration > max.duration ? a : max);
        document.getElementById('oldest-alert-time').textContent = formatDuration(oldest.duration);
      } else {
        document.getElementById('oldest-alert-time').textContent = '--';
      }

      // Alert velocity (alerts in selected time range)
      const rangeMs = TimeRangeManager.getRangeMs();
      const rangeStart = new Date(now - rangeMs);
      const recentAlerts = alertData.filter(a => a.time >= rangeStart).length;
      document.getElementById('alert-velocity').textContent = recentAlerts;

      // Recurring systems count (systems with 2+ services alerting)
      const systemServices = {};
      alertData.forEach(a => {
        if (!systemServices[a.hostname]) {
          systemServices[a.hostname] = new Set();
        }
        a.services.split(',').forEach(s => {
          if (s.trim()) systemServices[a.hostname].add(s.trim());
        });
      });
      const recurringCount = Object.values(systemServices).filter(s => s.size >= 2).length;
      document.getElementById('recurring-count').textContent = recurringCount;

      // Health Score
      const healthScore = calculateHealthScore(alertData);
      const healthEl = document.getElementById('health-score');
      if (healthEl) {
        healthEl.textContent = healthScore;
        // Color based on score
        const parentIcon = healthEl.closest('.quick-stat')?.querySelector('.quick-stat-icon');
        if (parentIcon) {
          if (healthScore >= 80) {
            parentIcon.style.background = 'var(--healthy-bg)';
            parentIcon.style.color = 'var(--healthy)';
          } else if (healthScore >= 50) {
            parentIcon.style.background = 'var(--warning-bg)';
            parentIcon.style.color = 'var(--warning)';
          } else {
            parentIcon.style.background = 'var(--critical-bg)';
            parentIcon.style.color = 'var(--critical)';
          }
        }
      }

      // Alert Trend indicator
      const trendEl = document.getElementById('alert-trend');
      if (trendEl) {
        // Compare current period vs previous period
        const halfRange = rangeMs / 2;
        const midPoint = new Date(now - halfRange);
        const currentPeriod = alertData.filter(a => a.time >= midPoint).length;
        const previousPeriod = alertData.filter(a => a.time < midPoint && a.time >= rangeStart).length;

        if (previousPeriod === 0) {
          trendEl.className = 'trend-indicator stable';
          trendEl.textContent = '—';
        } else {
          const changePercent = Math.round(((currentPeriod - previousPeriod) / previousPeriod) * 100);
          if (changePercent > 10) {
            trendEl.className = 'trend-indicator up';
            trendEl.textContent = `↑ ${changePercent}%`;
          } else if (changePercent < -10) {
            trendEl.className = 'trend-indicator down';
            trendEl.textContent = `↓ ${Math.abs(changePercent)}%`;
          } else {
            trendEl.className = 'trend-indicator stable';
            trendEl.textContent = '— stable';
          }
        }
      }

      // Update export counts
      IncidentManager.updateExportCounts();
    }

    function updateOldestAlert(alertData) {
      const card = document.getElementById('oldest-alert-card');

      if (alertData.length === 0) {
        card.classList.remove('show');
        return;
      }

      const oldest = alertData.reduce((max, a) => a.duration > max.duration ? a : max);

      // Only show if older than 1 hour
      if (oldest.duration < 60 * 60 * 1000) {
        card.classList.remove('show');
        return;
      }

      card.classList.add('show');
      document.getElementById('oldest-hostname').textContent = oldest.hostname;
      document.getElementById('oldest-account').textContent = oldest.account;
      document.getElementById('oldest-started').textContent = oldest.time.toLocaleString();
      document.getElementById('oldest-duration').textContent = formatDuration(oldest.duration);
    }

    function updateAlertVelocity(alertData, now) {
      const chartContainer = document.getElementById('velocity-chart');
      const rangeMs = TimeRangeManager.getRangeMs();
      const range = TimeRangeManager.current;

      // Determine bucket count and size based on range
      let bucketCount, bucketMs, labelInterval;
      if (range === '1h') {
        bucketCount = 12; // 5-minute buckets
        bucketMs = 5 * 60 * 1000;
        labelInterval = 3;
      } else if (range === '6h') {
        bucketCount = 12; // 30-minute buckets
        bucketMs = 30 * 60 * 1000;
        labelInterval = 2;
      } else if (range === '7d') {
        bucketCount = 14; // 12-hour buckets
        bucketMs = 12 * 60 * 60 * 1000;
        labelInterval = 2;
      } else {
        // 24h default
        bucketCount = 24; // 1-hour buckets
        bucketMs = 60 * 60 * 1000;
        labelInterval = 4;
      }

      // Generate buckets for current period
      const buckets = [];
      for (let i = bucketCount - 1; i >= 0; i--) {
        const bucketStart = new Date(now - (i + 1) * bucketMs);
        const bucketEnd = new Date(now - i * bucketMs);
        const count = alertData.filter(a => a.time >= bucketStart && a.time < bucketEnd).length;

        let label = '';
        if (i % labelInterval === 0) {
          if (range === '7d') {
            label = bucketEnd.toLocaleDateString('en-US', { weekday: 'short' });
          } else {
            label = `${bucketEnd.getHours()}:00`;
          }
        }

        buckets.push({ label, count, index: bucketCount - 1 - i });
      }

      const maxCount = Math.max(...buckets.map(b => b.count), 1);
      const totalAlerts = buckets.reduce((sum, b) => sum + b.count, 0);
      const avgAlerts = (totalAlerts / bucketCount).toFixed(1);
      const peakAlerts = maxCount;

      // Update legend
      document.getElementById('velocity-peak').textContent = peakAlerts;
      document.getElementById('velocity-avg').textContent = avgAlerts;
      document.getElementById('velocity-total').textContent = totalAlerts;

      // Generate bars
      chartContainer.innerHTML = buckets.map((bucket, i) => {
        const height = (bucket.count / maxCount) * 100;
        return `
          <div class="velocity-bar-wrapper">
            <div class="velocity-bar" style="height: ${Math.max(height, 4)}%" data-count="${bucket.count}"></div>
            <span class="velocity-label">${bucket.label}</span>
          </div>
        `;
      }).join('');

      // Calculate trend using linear regression for more accurate velocity analysis
      const trendIndicator = document.getElementById('velocity-trend-indicator');
      const velocityChange = document.getElementById('velocity-change');
      if (trendIndicator) {
        // Linear regression to determine trend direction and strength
        const n = buckets.length;
        let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;

        buckets.forEach((bucket, i) => {
          sumX += i;
          sumY += bucket.count;
          sumXY += i * bucket.count;
          sumX2 += i * i;
        });

        // Calculate slope (rate of change per bucket)
        const slope = n > 1 ? (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX) : 0;

        // Calculate average for normalization
        const avgCount = sumY / n;

        // Calculate percentage change based on slope relative to average
        // Slope represents change per bucket, multiply by bucket count for total change
        const totalChange = slope * (n - 1);
        const changePercent = avgCount > 0 ? Math.round((totalChange / avgCount) * 100) : 0;

        // Also calculate recent trend (last 1/3 vs first 1/3) for confirmation
        const thirdPoint = Math.floor(n / 3);
        const firstThird = buckets.slice(0, thirdPoint).reduce((sum, b) => sum + b.count, 0);
        const lastThird = buckets.slice(-thirdPoint).reduce((sum, b) => sum + b.count, 0);
        const recentChangePercent = firstThird > 0 ? Math.round(((lastThird - firstThird) / firstThird) * 100) : 0;

        // Determine trend based on both slope and recent change
        // Use 10% threshold for more sensitivity
        const isIncreasing = slope > 0.1 && (changePercent > 10 || recentChangePercent > 15);
        const isDecreasing = slope < -0.1 && (changePercent < -10 || recentChangePercent < -15);

        if (totalAlerts === 0) {
          trendIndicator.className = 'velocity-trend-indicator stable';
          trendIndicator.innerHTML = '— No Data';
          if (velocityChange) velocityChange.textContent = '--';
        } else if (isIncreasing) {
          trendIndicator.className = 'velocity-trend-indicator up';
          trendIndicator.innerHTML = `↑ Increasing`;
          if (velocityChange) velocityChange.textContent = `+${Math.abs(changePercent)}%`;
        } else if (isDecreasing) {
          trendIndicator.className = 'velocity-trend-indicator down';
          trendIndicator.innerHTML = `↓ Decreasing`;
          if (velocityChange) velocityChange.textContent = `-${Math.abs(changePercent)}%`;
        } else {
          trendIndicator.className = 'velocity-trend-indicator stable';
          trendIndicator.innerHTML = '— Stable';
          if (velocityChange) velocityChange.textContent = `${changePercent >= 0 ? '+' : ''}${changePercent}%`;
        }
      }
    }

    // ========================================
    // OPERATIONAL INSIGHTS FUNCTIONS
    // ========================================

    // Priority Queue Manager for handling different ordering modes
    const PriorityQueueManager = {
      mode: 'priority', // Default mode
      modes: {
        priority: { label: 'Priority Score', sort: (a, b) => b.score - a.score },
        fifo: { label: 'FIFO (Oldest First)', sort: (a, b) => a.time - b.time },
        lifo: { label: 'LIFO (Newest First)', sort: (a, b) => b.time - a.time },
        age: { label: 'Age Only', sort: (a, b) => b.ageHours - a.ageHours },
        services: { label: 'Service Count', sort: (a, b) => b.serviceCount - a.serviceCount }
      },

      init() {
        // Load saved mode from localStorage
        const saved = localStorage.getItem('prometheos-queue-mode');
        if (saved && this.modes[saved]) {
          this.mode = saved;
        }
        // Update select element
        const select = document.getElementById('queue-mode-select');
        if (select) {
          select.value = this.mode;
        }
      },

      setMode(mode) {
        if (this.modes[mode]) {
          this.mode = mode;
          localStorage.setItem('prometheos-queue-mode', mode);
          // Refresh the queue display
          refreshOperationalInsights();
          showToast(`Queue mode: ${this.modes[mode].label}`, 'success');
        }
      },

      getMode() {
        return this.mode;
      },

      getSortFunction() {
        return this.modes[this.mode]?.sort || this.modes.priority.sort;
      }
    };

    function updatePriorityQueue(alertData, now) {
      const container = document.getElementById('priority-queue');
      const badge = document.getElementById('priority-count-badge');

      if (!container) return;

      // Calculate priority score for each alert
      // Score = (age_hours * 10) + (service_count * 5) + (is_recurring * 20)
      const scored = alertData.map(alert => {
        const ageHours = alert.duration / (60 * 60 * 1000);
        const serviceCount = alert.services.split(',').filter(s => s.trim()).length;

        // Check if this host has multiple alerts (recurring)
        const hostAlerts = alertData.filter(a => a.hostname === alert.hostname).length;
        const isRecurring = hostAlerts > 1;

        const score = Math.round((ageHours * 10) + (serviceCount * 5) + (isRecurring ? 20 : 0));

        return { ...alert, score, ageHours, serviceCount, isRecurring };
      });

      // Get current queue mode and sort accordingly
      const mode = PriorityQueueManager.getMode();
      const sortFn = PriorityQueueManager.getSortFunction();

      // Sort by selected mode and take top 5
      const prioritized = [...scored]
        .sort(sortFn)
        .slice(0, 5);

      // Count high priority (score > 50) - always based on score regardless of sort mode
      const highPriority = scored.filter(a => a.score > 50).length;
      if (badge) {
        badge.textContent = highPriority;
        badge.style.background = highPriority > 0 ? 'var(--critical-bg)' : 'var(--bg-tertiary)';
        badge.style.color = highPriority > 0 ? 'var(--critical)' : 'var(--text-secondary)';
      }

      if (prioritized.length === 0) {
        container.innerHTML = `
          <div class="widget-empty">
            <div class="widget-empty-icon">
              <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                <polyline points="22 4 12 14.01 9 11.01"></polyline>
              </svg>
            </div>
            <span class="widget-empty-text">No alerts in queue</span>
          </div>
        `;
        return;
      }

      // Determine what secondary info to show based on mode
      const getSecondaryLabel = (alert) => {
        switch (mode) {
          case 'fifo':
          case 'lifo':
            return alert.time.toLocaleString();
          case 'age':
            const ageText = alert.ageHours >= 24 ? `${Math.floor(alert.ageHours / 24)}d` :
                            alert.ageHours >= 1 ? `${Math.floor(alert.ageHours)}h` :
                            `${Math.floor(alert.ageHours * 60)}m`;
            return `${ageText} old`;
          case 'services':
            return `${alert.serviceCount} service${alert.serviceCount !== 1 ? 's' : ''}`;
          default:
            return `score`;
        }
      };

      const getSecondaryValue = (alert) => {
        switch (mode) {
          case 'fifo':
          case 'lifo':
            const ageText = alert.ageHours >= 24 ? `${Math.floor(alert.ageHours / 24)}d` :
                            alert.ageHours >= 1 ? `${Math.floor(alert.ageHours)}h` :
                            `${Math.floor(alert.ageHours * 60)}m`;
            return ageText;
          case 'age':
            return alert.score;
          case 'services':
            return alert.score;
          default:
            return alert.score;
        }
      };

      container.innerHTML = prioritized.map((alert, i) => {
        const priority = alert.score > 80 ? 'high' : alert.score > 40 ? 'medium' : 'low';
        const services = alert.services.split(',').filter(s => s.trim()).slice(0, 2).join(', ');
        const ageText = alert.ageHours >= 24 ? `${Math.floor(alert.ageHours / 24)}d` :
                        alert.ageHours >= 1 ? `${Math.floor(alert.ageHours)}h` :
                        `${Math.floor(alert.ageHours * 60)}m`;

        return `
          <div class="priority-item ${priority}" onclick="filterByHostname('${alert.hostname}')">
            <span class="priority-rank">${i + 1}</span>
            <div class="priority-info">
              <div class="priority-name">${alert.hostname}</div>
              <div class="priority-meta">${services} • ${ageText} old${alert.isRecurring ? ' • Recurring' : ''}</div>
            </div>
            <div class="priority-score">
              <span class="priority-score-value">${getSecondaryValue(alert)}</span>
              <span class="priority-score-label">${getSecondaryLabel(alert)}</span>
            </div>
          </div>
        `;
      }).join('');
    }

    function updateResponseMetrics(alertData, now) {
      // Time thresholds
      const HOUR = 60 * 60 * 1000;
      const FOUR_HOURS = 4 * HOUR;

      // Count by age category
      let criticalCount = 0;  // > 4h
      let agingCount = 0;     // 1-4h
      let freshCount = 0;     // < 1h

      const accounts = new Set();
      const hosts = new Set();
      const services = new Set();

      alertData.forEach(alert => {
        // Age categorization
        if (alert.duration > FOUR_HOURS) {
          criticalCount++;
        } else if (alert.duration > HOUR) {
          agingCount++;
        } else {
          freshCount++;
        }

        // Unique counts
        accounts.add(alert.account);
        hosts.add(alert.hostname);
        alert.services.split(',').forEach(s => {
          if (s.trim()) services.add(s.trim());
        });
      });

      // Update UI
      const criticalEl = document.getElementById('metric-critical-count');
      const agingEl = document.getElementById('metric-aging-count');
      const freshEl = document.getElementById('metric-fresh-count');
      const accountsEl = document.getElementById('metric-affected-accounts');
      const hostsEl = document.getElementById('metric-affected-hosts');
      const servicesEl = document.getElementById('metric-affected-services');

      if (criticalEl) criticalEl.textContent = criticalCount;
      if (agingEl) agingEl.textContent = agingCount;
      if (freshEl) freshEl.textContent = freshCount;
      if (accountsEl) accountsEl.textContent = accounts.size;
      if (hostsEl) hostsEl.textContent = hosts.size;
      if (servicesEl) servicesEl.textContent = services.size;
    }

    function updateServiceImpact(alertData) {
      const container = document.getElementById('service-impact');
      if (!container) return;

      // Count alerts per service
      const serviceCounts = {};
      alertData.forEach(alert => {
        alert.services.split(',').forEach(s => {
          const service = s.trim();
          if (service) {
            serviceCounts[service] = (serviceCounts[service] || 0) + 1;
          }
        });
      });

      // Sort by count descending and take top 8
      const sorted = Object.entries(serviceCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 8);

      if (sorted.length === 0) {
        container.innerHTML = `
          <div class="widget-empty">
            <div class="widget-empty-icon">
              <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                <polyline points="22 4 12 14.01 9 11.01"></polyline>
              </svg>
            </div>
            <span class="widget-empty-text">No service data</span>
          </div>
        `;
        return;
      }

      const maxCount = sorted[0][1];

      container.innerHTML = sorted.map(([service, count]) => {
        const percentage = (count / maxCount) * 100;
        return `
          <div class="service-impact-item" onclick="filterByService('${service}')">
            <span class="service-impact-name">${service}</span>
            <div class="service-impact-bar">
              <div class="service-impact-bar-fill" style="width: ${percentage}%"></div>
            </div>
            <span class="service-impact-count">${count}</span>
          </div>
        `;
      }).join('');
    }

    // ========================================
    // DURATION CALCULATION
    // ========================================

    function updateDurations() {
      const now = new Date();
      document.querySelectorAll('.cell-duration').forEach(cell => {
        const startTimeStr = cell.dataset.startTime;
        const row = cell.closest('tr');
        const badge = cell.querySelector('.duration-badge');

        if (!startTimeStr) {
          // No start time - mark as new
          badge.textContent = 'NEW';
          if (!badge.classList.contains('silenced')) {
            badge.classList.remove('short', 'medium', 'long');
            badge.classList.add('new');
          }
          if (row) row.classList.add('new-alert');
          return;
        }

        const startTime = new Date(startTimeStr.replace(' ', 'T'));
        const diffMs = now - startTime;

        if (isNaN(diffMs) || diffMs < 0) {
          // Invalid time or future time - mark as new
          badge.textContent = 'NEW';
          if (!badge.classList.contains('silenced')) {
            badge.classList.remove('short', 'medium', 'long');
            badge.classList.add('new');
          }
          if (row) row.classList.add('new-alert');
          return;
        }

        const seconds = Math.floor(diffMs / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);

        // Check if this is a very new alert (< 1 minute)
        const isNew = seconds < 60;

        let durationText;
        if (isNew) {
          durationText = 'NEW';
        } else if (days > 0) {
          durationText = `${days}d ${hours % 24}h`;
        } else if (hours > 0) {
          durationText = `${hours}h ${minutes % 60}m`;
        } else if (minutes > 0) {
          durationText = `${minutes}m`;
        } else {
          durationText = `${seconds}s`;
        }

        badge.textContent = durationText;

        // Color-code based on duration (skip if silenced)
        if (!badge.classList.contains('silenced')) {
          badge.classList.remove('short', 'medium', 'long', 'new');
          if (row) row.classList.remove('new-alert');

          if (isNew) {
            badge.classList.add('new');
            if (row) row.classList.add('new-alert');
          } else if (hours >= 24) {
            badge.classList.add('long');
          } else if (hours >= 1) {
            badge.classList.add('medium');
          } else {
            badge.classList.add('short');
          }
        }
      });
    }

    // ========================================
    // COUNT BADGES & EMPTY STATES
    // ========================================

    function updateCounts() {
      const activeTable = document.getElementById('active-table');
      const silencedTable = document.getElementById('silenced-table');

      const activeCount = activeTable ? activeTable.querySelectorAll('tbody tr:not(.filtered-out)').length : 0;
      const silencedCount = silencedTable ? silencedTable.querySelectorAll('tbody tr:not(.filtered-out)').length : 0;

      const activeBadge = document.getElementById('active-badge');
      const silencedBadge = document.getElementById('silenced-badge');
      const silencedCardCount = document.getElementById('silenced-count');

      if (activeBadge) activeBadge.textContent = activeCount;
      if (silencedBadge) silencedBadge.textContent = silencedCount;
      if (silencedCardCount) silencedCardCount.textContent = silencedCount;

      const activeEmpty = document.getElementById('active-empty');
      const silencedEmpty = document.getElementById('silenced-empty');
      const activeTableContainer = activeTable ? activeTable.closest('.table-container') : null;
      const silencedTableContainer = silencedTable ? silencedTable.closest('.table-container') : null;

      if (activeCount === 0) {
        if (activeTableContainer) activeTableContainer.style.display = 'none';
        if (activeEmpty) activeEmpty.style.display = 'block';
      } else {
        if (activeTableContainer) activeTableContainer.style.display = 'block';
        if (activeEmpty) activeEmpty.style.display = 'none';
      }

      if (silencedCount === 0) {
        if (silencedTableContainer) silencedTableContainer.style.display = 'none';
        if (silencedEmpty) silencedEmpty.style.display = 'block';
      } else {
        if (silencedTableContainer) silencedTableContainer.style.display = 'block';
        if (silencedEmpty) silencedEmpty.style.display = 'none';
      }

      // Update widgets
      updateDashboardWidgets();
    }

    // ========================================
    // TOAST NOTIFICATIONS
    // ========================================

    function showToast(message, type = 'success') {
      const container = document.getElementById('toast-container');
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          ${type === 'success' ?
            '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline>' :
            '<circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>'
          }
        </svg>
        <span>${message}</span>
      `;

      container.appendChild(toast);

      setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transform = 'translateX(20px)';
        setTimeout(() => toast.remove(), 200);
      }, 3000);
    }

    // ========================================
    // KEYBOARD NAVIGATION
    // ========================================

    document.addEventListener('keydown', function(e) {
      // Don't trigger shortcuts when typing in inputs
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
        if (e.key === 'Escape') {
          e.target.blur();
        }
        return;
      }

      // Alt+1 = Active tab, Alt+2 = Silenced tab
      if (e.altKey && e.key === '1') {
        e.preventDefault();
        document.querySelector('.tab-btn').click();
      }
      if (e.altKey && e.key === '2') {
        e.preventDefault();
        document.querySelectorAll('.tab-btn')[1].click();
      }

      // / to focus search
      if (e.key === '/' && !e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        document.getElementById('search-box').focus();
      }

      // ? to show shortcuts
      if (e.key === '?' || (e.shiftKey && e.key === '/')) {
        e.preventDefault();
        ShortcutsModal.toggle();
      }

      // F to toggle filters
      if (e.key === 'f' || e.key === 'F') {
        e.preventDefault();
        FilterManager.togglePanel();
      }

      // T to toggle theme
      if (e.key === 't' || e.key === 'T') {
        e.preventDefault();
        ThemeManager.toggle();
        showToast(`Switched to ${document.documentElement.getAttribute('data-theme')} mode`, 'success');
      }

      // R to refresh
      if (e.key === 'r' || e.key === 'R') {
        e.preventDefault();
        RefreshManager.refresh();
      }

      // Escape to close modals
      if (e.key === 'Escape') {
        ShortcutsModal.close();
        HelpModal.close();
        ColumnManager.close();
        AlertDrawer.close();
        MetricModals.close('avg-duration');
        MetricModals.close('oldest-alert');
        MetricModals.close('velocity');
        MetricModals.close('recurring');
        MetricModals.close('health-score');
        document.getElementById('filters-panel').classList.remove('show');
        document.getElementById('refresh-dropdown').classList.remove('show');
        document.getElementById('export-menu').classList.remove('show');
        document.getElementById('view-presets-dropdown')?.classList.remove('show');
      }

      // Ctrl+A to select all in current table
      if (e.ctrlKey && e.key === 'a') {
        e.preventDefault();
        const activePanel = document.querySelector('.tab-panel[style*="block"]') || document.getElementById('active');
        const headerCheckbox = activePanel.querySelector('.row-checkbox-header');
        if (headerCheckbox) {
          headerCheckbox.checked = true;
          headerCheckbox.dispatchEvent(new Event('change'));
        }
      }

      // O to open Oldest Alert modal
      if (e.key === 'o' || e.key === 'O') {
        e.preventDefault();
        MetricModals.openOldestAlert();
      }

      // G to open Health Score modal (G for "Good/bad" health)
      if (e.key === 'g' || e.key === 'G') {
        e.preventDefault();
        MetricModals.openHealthScore();
      }

      // V to open Velocity modal
      if (e.key === 'v' || e.key === 'V') {
        e.preventDefault();
        MetricModals.openVelocity();
      }

      // 1-5 to filter to top oldest alerts (when insight card visible)
      if (['1', '2', '3', '4', '5'].includes(e.key) && !e.altKey && !e.ctrlKey && !e.metaKey) {
        const oldestCard = document.getElementById('oldest-alerts-card');
        if (oldestCard?.classList.contains('show')) {
          const items = oldestCard.querySelectorAll('.insight-list-item');
          const index = parseInt(e.key) - 1;
          if (items[index]) {
            e.preventDefault();
            const hostname = items[index].querySelector('.insight-item-primary')?.textContent;
            if (hostname) {
              InsightCards.filterByHostname(hostname);
            }
          }
        }
      }

      // D to cycle through density modes
      if (e.key === 'd' || e.key === 'D') {
        e.preventDefault();
        const densities = ['compact', 'comfortable', 'spacious'];
        const currentIndex = densities.indexOf(DensityManager.current);
        const nextIndex = (currentIndex + 1) % densities.length;
        DensityManager.setDensity(densities[nextIndex]);
        showToast(`Switched to ${densities[nextIndex]} view`, 'success');
      }

      // C to open column configuration
      if (e.key === 'c' || e.key === 'C') {
        e.preventDefault();
        ColumnManager.open();
      }

      // H to open help
      if (e.key === 'h' || e.key === 'H') {
        e.preventDefault();
        HelpModal.toggle();
      }
    });

    // ========================================
    // SECTION COLLAPSE MANAGER
    // ========================================

    const SectionManager = {
      collapsed: {},
      // Sections that should be collapsed by default
      defaultCollapsed: ['metrics', 'charts', 'incidents'],

      init() {
        const saved = localStorage.getItem('prometheos-collapsed-sections');

        if (saved) {
          // Use saved preferences
          this.collapsed = JSON.parse(saved);
        } else {
          // First load: collapse all analytics sections by default
          this.defaultCollapsed.forEach(section => {
            this.collapsed[section] = true;
          });
        }

        // Apply states
        Object.keys(this.collapsed).forEach(section => {
          if (this.collapsed[section]) {
            this.setCollapsed(section, true, false);
          }
        });

        // Save initial state if first load
        if (!saved) {
          localStorage.setItem('prometheos-collapsed-sections', JSON.stringify(this.collapsed));
        }
      },

      toggle(section) {
        const isCollapsed = this.collapsed[section] || false;
        this.setCollapsed(section, !isCollapsed, true);
      },

      setCollapsed(section, collapsed, save = true) {
        const header = document.querySelector(`#${section}-section .section-header`);
        const content = document.getElementById(`${section}-content`);

        if (header && content) {
          header.classList.toggle('collapsed', collapsed);
          content.classList.toggle('collapsed', collapsed);
        }

        this.collapsed[section] = collapsed;

        if (save) {
          localStorage.setItem('prometheos-collapsed-sections', JSON.stringify(this.collapsed));
        }
      }
    };

    // ========================================
    // TIME RANGE MANAGER
    // ========================================

    const TimeRangeManager = {
      current: '24h',
      rangeMs: {
        '1h': 60 * 60 * 1000,
        '6h': 6 * 60 * 60 * 1000,
        '24h': 24 * 60 * 60 * 1000,
        '7d': 7 * 24 * 60 * 60 * 1000
      },

      init() {
        const saved = localStorage.getItem('prometheos-analytics-range');
        if (saved && this.rangeMs[saved]) {
          this.current = saved;
        }

        this.updateUI();
        this.bindEvents();
      },

      bindEvents() {
        document.querySelectorAll('.time-range-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const range = btn.dataset.range;
            this.setRange(range);
          });
        });
      },

      setRange(range) {
        this.current = range;
        localStorage.setItem('prometheos-analytics-range', range);
        this.updateUI();
        updateAdvancedAnalytics();
        showToast(`Analytics range set to ${this.getRangeLabel(range)}`, 'success');
      },

      updateUI() {
        document.querySelectorAll('.time-range-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.range === this.current);
        });

        // Update labels
        const velocityLabel = document.getElementById('velocity-range-label');
        if (velocityLabel) {
          velocityLabel.textContent = this.getRangeLabel(this.current);
        }

        const timelineStart = document.getElementById('timeline-start');
        if (timelineStart) {
          timelineStart.textContent = this.getRangeLabel(this.current) + ' ago';
        }
      },

      getRangeLabel(range) {
        const labels = { '1h': '1 hour', '6h': '6 hours', '24h': '24 hours', '7d': '7 days' };
        return labels[range] || range;
      },

      getRangeMs() {
        return this.rangeMs[this.current] || this.rangeMs['24h'];
      }
    };

    // ========================================
    // INCIDENT MANAGER - Infrastructure-Based Detection
    // ========================================

    const IncidentManager = {
      incidents: [],
      dismissedIncidents: [], // Track deleted incidents to prevent re-detection
      selectedAlerts: new Set(),
      windowMinutes: 5,
      CLUSTER_WINDOW_MS: 5 * 60 * 1000, // 5 minutes (default)
      minAlerts: 3,  // Minimum alerts to form an incident
      minHosts: 2,   // Minimum unique hosts to form an incident
      useCustomWindow: false, // Whether using custom date range
      customDateStart: null,  // Custom date range start
      customDateEnd: null,    // Custom date range end
      // Incident type filters - which types to detect
      enabledTypes: {
        rack: true,
        row: true,
        section: false,  // Disabled by default to reduce noise
        account: true
      },

      // Hostnames to exclude from account-based grouping (internal infrastructure)
      excludedHostnamePatterns: [
        /\.liquidweb\.com$/i,
        /\.nexcess\.net$/i,
        /^metalseed\./i
      ],

      init() {
        // Load saved window setting
        const savedWindow = localStorage.getItem('prometheos-incident-window');
        if (savedWindow === 'custom') {
          this.useCustomWindow = true;
          // Load saved date range
          const savedDateStart = localStorage.getItem('prometheos-incident-date-start');
          const savedDateEnd = localStorage.getItem('prometheos-incident-date-end');
          if (savedDateStart) this.customDateStart = new Date(savedDateStart);
          if (savedDateEnd) this.customDateEnd = new Date(savedDateEnd);
        } else if (savedWindow) {
          this.windowMinutes = parseInt(savedWindow) || 5;
          this.CLUSTER_WINDOW_MS = this.windowMinutes * 60 * 1000;
        }

        // Load saved threshold settings
        const savedMinAlerts = localStorage.getItem('prometheos-incident-min-alerts');
        const savedMinHosts = localStorage.getItem('prometheos-incident-min-hosts');
        if (savedMinAlerts) {
          if (savedMinAlerts === 'custom') {
            const customValue = localStorage.getItem('prometheos-incident-min-alerts-custom');
            this.minAlerts = parseInt(customValue) || 3;
          } else {
            this.minAlerts = parseInt(savedMinAlerts) || 3;
          }
        }
        if (savedMinHosts) {
          if (savedMinHosts === 'custom') {
            const customValue = localStorage.getItem('prometheos-incident-min-hosts-custom');
            this.minHosts = parseInt(customValue) || 2;
          } else {
            this.minHosts = parseInt(savedMinHosts) || 2;
          }
        }

        // Load saved type filters
        const savedTypes = localStorage.getItem('prometheos-incident-enabled-types');
        if (savedTypes) {
          try {
            this.enabledTypes = JSON.parse(savedTypes);
          } catch (e) {
            // Use defaults
          }
        }

        // Update select elements
        const windowSelect = document.getElementById('incident-window-select');
        if (windowSelect) {
          if (this.useCustomWindow) {
            windowSelect.value = 'custom';
          } else {
            windowSelect.value = this.windowMinutes.toString();
          }
        }

        // Show/hide date range picker
        this.updateDateRangeVisibility();

        // Update date inputs if we have saved values
        if (this.customDateStart) {
          const startInput = document.getElementById('incident-date-start');
          if (startInput) startInput.value = this.formatDateTimeLocal(this.customDateStart);
        }
        if (this.customDateEnd) {
          const endInput = document.getElementById('incident-date-end');
          if (endInput) endInput.value = this.formatDateTimeLocal(this.customDateEnd);
        }

        // Update min alerts select and custom input
        const minAlertsSelect = document.getElementById('incident-min-alerts');
        const minAlertsCustom = document.getElementById('incident-min-alerts-custom');
        const savedMinAlertsRaw = localStorage.getItem('prometheos-incident-min-alerts');
        if (savedMinAlertsRaw === 'custom') {
          if (minAlertsSelect) minAlertsSelect.value = 'custom';
          if (minAlertsCustom) {
            minAlertsCustom.style.display = 'block';
            minAlertsCustom.value = this.minAlerts;
          }
        } else if (minAlertsSelect) {
          // Check if value exists in options
          const options = Array.from(minAlertsSelect.options).map(o => o.value);
          if (options.includes(this.minAlerts.toString())) {
            minAlertsSelect.value = this.minAlerts.toString();
          } else {
            minAlertsSelect.value = 'custom';
            if (minAlertsCustom) {
              minAlertsCustom.style.display = 'block';
              minAlertsCustom.value = this.minAlerts;
            }
          }
        }

        // Update min hosts select and custom input
        const minHostsSelect = document.getElementById('incident-min-hosts');
        const minHostsCustom = document.getElementById('incident-min-hosts-custom');
        const savedMinHostsRaw = localStorage.getItem('prometheos-incident-min-hosts');
        if (savedMinHostsRaw === 'custom') {
          if (minHostsSelect) minHostsSelect.value = 'custom';
          if (minHostsCustom) {
            minHostsCustom.style.display = 'block';
            minHostsCustom.value = this.minHosts;
          }
        } else if (minHostsSelect) {
          // Check if value exists in options
          const options = Array.from(minHostsSelect.options).map(o => o.value);
          if (options.includes(this.minHosts.toString())) {
            minHostsSelect.value = this.minHosts.toString();
          } else {
            minHostsSelect.value = 'custom';
            if (minHostsCustom) {
              minHostsCustom.style.display = 'block';
              minHostsCustom.value = this.minHosts;
            }
          }
        }

        // Update type filter toggles
        this.updateTypeFilterUI();

        const saved = localStorage.getItem('prometheos-incidents');
        this.incidents = saved ? JSON.parse(saved) : [];

        // Load dismissed incidents
        const dismissed = localStorage.getItem('prometheos-dismissed-incidents');
        this.dismissedIncidents = dismissed ? JSON.parse(dismissed) : [];

        this.detectIncidents();
        this.render();
        this.updateExportCounts();
      },

      // Format date for datetime-local input
      formatDateTimeLocal(date) {
        const d = new Date(date);
        const year = d.getFullYear();
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        const hours = String(d.getHours()).padStart(2, '0');
        const minutes = String(d.getMinutes()).padStart(2, '0');
        return `${year}-${month}-${day}T${hours}:${minutes}`;
      },

      // Toggle incident type filter
      toggleType(type, element) {
        this.enabledTypes[type] = !this.enabledTypes[type];

        // Update UI
        if (this.enabledTypes[type]) {
          element.classList.add('active');
        } else {
          element.classList.remove('active');
        }

        // Save to localStorage
        localStorage.setItem('prometheos-incident-enabled-types', JSON.stringify(this.enabledTypes));

        // Rescan with new filters
        this.rescanWithMessage(`${type} detection ${this.enabledTypes[type] ? 'enabled' : 'disabled'}`);
      },

      // Update type filter UI from state
      updateTypeFilterUI() {
        ['rack', 'row', 'section', 'account'].forEach(type => {
          const toggle = document.getElementById(`incident-type-${type}`);
          if (toggle) {
            if (this.enabledTypes[type]) {
              toggle.classList.add('active');
            } else {
              toggle.classList.remove('active');
            }
          }
        });
      },

      // Show/hide date range picker based on window selection
      updateDateRangeVisibility() {
        const dateRange = document.getElementById('incident-date-range');
        if (dateRange) {
          if (this.useCustomWindow) {
            dateRange.classList.add('visible');
          } else {
            dateRange.classList.remove('visible');
          }
        }
      },

      // Set custom date range
      setDateRange() {
        const startInput = document.getElementById('incident-date-start');
        const endInput = document.getElementById('incident-date-end');

        if (startInput && startInput.value) {
          this.customDateStart = new Date(startInput.value);
          localStorage.setItem('prometheos-incident-date-start', this.customDateStart.toISOString());
        }
        if (endInput && endInput.value) {
          this.customDateEnd = new Date(endInput.value);
          localStorage.setItem('prometheos-incident-date-end', this.customDateEnd.toISOString());
        }

        if (this.customDateStart && this.customDateEnd) {
          this.rescanWithMessage('Custom date range updated');
        }
      },

      // Set custom min alerts value
      setMinAlertsCustom(value) {
        const count = parseInt(value) || 3;
        this.minAlerts = Math.max(1, count);
        localStorage.setItem('prometheos-incident-min-alerts', 'custom');
        localStorage.setItem('prometheos-incident-min-alerts-custom', this.minAlerts.toString());
        this.rescanWithMessage(`Min alerts changed to ${this.minAlerts}`);
      },

      // Set custom min hosts value
      setMinHostsCustom(value) {
        const count = parseInt(value) || 2;
        this.minHosts = Math.max(1, count);
        localStorage.setItem('prometheos-incident-min-hosts', 'custom');
        localStorage.setItem('prometheos-incident-min-hosts-custom', this.minHosts.toString());
        this.rescanWithMessage(`Min hosts changed to ${this.minHosts}`);
      },

      // Generate a signature for an incident to track dismissals
      getIncidentSignature(incident) {
        // Signature based on type + key (location or account)
        if (incident.type === 'account') {
          return `account:${incident.account}`;
        } else if (incident.locationKey) {
          return `${incident.type}:${incident.locationKey}`;
        }
        // Fallback: use sorted hostnames
        const hostnames = incident.alerts.map(a => a.hostname).sort().join(',');
        return `hosts:${hostnames}`;
      },

      // Check if an incident signature is dismissed
      isIncidentDismissed(signature) {
        return this.dismissedIncidents.includes(signature);
      },

      // Dismiss an incident by its signature
      dismissIncident(signature) {
        if (!this.dismissedIncidents.includes(signature)) {
          this.dismissedIncidents.push(signature);
          this.saveDismissed();
        }
      },

      // Clear all dismissed incidents (allows them to be re-detected)
      clearDismissed() {
        this.dismissedIncidents = [];
        this.saveDismissed();
        this.detectIncidents();
        this.render();
        showToast('Dismissed incidents cleared - they may reappear on next scan', 'info');
      },

      saveDismissed() {
        localStorage.setItem('prometheos-dismissed-incidents', JSON.stringify(this.dismissedIncidents));
      },

      // Parse location code: B3S2R9K8U27 -> { datacenter, section, row, rack, unit }
      parseLocation(location) {
        if (!location) return null;

        // Pattern: B{num}S{num}R{num}K{num}U{num}
        const match = location.match(/^B(\d+)S(\d+)R(\d+)K(\d+)(?:U(\d+))?$/i);
        if (!match) return null;

        return {
          datacenter: `B${match[1]}`,
          section: `B${match[1]}S${match[2]}`,
          row: `B${match[1]}S${match[2]}R${match[3]}`,
          rack: `B${match[1]}S${match[2]}R${match[3]}K${match[4]}`,
          unit: match[5] ? `B${match[1]}S${match[2]}R${match[3]}K${match[4]}U${match[5]}` : null,
          raw: location
        };
      },

      // Check if hostname should be excluded from account-based grouping
      isExcludedHostname(hostname) {
        return this.excludedHostnamePatterns.some(pattern => pattern.test(hostname));
      },

      setWindow(minutes) {
        if (minutes === 'custom') {
          this.useCustomWindow = true;
          localStorage.setItem('prometheos-incident-window', 'custom');
          this.updateDateRangeVisibility();
          // Initialize date range to now and 24 hours ago if not set
          if (!this.customDateStart || !this.customDateEnd) {
            const now = new Date();
            const dayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
            this.customDateEnd = now;
            this.customDateStart = dayAgo;
            const startInput = document.getElementById('incident-date-start');
            const endInput = document.getElementById('incident-date-end');
            if (startInput) startInput.value = this.formatDateTimeLocal(dayAgo);
            if (endInput) endInput.value = this.formatDateTimeLocal(now);
            localStorage.setItem('prometheos-incident-date-start', dayAgo.toISOString());
            localStorage.setItem('prometheos-incident-date-end', now.toISOString());
          }
          showToast('Custom date range enabled - select start and end dates', 'info');
          return;
        }

        this.useCustomWindow = false;
        this.windowMinutes = parseInt(minutes) || 5;
        this.CLUSTER_WINDOW_MS = this.windowMinutes * 60 * 1000;
        localStorage.setItem('prometheos-incident-window', this.windowMinutes.toString());
        this.updateDateRangeVisibility();
        this.rescanWithMessage(`Window changed to ${this.windowMinutes}min`);
      },

      setMinAlerts(count) {
        const minAlertsCustom = document.getElementById('incident-min-alerts-custom');

        if (count === 'custom') {
          if (minAlertsCustom) {
            minAlertsCustom.style.display = 'block';
            minAlertsCustom.value = this.minAlerts;
            minAlertsCustom.focus();
          }
          localStorage.setItem('prometheos-incident-min-alerts', 'custom');
          localStorage.setItem('prometheos-incident-min-alerts-custom', this.minAlerts.toString());
          return;
        }

        if (minAlertsCustom) {
          minAlertsCustom.style.display = 'none';
        }
        this.minAlerts = parseInt(count) || 3;
        localStorage.setItem('prometheos-incident-min-alerts', this.minAlerts.toString());
        this.rescanWithMessage(`Min alerts changed to ${this.minAlerts}`);
      },

      setMinHosts(count) {
        const minHostsCustom = document.getElementById('incident-min-hosts-custom');

        if (count === 'custom') {
          if (minHostsCustom) {
            minHostsCustom.style.display = 'block';
            minHostsCustom.value = this.minHosts;
            minHostsCustom.focus();
          }
          localStorage.setItem('prometheos-incident-min-hosts', 'custom');
          localStorage.setItem('prometheos-incident-min-hosts-custom', this.minHosts.toString());
          return;
        }

        if (minHostsCustom) {
          minHostsCustom.style.display = 'none';
        }
        this.minHosts = parseInt(count) || 2;
        localStorage.setItem('prometheos-incident-min-hosts', this.minHosts.toString());
        this.rescanWithMessage(`Min hosts changed to ${this.minHosts}`);
      },

      rescan() {
        this.rescanWithMessage('Manual rescan');
      },

      rescanWithMessage(reason) {
        const previousCount = this.incidents.length;
        const savedIncidents = this.incidents.filter(inc => this.isIncidentSaved(inc));
        const clearedCount = previousCount - savedIncidents.length;

        this.incidents = savedIncidents;
        this.detectIncidents();

        const newCount = this.incidents.length - savedIncidents.length;

        let message = reason ? `${reason}: ` : '';
        const parts = [];
        if (newCount > 0) parts.push(`${newCount} new`);
        if (clearedCount > 0) parts.push(`${clearedCount} cleared`);
        if (savedIncidents.length > 0) parts.push(`${savedIncidents.length} preserved`);

        message += parts.length > 0 ? parts.join(', ') : 'No incidents found';
        showToast(message, 'success');
      },

      isIncidentSaved(incident) {
        const autoGeneratedPrefixes = [
          'Rack Outage',
          'Row Outage',
          'Section Outage',
          'Datacenter Outage',
          'Account Outage',
          'Infrastructure Incident',
          'Manual Incident'
        ];
        const isAutoName = autoGeneratedPrefixes.some(prefix => incident.name.startsWith(prefix));

        // An incident is "saved" (should be preserved) if:
        // 1. It has notes
        // 2. Its name was manually changed
        // 3. Its status was changed from 'new' (meaning user acknowledged it)
        return (
          (incident.notes && incident.notes.length > 0) ||
          !isAutoName ||
          incident.status !== 'new'
        );
      },

      detectIncidents() {
        const rows = document.querySelectorAll('#active-table tbody tr:not(.filtered-out)');
        let alerts = [];

        // Collect all alerts with parsed location data
        rows.forEach(row => {
          const timeStr = row.dataset.time;
          const hostname = row.querySelector('.hostname')?.textContent.trim() || '';

          if (timeStr && hostname) {
            const location = row.dataset.location || '';
            const parsedLocation = this.parseLocation(location);

            alerts.push({
              id: hostname + '-' + timeStr,
              hostname: hostname,
              account: row.querySelector('.cell-primary')?.textContent.trim() || '',
              time: new Date(timeStr.replace(' ', 'T')),
              timeStr: timeStr,
              services: row.dataset.services || '',
              location: location,
              parsedLocation: parsedLocation,
              isExcluded: this.isExcludedHostname(hostname)
            });
          }
        });

        // Filter alerts by custom date range if using custom window mode
        if (this.useCustomWindow && this.customDateStart && this.customDateEnd) {
          alerts = alerts.filter(a => {
            return a.time >= this.customDateStart && a.time <= this.customDateEnd;
          });
        }

        // Group alerts by infrastructure hierarchy (rack > row > section > datacenter)
        // and by account for non-excluded hosts
        // IMPORTANT: Within each group, cluster by time window to avoid grouping unrelated alerts
        const newIncidents = [];

        // Helper to check if incident should be created (not dismissed and type enabled)
        const shouldCreateIncident = (type, key) => {
          // Check if type is enabled in filters
          if (!this.enabledTypes[type]) return false;
          const signature = type === 'account' ? `account:${key}` : `${type}:${key}`;
          return !this.isIncidentDismissed(signature);
        };

        // Helper to process a location group - clusters by time and creates incidents
        const processLocationGroup = (groupAlerts, type, key) => {
          if (!key || !shouldCreateIncident(type, key)) return [];

          // Cluster alerts within this location group by time window
          const timeClusters = this.clusterByTimeWindow(groupAlerts);
          const incidents = [];

          timeClusters.forEach(cluster => {
            if (this.meetsInfrastructureCriteria(cluster)) {
              incidents.push(this.createInfrastructureIncident(cluster, type, key));
            }
          });

          return incidents;
        };

        // 1. First, detect RACK-level incidents (highest priority)
        if (this.enabledTypes.rack) {
          const rackGroups = this.groupAlertsByKey(alerts, a => a.parsedLocation?.rack);
          rackGroups.forEach((groupAlerts, rack) => {
            const incidents = processLocationGroup(groupAlerts, 'rack', rack);
            newIncidents.push(...incidents);
          });
        }

        // Get alerts already in rack incidents to avoid double-counting
        const rackAlertIds = new Set(newIncidents.flatMap(i => i.alerts.map(a => a.id)));

        // 2. Detect ROW-level incidents (alerts not already in rack incidents)
        if (this.enabledTypes.row) {
          const remainingForRow = alerts.filter(a => !rackAlertIds.has(a.id));
          const rowGroups = this.groupAlertsByKey(remainingForRow, a => a.parsedLocation?.row);
          rowGroups.forEach((groupAlerts, row) => {
            const incidents = processLocationGroup(groupAlerts, 'row', row);
            newIncidents.push(...incidents);
          });
        }

        // Get alerts in rack or row incidents
        const infraAlertIds = new Set(newIncidents.flatMap(i => i.alerts.map(a => a.id)));

        // 3. Detect SECTION-level incidents
        if (this.enabledTypes.section) {
          const remainingForSection = alerts.filter(a => !infraAlertIds.has(a.id));
          const sectionGroups = this.groupAlertsByKey(remainingForSection, a => a.parsedLocation?.section);
          sectionGroups.forEach((groupAlerts, section) => {
            const incidents = processLocationGroup(groupAlerts, 'section', section);
            newIncidents.push(...incidents);
          });
        }

        // Update infraAlertIds
        const allInfraAlertIds = new Set(newIncidents.flatMap(i => i.alerts.map(a => a.id)));

        // 4. Detect ACCOUNT-based incidents (for non-excluded hosts not in infra incidents)
        if (this.enabledTypes.account) {
          const remainingForAccount = alerts.filter(a =>
            !allInfraAlertIds.has(a.id) && !a.isExcluded
          );
          const accountGroups = this.groupAlertsByKey(remainingForAccount, a => a.account);
          accountGroups.forEach((groupAlerts, account) => {
            if (!account || !shouldCreateIncident('account', account)) return;

            // Cluster by time window for account groups too
            const timeClusters = this.clusterByTimeWindow(groupAlerts);
            timeClusters.forEach(cluster => {
              if (this.meetsAccountCriteria(cluster)) {
                newIncidents.push(this.createAccountIncident(cluster, account));
              }
            });
          });
        }

        this.mergeIncidents(newIncidents);
        this.save();
        this.render();
        this.updateIncidentCounts();
      },

      groupAlertsByKey(alerts, keyFn) {
        const groups = new Map();
        alerts.forEach(alert => {
          const key = keyFn(alert);
          if (key) {
            if (!groups.has(key)) {
              groups.set(key, []);
            }
            groups.get(key).push(alert);
          }
        });
        return groups;
      },

      // Cluster alerts by time window - returns array of clusters
      clusterByTimeWindow(alerts) {
        if (alerts.length === 0) return [];

        // When using custom date range, treat all alerts in range as one cluster
        if (this.useCustomWindow) {
          return [alerts];
        }

        // Sort by time
        const sorted = [...alerts].sort((a, b) => a.time - b.time);
        const clusters = [];
        let currentCluster = [sorted[0]];

        for (let i = 1; i < sorted.length; i++) {
          const alert = sorted[i];
          const lastInCluster = currentCluster[currentCluster.length - 1];
          const timeDiff = alert.time - lastInCluster.time;

          if (timeDiff <= this.CLUSTER_WINDOW_MS) {
            currentCluster.push(alert);
          } else {
            clusters.push(currentCluster);
            currentCluster = [alert];
          }
        }

        // Don't forget the last cluster
        if (currentCluster.length > 0) {
          clusters.push(currentCluster);
        }

        return clusters;
      },

      meetsInfrastructureCriteria(alerts) {
        // For infrastructure incidents: need minimum alerts AND minimum hosts in same location
        const minAlerts = this.minAlerts || 3;
        const minHosts = this.minHosts || 2;
        const uniqueHosts = new Set(alerts.map(a => a.hostname)).size;
        return alerts.length >= minAlerts && uniqueHosts >= minHosts;
      },

      meetsAccountCriteria(alerts) {
        // For account incidents: need minimum alerts AND multiple hosts from same account
        const minAlerts = this.minAlerts || 3;
        const minHosts = this.minHosts || 2;
        const uniqueHosts = new Set(alerts.map(a => a.hostname)).size;
        return alerts.length >= minAlerts && uniqueHosts >= minHosts;
      },

      createInfrastructureIncident(alerts, level, locationKey) {
        const firstAlert = alerts.reduce((min, a) => a.time < min.time ? a : min);
        const lastAlert = alerts.reduce((max, a) => a.time > max.time ? a : max);
        const stats = this.getClusterStats(alerts);

        // Format level-appropriate name
        let levelLabel;
        switch (level) {
          case 'rack': levelLabel = 'Rack'; break;
          case 'row': levelLabel = 'Row'; break;
          case 'section': levelLabel = 'Section'; break;
          case 'datacenter': levelLabel = 'Datacenter'; break;
          default: levelLabel = 'Infrastructure';
        }

        const name = `${levelLabel} Outage: ${locationKey} (${stats.hostCount} hosts)`;

        return {
          id: Date.now() + Math.random().toString(36).substr(2, 9),
          name: name,
          type: level, // 'rack', 'row', 'section', 'datacenter'
          locationKey: locationKey,
          status: 'new',
          alerts: alerts,
          stats: stats,
          startTime: firstAlert.time.toISOString(),
          endTime: lastAlert.time.toISOString(),
          notes: [],
          createdAt: new Date().toISOString()
        };
      },

      createAccountIncident(alerts, account) {
        const firstAlert = alerts.reduce((min, a) => a.time < min.time ? a : min);
        const lastAlert = alerts.reduce((max, a) => a.time > max.time ? a : max);
        const stats = this.getClusterStats(alerts);

        const name = `Account Outage: ${account} (${stats.hostCount} hosts)`;

        return {
          id: Date.now() + Math.random().toString(36).substr(2, 9),
          name: name,
          type: 'account',
          account: account,
          status: 'new',
          alerts: alerts,
          stats: stats,
          startTime: firstAlert.time.toISOString(),
          endTime: lastAlert.time.toISOString(),
          notes: [],
          createdAt: new Date().toISOString()
        };
      },

      getClusterStats(cluster) {
        const uniqueHosts = new Set(cluster.map(a => a.hostname));
        const uniqueAccounts = new Set(cluster.map(a => a.account));
        const uniqueLocations = new Set(cluster.map(a => a.location).filter(l => l));

        return {
          alertCount: cluster.length,
          hostCount: uniqueHosts.size,
          accountCount: uniqueAccounts.size,
          locationCount: uniqueLocations.size,
          hosts: [...uniqueHosts],
          accounts: [...uniqueAccounts],
          locations: [...uniqueLocations]
        };
      },

      createFromAlerts(alertsData) {
        // Create incident from bulk-selected alerts
        const alerts = alertsData.map(a => ({
          id: a.hostname + '-' + a.time,
          hostname: a.hostname,
          account: a.account,
          time: new Date(a.time?.replace(' ', 'T') || Date.now()),
          timeStr: a.time,
          services: a.services,
          location: a.location
        }));

        alerts.sort((a, b) => a.time - b.time);

        const incident = {
          id: Date.now() + Math.random().toString(36).substr(2, 9),
          name: `Manual Incident ${new Date().toLocaleString()}`,
          status: 'investigating',
          alerts: alerts,
          startTime: alerts[0]?.time?.toISOString() || new Date().toISOString(),
          endTime: alerts[alerts.length - 1]?.time?.toISOString() || new Date().toISOString(),
          notes: [],
          createdAt: new Date().toISOString()
        };

        this.incidents.push(incident);
        this.save();
        this.render();
        this.updateIncidentCounts();

        // Expand incidents section
        SectionManager.setCollapsed('incidents', false);
      },

      mergeIncidents(newIncidents) {
        // Simple merge: keep existing incident data if alert IDs overlap
        const existingById = {};
        this.incidents.forEach(inc => {
          const alertIds = inc.alerts.map(a => a.id).join(',');
          existingById[alertIds] = inc;
        });

        this.incidents = newIncidents.map(newInc => {
          const alertIds = newInc.alerts.map(a => a.id).join(',');
          if (existingById[alertIds]) {
            // Preserve name, status, and notes from existing
            return {
              ...newInc,
              id: existingById[alertIds].id,
              name: existingById[alertIds].name,
              status: existingById[alertIds].status,
              notes: existingById[alertIds].notes
            };
          }
          return newInc;
        });
      },

      updateIncidentCounts() {
        const countEl = document.getElementById('incidents-count');
        const badgeEl = document.getElementById('incidents-badge');

        if (countEl) countEl.textContent = this.incidents.length;
        if (badgeEl) badgeEl.textContent = `${this.incidents.length} groups`;
      },

      updateExportCounts() {
        const activeRows = document.querySelectorAll('#active-table tbody tr:not(.filtered-out)');
        const csvCount = document.getElementById('export-csv-count');
        const jsonCount = document.getElementById('export-json-count');
        const incidentsCount = document.getElementById('export-incidents-count');

        if (csvCount) csvCount.textContent = `${activeRows.length} rows`;
        if (jsonCount) jsonCount.textContent = `${activeRows.length} rows`;
        if (incidentsCount) incidentsCount.textContent = `${this.incidents.length} incidents`;
      },

      render() {
        const container = document.getElementById('incidents-list');
        if (!container) return;

        if (this.incidents.length === 0) {
          container.innerHTML = `
            <div class="widget-empty">
              <div class="widget-empty-icon">
                <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                  <path d="M12 2L2 7l10 5 10-5-10-5z"></path>
                  <path d="M2 17l10 5 10-5"></path>
                  <path d="M2 12l10 5 10-5"></path>
                </svg>
              </div>
              <span class="widget-empty-text">No infrastructure incidents detected. Requires ${this.minHosts}+ hosts in same rack, row, section, or account.</span>
            </div>
          `;
          return;
        }

        container.innerHTML = this.incidents.map(incident => this.renderIncident(incident)).join('');
      },

      renderIncident(incident) {
        const alertCount = incident.alerts.length;
        const duration = new Date(incident.endTime) - new Date(incident.startTime);
        const durationStr = formatDuration(duration);

        // Get stats (either from stored stats or calculate)
        const stats = incident.stats || this.getClusterStats(incident.alerts);
        const hostCount = stats.hostCount || new Set(incident.alerts.map(a => a.hostname)).size;

        // Color based on incident type (infrastructure level)
        let severityClass = '';
        let typeLabel = '';
        switch (incident.type) {
          case 'rack':
            severityClass = ''; // Critical (red) - same rack is highest priority
            typeLabel = 'RACK';
            break;
          case 'row':
            severityClass = 'warning'; // Warning (orange)
            typeLabel = 'ROW';
            break;
          case 'section':
            severityClass = 'info'; // Info (cyan)
            typeLabel = 'SECTION';
            break;
          case 'account':
            severityClass = 'account'; // Purple
            typeLabel = 'ACCOUNT';
            break;
          default:
            severityClass = hostCount >= 5 ? '' : hostCount >= 3 ? 'warning' : 'info';
            typeLabel = 'INFRA';
        }

        return `
          <div class="incident-group" id="incident-${incident.id}" data-id="${incident.id}" data-type="${incident.type || 'unknown'}">
            <div class="incident-header" onclick="IncidentManager.toggleExpand('${incident.id}')">
              <div class="incident-expand-icon">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <polyline points="9 18 15 12 9 6"></polyline>
                </svg>
              </div>
              <div class="incident-color-bar ${severityClass}"></div>
              <div class="incident-info">
                <div class="incident-name-row">
                  <span class="incident-name" id="incident-name-${incident.id}">${this.escapeHtml(incident.name)}</span>
                  <button type="button" class="incident-edit-btn" onclick="event.stopPropagation(); IncidentManager.editName('${incident.id}')" title="Edit name">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                      <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                    </svg>
                  </button>
                  <span class="incident-status-badge ${incident.status}">${incident.status}</span>
                </div>
                <div class="incident-meta">
                  Started ${new Date(incident.startTime).toLocaleString()} &bull; Span: ${durationStr}
                </div>
              </div>
              <div class="incident-stats">
                <div class="incident-stat">
                  <div class="incident-stat-value">${hostCount}</div>
                  <div class="incident-stat-label">Hosts</div>
                </div>
                <div class="incident-stat">
                  <div class="incident-stat-value">${alertCount}</div>
                  <div class="incident-stat-label">Alerts</div>
                </div>
              </div>
              <div class="incident-actions">
                <div class="status-selector">
                  <button type="button" class="incident-action-btn" onclick="event.stopPropagation(); IncidentManager.toggleStatusDropdown('${incident.id}')" title="Change status">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <circle cx="12" cy="12" r="10"></circle>
                      <polyline points="12 6 12 12 16 14"></polyline>
                    </svg>
                  </button>
                  <div class="status-dropdown" id="status-dropdown-${incident.id}">
                    <div class="status-option" onclick="event.stopPropagation(); IncidentManager.setStatus('${incident.id}', 'new')">
                      <span class="status-dot new"></span>
                      <span>New</span>
                    </div>
                    <div class="status-option" onclick="event.stopPropagation(); IncidentManager.setStatus('${incident.id}', 'investigating')">
                      <span class="status-dot investigating"></span>
                      <span>Investigating</span>
                    </div>
                    <div class="status-option" onclick="event.stopPropagation(); IncidentManager.setStatus('${incident.id}', 'identified')">
                      <span class="status-dot identified"></span>
                      <span>Identified</span>
                    </div>
                    <div class="status-option" onclick="event.stopPropagation(); IncidentManager.setStatus('${incident.id}', 'monitoring')">
                      <span class="status-dot monitoring"></span>
                      <span>Monitoring</span>
                    </div>
                    <div class="status-option" onclick="event.stopPropagation(); IncidentManager.setStatus('${incident.id}', 'resolved')">
                      <span class="status-dot resolved"></span>
                      <span>Resolved</span>
                    </div>
                  </div>
                </div>
                <button type="button" class="incident-action-btn" onclick="event.stopPropagation(); IncidentManager.deleteIncident('${incident.id}')" title="Delete incident">
                  <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                  </svg>
                </button>
              </div>
            </div>
            <div class="incident-body">
              <div class="incident-alerts">
                ${incident.alerts.map(alert => `
                  <div class="incident-alert-item">
                    <div class="incident-alert-info">
                      <div class="incident-alert-hostname">${this.escapeHtml(alert.hostname)}</div>
                      <div class="incident-alert-meta">${this.escapeHtml(alert.account)} &bull; ${this.escapeHtml(alert.services.split(',').slice(0, 2).join(', '))}</div>
                    </div>
                    <div class="incident-alert-time">${alert.timeStr}</div>
                  </div>
                `).join('')}
              </div>
              <div class="incident-notes">
                <div class="incident-notes-header">
                  <span class="incident-notes-title">Notes & Annotations</span>
                </div>
                <div class="incident-notes-list" id="notes-list-${incident.id}">
                  ${incident.notes.length === 0 ? '' : incident.notes.map(note => `
                    <div class="incident-note">
                      <div class="incident-note-header">
                        <span class="incident-note-author">${this.escapeHtml(note.author || 'User')}</span>
                        <span class="incident-note-time">${new Date(note.createdAt).toLocaleString()}</span>
                      </div>
                      <div class="incident-note-text">${this.escapeHtml(note.text)}</div>
                    </div>
                  `).join('')}
                </div>
                <div class="incident-note-input">
                  <textarea class="incident-note-textarea" id="note-input-${incident.id}" placeholder="Add a note about this incident..."></textarea>
                  <button type="button" class="btn btn-sm btn-primary" onclick="IncidentManager.addNote('${incident.id}')">Add</button>
                </div>
              </div>
            </div>
          </div>
        `;
      },

      toggleExpand(id) {
        const el = document.getElementById(`incident-${id}`);
        if (el) {
          el.classList.toggle('expanded');
        }
      },

      toggleStatusDropdown(id) {
        // Close all other dropdowns first
        document.querySelectorAll('.status-dropdown.show').forEach(d => d.classList.remove('show'));

        const dropdown = document.getElementById(`status-dropdown-${id}`);
        if (dropdown) {
          dropdown.classList.toggle('show');
        }
      },

      setStatus(id, status) {
        const incident = this.incidents.find(i => i.id === id);
        if (incident) {
          incident.status = status;
          this.save();
          this.render();
          showToast(`Incident status set to ${status}`, 'success');
        }
      },

      editName(id) {
        const nameEl = document.getElementById(`incident-name-${id}`);
        if (!nameEl) return;

        const currentName = nameEl.textContent;
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'incident-name-input';
        input.value = currentName;

        const saveName = () => {
          const newName = input.value.trim() || currentName;
          const incident = this.incidents.find(i => i.id === id);
          if (incident) {
            incident.name = newName;
            this.save();
            this.render();
          }
        };

        input.addEventListener('blur', saveName);
        input.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            saveName();
          }
        });

        nameEl.replaceWith(input);
        input.focus();
        input.select();
      },

      addNote(id) {
        const input = document.getElementById(`note-input-${id}`);
        if (!input || !input.value.trim()) return;

        const incident = this.incidents.find(i => i.id === id);
        if (incident) {
          incident.notes.push({
            id: Date.now(),
            text: input.value.trim(),
            author: 'User',
            createdAt: new Date().toISOString()
          });
          this.save();
          this.render();
          showToast('Note added', 'success');

          // Re-expand the incident
          setTimeout(() => {
            const el = document.getElementById(`incident-${id}`);
            if (el) el.classList.add('expanded');
          }, 10);
        }
      },

      deleteIncident(id) {
        const incident = this.incidents.find(i => i.id === id);
        if (!incident) return;

        if (!confirm('Delete this incident grouping? It will not reappear on rescan. The alerts will remain but the grouping and notes will be lost.')) {
          return;
        }

        // Add to dismissed list so it won't be re-detected
        const signature = this.getIncidentSignature(incident);
        this.dismissIncident(signature);

        this.incidents = this.incidents.filter(i => i.id !== id);
        this.save();
        this.render();
        this.updateIncidentCounts();
        showToast('Incident deleted and dismissed', 'success');
      },

      save() {
        localStorage.setItem('prometheos-incidents', JSON.stringify(this.incidents));
      },

      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      },

      // Selection for manual incident creation
      toggleAlertSelection(alertId) {
        if (this.selectedAlerts.has(alertId)) {
          this.selectedAlerts.delete(alertId);
        } else {
          this.selectedAlerts.add(alertId);
        }
        this.updateSelectionUI();
      },

      updateSelectionUI() {
        const bar = document.getElementById('create-incident-bar');
        const countEl = document.getElementById('selected-for-incident');

        if (this.selectedAlerts.size > 0) {
          bar.classList.add('show');
          countEl.textContent = this.selectedAlerts.size;
        } else {
          bar.classList.remove('show');
        }
      },

      clearSelection() {
        this.selectedAlerts.clear();
        this.updateSelectionUI();
      },

      createFromSelection() {
        // Implementation for manual incident creation from selected alerts
        showToast('Manual incident creation - select alerts from the table first', 'info');
      }
    };

    // ========================================
    // ENHANCED EXPORT MANAGER
    // ========================================

    const ExportManagerEnhanced = {
      exportWithAnnotations(format) {
        const activePanel = document.querySelector('.tab-panel[style*="block"]') || document.getElementById('active');
        const table = activePanel.querySelector('.data-table');

        if (!table) return;

        const rows = table.querySelectorAll('tbody tr:not(.filtered-out)');
        const data = [];

        rows.forEach(row => {
          const cells = row.querySelectorAll('td');
          const hostname = cells[3]?.textContent.trim() || '';

          // Find if this alert is part of any incident
          let incidentName = '';
          let incidentStatus = '';
          let incidentNotes = [];

          IncidentManager.incidents.forEach(incident => {
            incident.alerts.forEach(alert => {
              if (alert.hostname === hostname) {
                incidentName = incident.name;
                incidentStatus = incident.status;
                incidentNotes = incident.notes.map(n => n.text);
              }
            });
          });

          data.push({
            uid: cells[1]?.textContent.trim() || '',
            account: cells[2]?.textContent.trim() || '',
            hostname: hostname,
            datacenter: cells[4]?.textContent.trim() || '',
            section: cells[5]?.textContent.trim() || '',
            row: cells[6]?.textContent.trim() || '',
            rack: cells[7]?.textContent.trim() || '',
            promNode: cells[8]?.textContent.trim() || '',
            startTime: cells[9]?.textContent.trim() || '',
            duration: cells[10]?.textContent.trim() || '',
            services: Array.from(cells[11]?.querySelectorAll('.service-tag') || []).map(t => t.textContent.trim()),
            incidentName: incidentName,
            incidentStatus: incidentStatus,
            notes: incidentNotes
          });
        });

        if (format === 'json') {
          const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
          downloadBlob(blob, `prometheos-alerts-annotated-${new Date().toISOString().slice(0, 10)}.json`);
          showToast('Exported with annotations as JSON', 'success');
        } else if (format === 'csv') {
          let csv = 'UID,Account,Hostname,DC,Section,Row,Rack,Prom Node,Start Time,Duration,Services,Incident,Status,Notes\n';
          data.forEach(row => {
            csv += `"${row.uid}","${row.account}","${row.hostname}","${row.datacenter}","${row.section}","${row.row}","${row.rack}","${row.promNode}","${row.startTime}","${row.duration}","${row.services.join('; ')}","${row.incidentName}","${row.incidentStatus}","${row.notes.join(' | ')}"\n`;
          });
          const blob = new Blob([csv], { type: 'text/csv' });
          downloadBlob(blob, `prometheos-alerts-annotated-${new Date().toISOString().slice(0, 10)}.csv`);
          showToast('Exported with annotations as CSV', 'success');
        }

        document.getElementById('export-menu').classList.remove('show');
      },

      exportIncidents(format) {
        const incidents = IncidentManager.incidents;

        if (incidents.length === 0) {
          showToast('No incidents to export', 'error');
          return;
        }

        const data = incidents.map(incident => ({
          id: incident.id,
          name: incident.name,
          status: incident.status,
          startTime: incident.startTime,
          endTime: incident.endTime,
          alertCount: incident.alerts.length,
          alerts: incident.alerts.map(a => ({
            hostname: a.hostname,
            account: a.account,
            time: a.timeStr,
            services: a.services
          })),
          notes: incident.notes.map(n => ({
            text: n.text,
            author: n.author,
            time: n.createdAt
          })),
          createdAt: incident.createdAt
        }));

        if (format === 'json') {
          const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
          downloadBlob(blob, `prometheos-incidents-${new Date().toISOString().slice(0, 10)}.json`);
          showToast('Incidents exported as JSON', 'success');
        } else if (format === 'csv') {
          let csv = 'Incident ID,Name,Status,Start Time,End Time,Alert Count,Hostnames,Notes\n';
          data.forEach(inc => {
            const hostnames = inc.alerts.map(a => a.hostname).join('; ');
            const notes = inc.notes.map(n => n.text).join(' | ');
            csv += `"${inc.id}","${inc.name}","${inc.status}","${inc.startTime}","${inc.endTime}","${inc.alertCount}","${hostnames}","${notes}"\n`;
          });
          const blob = new Blob([csv], { type: 'text/csv' });
          downloadBlob(blob, `prometheos-incidents-${new Date().toISOString().slice(0, 10)}.csv`);
          showToast('Incidents exported as CSV', 'success');
        }

        document.getElementById('export-menu').classList.remove('show');
      }
    };

    // Attach to ExportManager for button onclick handlers
    if (typeof ExportManager !== 'undefined') {
      ExportManager.exportWithAnnotations = ExportManagerEnhanced.exportWithAnnotations;
      ExportManager.exportIncidents = ExportManagerEnhanced.exportIncidents;
    }

    // ========================================
    // HEALTH SCORE CALCULATOR
    // ========================================

    function calculateHealthScore(alertData) {
      if (alertData.length === 0) return 100;

      const now = new Date();
      let score = 100;

      // Deduct points based on various factors
      // Alert count penalty (max -30)
      score -= Math.min(alertData.length * 2, 30);

      // Long-running alerts penalty (max -20)
      const longRunning = alertData.filter(a => a.duration > 60 * 60 * 1000).length;
      score -= Math.min(longRunning * 5, 20);

      // Recurring systems penalty (max -20)
      const systemCounts = {};
      alertData.forEach(a => {
        systemCounts[a.hostname] = (systemCounts[a.hostname] || 0) + 1;
      });
      const recurringCount = Object.values(systemCounts).filter(c => c >= 2).length;
      score -= Math.min(recurringCount * 5, 20);

      // Recent velocity penalty (max -15)
      const oneHourAgo = new Date(now - 60 * 60 * 1000);
      const recentAlerts = alertData.filter(a => a.time >= oneHourAgo).length;
      score -= Math.min(recentAlerts * 3, 15);

      // Incident count penalty (max -15)
      score -= Math.min(IncidentManager.incidents.length * 3, 15);

      return Math.max(0, Math.round(score));
    }

    // ========================================
    // DENSITY/VIEW MODE MANAGER
    // ========================================

    const DensityManager = {
      current: 'comfortable',

      init() {
        // Load saved density preference
        const savedDensity = localStorage.getItem('prometheos-density') || 'comfortable';
        this.setDensity(savedDensity);

        // Toggle dropdown
        const toggleBtn = document.getElementById('view-toggle-btn');
        const dropdown = document.getElementById('view-dropdown');

        if (toggleBtn && dropdown) {
          toggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            dropdown.classList.toggle('show');
          });

          // Option selection
          document.querySelectorAll('.view-option').forEach(option => {
            option.addEventListener('click', () => {
              const density = option.dataset.density;
              this.setDensity(density);
              dropdown.classList.remove('show');
              showToast(`Switched to ${density} view`, 'success');
            });
          });

          // Close on outside click
          document.addEventListener('click', () => {
            dropdown.classList.remove('show');
          });
        }
      },

      setDensity(density) {
        this.current = density;
        document.documentElement.setAttribute('data-density', density);
        localStorage.setItem('prometheos-density', density);

        // Update UI
        document.querySelectorAll('.view-option').forEach(option => {
          option.classList.toggle('selected', option.dataset.density === density);
        });
      }
    };

    // ========================================
    // SAVED FILTER PRESETS MANAGER
    // ========================================

    const PresetsManager = {
      presets: [],

      init() {
        // Load saved presets from localStorage
        const saved = localStorage.getItem('prometheos-filter-presets');
        this.presets = saved ? JSON.parse(saved) : [];

        this.render();
        this.bindEvents();
      },

      bindEvents() {
        const presetsBtn = document.getElementById('presets-btn');
        const presetsDropdown = document.getElementById('presets-dropdown');
        const presetNameInput = document.getElementById('preset-name-input');
        const savePresetBtn = document.getElementById('save-preset-btn');

        if (!presetsBtn || !presetsDropdown) return;

        // Toggle dropdown
        presetsBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          presetsDropdown.classList.toggle('show');
        });

        // Close on outside click
        document.addEventListener('click', (e) => {
          if (!presetsDropdown.contains(e.target)) {
            presetsDropdown.classList.remove('show');
          }
        });

        // Prevent dropdown from closing when clicking inside
        presetsDropdown.addEventListener('click', (e) => {
          e.stopPropagation();
        });

        // Enable/disable save button based on input
        if (presetNameInput && savePresetBtn) {
          presetNameInput.addEventListener('input', () => {
            const hasFilters = this.hasActiveFilters();
            const hasName = presetNameInput.value.trim().length > 0;
            savePresetBtn.disabled = !(hasFilters && hasName);
          });

          // Save preset on button click
          savePresetBtn.addEventListener('click', () => {
            this.saveCurrentFilters(presetNameInput.value.trim());
            presetNameInput.value = '';
            savePresetBtn.disabled = true;
          });

          // Save on Enter key
          presetNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !savePresetBtn.disabled) {
              this.saveCurrentFilters(presetNameInput.value.trim());
              presetNameInput.value = '';
              savePresetBtn.disabled = true;
            }
          });
        }
      },

      hasActiveFilters() {
        const location = document.getElementById('filter-location')?.value || '';
        const prom = document.getElementById('filter-prom')?.value || '';
        const time = document.getElementById('filter-time')?.value || '';
        const service = document.getElementById('filter-service')?.value || '';
        const search = document.getElementById('search-box')?.value || '';

        return location || prom || time || service || search;
      },

      getCurrentFilters() {
        return {
          location: document.getElementById('filter-location')?.value || '',
          prom: document.getElementById('filter-prom')?.value || '',
          time: document.getElementById('filter-time')?.value || '',
          service: document.getElementById('filter-service')?.value || '',
          search: document.getElementById('search-box')?.value || ''
        };
      },

      saveCurrentFilters(name) {
        if (!name || !this.hasActiveFilters()) return;

        const preset = {
          id: Date.now(),
          name: name,
          filters: this.getCurrentFilters(),
          createdAt: new Date().toISOString()
        };

        this.presets.unshift(preset);

        // Limit to 10 presets
        if (this.presets.length > 10) {
          this.presets = this.presets.slice(0, 10);
        }

        this.save();
        this.render();
        showToast(`Saved preset: ${name}`, 'success');
      },

      applyPreset(id) {
        const preset = this.presets.find(p => p.id === id);
        if (!preset) return;

        const filters = preset.filters;

        // Apply filter values
        if (document.getElementById('filter-location')) {
          document.getElementById('filter-location').value = filters.location || '';
        }
        if (document.getElementById('filter-prom')) {
          document.getElementById('filter-prom').value = filters.prom || '';
        }
        if (document.getElementById('filter-time')) {
          document.getElementById('filter-time').value = filters.time || '';
        }
        if (document.getElementById('filter-service')) {
          document.getElementById('filter-service').value = filters.service || '';
        }
        if (document.getElementById('search-box') && filters.search) {
          document.getElementById('search-box').value = filters.search;
        }

        // Apply the filters
        FilterManager.apply();

        // Close dropdown
        document.getElementById('presets-dropdown').classList.remove('show');

        showToast(`Applied preset: ${preset.name}`, 'success');
      },

      deletePreset(id) {
        this.presets = this.presets.filter(p => p.id !== id);
        this.save();
        this.render();
        showToast('Preset deleted', 'success');
      },

      save() {
        localStorage.setItem('prometheos-filter-presets', JSON.stringify(this.presets));
      },

      getFilterSummary(filters) {
        const parts = [];
        if (filters.location) parts.push(`Location: ${filters.location}`);
        if (filters.prom) parts.push(`Node: ${filters.prom}`);
        if (filters.time) parts.push(`Time: ${filters.time}`);
        if (filters.service) parts.push(`Service: ${filters.service}`);
        if (filters.search) parts.push(`Search: "${filters.search}"`);
        return parts.join(' | ') || 'No filters';
      },

      render() {
        const list = document.getElementById('presets-list');
        if (!list) return;

        if (this.presets.length === 0) {
          list.innerHTML = '<div class="presets-empty">No saved presets yet</div>';
          return;
        }

        list.innerHTML = this.presets.map(preset => `
          <div class="preset-item" data-id="${preset.id}">
            <div class="preset-info" onclick="PresetsManager.applyPreset(${preset.id})">
              <div class="preset-name">${this.escapeHtml(preset.name)}</div>
              <div class="preset-filters">${this.escapeHtml(this.getFilterSummary(preset.filters))}</div>
            </div>
            <div class="preset-actions">
              <button type="button" class="preset-action-btn delete" onclick="PresetsManager.deletePreset(${preset.id})" title="Delete preset">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <line x1="18" y1="6" x2="6" y2="18"></line>
                  <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
              </button>
            </div>
          </div>
        `).join('');
      },

      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
    };

    // ========================================
    // QUICK FILTERS (Priority-based filtering)
    // ========================================

    const QuickFilters = {
      activeFilter: null,
      cachedScores: null,

      // Calculate scores for all alerts (cached for efficiency)
      calculateAlertScores() {
        const now = new Date();
        const rows = Array.from(document.querySelectorAll('#alert-table tbody tr:not(.stale-section-row):not(.stale-alerts-row)'));

        return rows.map(row => {
          const timeStr = row.dataset.time;
          const hostname = row.dataset.hostname;
          const services = row.dataset.services || '';

          if (!timeStr) return null;

          const time = new Date(timeStr.replace(' ', 'T'));
          const duration = now - time;
          const ageHours = duration / (60 * 60 * 1000);
          const serviceCount = services.split(',').filter(s => s.trim()).length;

          // Check recurring (same hostname appears multiple times)
          const hostCount = rows.filter(r => r.dataset.hostname === hostname).length;
          const isRecurring = hostCount > 1;

          // Calculate priority score
          const score = Math.round((ageHours * 10) + (serviceCount * 5) + (isRecurring ? 20 : 0));

          return { row, hostname, time, duration, ageHours, serviceCount, isRecurring, score };
        }).filter(Boolean);
      },

      // Update badge counts for each quick filter
      updateBadges() {
        const scored = this.calculateAlertScores();
        const HOUR = 60 * 60 * 1000;
        const FOUR_HOURS = 4 * HOUR;

        // Priority Queue (score > 50)
        const highPriority = scored.filter(a => a.score > 50).length;
        const priorityBadge = document.getElementById('quick-filter-priority-badge');
        if (priorityBadge) priorityBadge.textContent = highPriority;

        // Critical (> 4 hours)
        const critical = scored.filter(a => a.duration > FOUR_HOURS).length;
        const criticalBadge = document.getElementById('quick-filter-critical-badge');
        if (criticalBadge) criticalBadge.textContent = critical;

        // Newest (< 1 hour)
        const newest = scored.filter(a => a.duration < HOUR).length;
        const newestBadge = document.getElementById('quick-filter-newest-badge');
        if (newestBadge) newestBadge.textContent = newest;

        // Recurring
        const recurring = scored.filter(a => a.isRecurring).length;
        const recurringBadge = document.getElementById('quick-filter-recurring-badge');
        if (recurringBadge) recurringBadge.textContent = recurring;

        this.cachedScores = scored;
      },

      apply(filterType) {
        const scored = this.cachedScores || this.calculateAlertScores();
        const HOUR = 60 * 60 * 1000;
        const FOUR_HOURS = 4 * HOUR;

        // First, clear any existing quick filter
        this.clear(false);

        // Determine which rows to show
        let matchingHostnames = [];
        let filterLabel = '';

        switch (filterType) {
          case 'highPriority':
            matchingHostnames = scored.filter(a => a.score > 50).map(a => a.hostname);
            filterLabel = 'Priority Queue';
            break;
          case 'critical':
            matchingHostnames = scored.filter(a => a.duration > FOUR_HOURS).map(a => a.hostname);
            filterLabel = 'Critical (>4h)';
            break;
          case 'newest':
            matchingHostnames = scored.filter(a => a.duration < HOUR).map(a => a.hostname);
            filterLabel = 'Newest (<1h)';
            break;
          case 'recurring':
            matchingHostnames = scored.filter(a => a.isRecurring).map(a => a.hostname);
            filterLabel = 'Recurring';
            break;
          default:
            return;
        }

        // Apply filter - show only matching rows
        const allRows = document.querySelectorAll('#alert-table tbody tr:not(.stale-section-row):not(.stale-alerts-row)');
        let visibleCount = 0;

        allRows.forEach(row => {
          const hostname = row.dataset.hostname;
          if (matchingHostnames.includes(hostname)) {
            row.classList.remove('quick-filtered-out');
            visibleCount++;
          } else {
            row.classList.add('quick-filtered-out');
          }
        });

        this.activeFilter = filterType;

        // Close the presets dropdown
        const dropdown = document.getElementById('presets-dropdown');
        if (dropdown) dropdown.classList.remove('show');

        // Update filter badge to show quick filter is active
        const filterBadge = document.getElementById('filter-badge');
        if (filterBadge) {
          const currentCount = parseInt(filterBadge.textContent) || 0;
          filterBadge.textContent = currentCount + 1;
          filterBadge.style.display = 'flex';
        }

        // Show clear button
        const clearBtn = document.getElementById('clear-all-btn');
        if (clearBtn) clearBtn.style.display = 'flex';

        showToast(`${filterLabel}: ${visibleCount} alerts`, 'success');

        // Update visible count
        updateVisibleCount();
      },

      clear(showMessage = true) {
        if (!this.activeFilter) return;

        // Remove quick filter class from all rows
        const allRows = document.querySelectorAll('#alert-table tbody tr.quick-filtered-out');
        allRows.forEach(row => row.classList.remove('quick-filtered-out'));

        this.activeFilter = null;

        if (showMessage) {
          showToast('Quick filter cleared', 'success');
          updateVisibleCount();
        }
      },

      isActive() {
        return this.activeFilter !== null;
      }
    };

    // ========================================
    // COLUMN MANAGER
    // ========================================

    const ColumnManager = {
      modal: null,
      columns: [],
      discoveredFields: { labels: [], annotations: [], core: [] },
      profiles: {
        default: ['checkbox', 'uid', 'account', 'hostname', 'datacenter', 'section', 'row', 'rack', 'location', 'prom', 'time', 'duration', 'services', 'actions'],
        compact: ['checkbox', 'hostname', 'account', 'services', 'time', 'actions'],
        detailed: ['checkbox', 'uid', 'account', 'hostname', 'datacenter', 'section', 'row', 'rack', 'location', 'prom', 'time', 'duration', 'services', 'actions'],
        custom: []
      },
      currentProfile: 'default',

      init() {
        this.modal = document.getElementById('column-config-modal');
        this.loadConfig();
        this.applyColumns();

        // Close modal on overlay click
        if (this.modal) {
          this.modal.addEventListener('click', (e) => {
            if (e.target === this.modal) this.close();
          });
        }

        // Keyboard shortcut
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && this.modal?.classList.contains('show')) {
            this.close();
          }
        });
      },

      loadConfig() {
        const saved = localStorage.getItem('prometheos_column_config');
        if (saved) {
          try {
            const config = JSON.parse(saved);
            this.columns = config.columns || this.profiles.default;
            this.currentProfile = config.profile || 'default';
            this.profiles.custom = config.customProfile || [];
            this.discoveredFields = config.discoveredFields || { labels: [], annotations: [], core: [] };
          } catch (e) {
            this.columns = [...this.profiles.default];
          }
        } else {
          this.columns = [...this.profiles.default];
        }
      },

      saveConfig() {
        localStorage.setItem('prometheos_column_config', JSON.stringify({
          columns: this.columns,
          profile: this.currentProfile,
          customProfile: this.profiles.custom,
          discoveredFields: this.discoveredFields
        }));
      },

      open() {
        if (!this.modal) return;
        this.renderVisibleColumns();
        this.renderApiFields();
        this.updatePreview();
        this.updateProfileButtons();
        this.modal.classList.add('show');
      },

      close() {
        if (this.modal) {
          this.modal.classList.remove('show');
        }
      },

      applyAndClose() {
        this.applyColumns();
        this.saveConfig();
        this.close();
      },

      renderVisibleColumns() {
        const list = document.getElementById('visible-columns-list');
        const countBadge = document.getElementById('visible-columns-count');
        if (!list) return;

        const allColumns = this.getAllColumnDefinitions();

        list.innerHTML = this.columns
          .filter(colId => colId !== 'checkbox' && colId !== 'actions')
          .map((colId, index) => {
            const col = allColumns.find(c => c.id === colId) || { id: colId, name: colId, source: 'custom' };
            return `
              <div class="column-item selected" data-column-id="${col.id}" draggable="true">
                <input type="checkbox" class="column-checkbox" checked onchange="ColumnManager.toggleColumn('${col.id}')">
                <div class="column-info">
                  <div class="column-name">${this.escapeHtml(col.name)}</div>
                  <div class="column-source">${col.source}</div>
                </div>
                <div class="column-drag-handle">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="8" y1="6" x2="16" y2="6"></line>
                    <line x1="8" y1="12" x2="16" y2="12"></line>
                    <line x1="8" y1="18" x2="16" y2="18"></line>
                  </svg>
                </div>
              </div>
            `;
          }).join('');

        // Add available but not visible columns
        const availableCols = allColumns.filter(col =>
          !this.columns.includes(col.id) && col.id !== 'checkbox' && col.id !== 'actions'
        );

        if (availableCols.length > 0) {
          list.innerHTML += availableCols.map(col => `
            <div class="column-item" data-column-id="${col.id}">
              <input type="checkbox" class="column-checkbox" onchange="ColumnManager.toggleColumn('${col.id}')">
              <div class="column-info">
                <div class="column-name">${this.escapeHtml(col.name)}</div>
                <div class="column-source">${col.source}</div>
              </div>
              <div class="column-drag-handle">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <line x1="8" y1="6" x2="16" y2="6"></line>
                  <line x1="8" y1="12" x2="16" y2="12"></line>
                  <line x1="8" y1="18" x2="16" y2="18"></line>
                </svg>
              </div>
            </div>
          `).join('');
        }

        if (countBadge) {
          countBadge.textContent = `${this.columns.length - 2} columns`; // -2 for checkbox and actions
        }

        this.initDragDrop();
      },

      getAllColumnDefinitions() {
        const defaultCols = [
          { id: 'uid', name: 'UID', source: 'core' },
          { id: 'account', name: 'Account', source: 'core' },
          { id: 'hostname', name: 'Hostname', source: 'core' },
          { id: 'datacenter', name: 'DC', source: 'core' },
          { id: 'section', name: 'Section', source: 'core' },
          { id: 'row', name: 'Row', source: 'core' },
          { id: 'rack', name: 'Rack', source: 'core' },
          { id: 'location', name: 'Location', source: 'core' },
          { id: 'prom', name: 'Prom Node', source: 'core' },
          { id: 'time', name: 'Start Time', source: 'core' },
          { id: 'duration', name: 'Duration', source: 'core' },
          { id: 'services', name: 'Services', source: 'core' }
        ];

        // Add discovered fields
        const labelCols = this.discoveredFields.labels.map(f => ({
          id: `label_${f.name}`, name: f.name, source: 'label'
        }));
        const annotationCols = this.discoveredFields.annotations.map(f => ({
          id: `annotation_${f.name}`, name: f.name, source: 'annotation'
        }));

        return [...defaultCols, ...labelCols, ...annotationCols];
      },

      toggleColumn(colId) {
        const idx = this.columns.indexOf(colId);
        if (idx > -1) {
          this.columns.splice(idx, 1);
        } else {
          // Insert before 'actions'
          const actionsIdx = this.columns.indexOf('actions');
          if (actionsIdx > -1) {
            this.columns.splice(actionsIdx, 0, colId);
          } else {
            this.columns.push(colId);
          }
        }
        this.currentProfile = 'custom';
        this.profiles.custom = [...this.columns];
        this.renderVisibleColumns();
        this.updatePreview();
        this.updateProfileButtons();
      },

      initDragDrop() {
        const list = document.getElementById('visible-columns-list');
        if (!list) return;

        const items = list.querySelectorAll('.column-item[draggable="true"]');
        items.forEach(item => {
          item.addEventListener('dragstart', (e) => {
            item.classList.add('dragging');
            e.dataTransfer.setData('text/plain', item.dataset.columnId);
          });
          item.addEventListener('dragend', () => {
            item.classList.remove('dragging');
          });
          item.addEventListener('dragover', (e) => {
            e.preventDefault();
            const dragging = list.querySelector('.dragging');
            if (dragging && item !== dragging) {
              const rect = item.getBoundingClientRect();
              const midY = rect.top + rect.height / 2;
              if (e.clientY < midY) {
                item.parentNode.insertBefore(dragging, item);
              } else {
                item.parentNode.insertBefore(dragging, item.nextSibling);
              }
            }
          });
          item.addEventListener('drop', () => {
            this.updateColumnOrder();
          });
        });
      },

      updateColumnOrder() {
        const list = document.getElementById('visible-columns-list');
        if (!list) return;

        const newOrder = ['checkbox'];
        list.querySelectorAll('.column-item.selected').forEach(item => {
          newOrder.push(item.dataset.columnId);
        });
        newOrder.push('actions');

        this.columns = newOrder;
        this.currentProfile = 'custom';
        this.profiles.custom = [...this.columns];
        this.updatePreview();
        this.updateProfileButtons();
      },

      renderApiFields() {
        // Update field grids
        ['labels', 'annotations', 'core'].forEach(type => {
          const grid = document.getElementById(`${type === 'labels' ? 'label' : type === 'annotations' ? 'annotation' : type}-fields-grid`);
          const count = document.getElementById(`${type === 'labels' ? 'label' : type === 'annotations' ? 'annotation' : type}-fields-count`);

          if (!grid) return;

          const fields = type === 'core' ? this.getCoreFields() : this.discoveredFields[type];

          if (count) count.textContent = fields.length;

          if (fields.length === 0) {
            grid.innerHTML = '<div class="api-fields-empty">Click "Discover Fields" to scan for available fields</div>';
            return;
          }

          grid.innerHTML = fields.map(field => {
            const colId = type === 'core' ? field.id : `${type === 'labels' ? 'label' : 'annotation'}_${field.name}`;
            const isAdded = this.columns.includes(colId);
            return `
              <div class="api-field-card ${isAdded ? 'added' : ''}" data-field-id="${colId}">
                <div class="api-field-header">
                  <span class="api-field-name">${this.escapeHtml(field.name)}</span>
                  <span class="api-field-type ${type === 'labels' ? 'label' : type === 'annotations' ? 'annotation' : 'core'}">${type === 'labels' ? 'Label' : type === 'annotations' ? 'Ann.' : 'Core'}</span>
                </div>
                ${field.sample ? `<div class="api-field-sample" title="${this.escapeHtml(field.sample)}">${this.escapeHtml(field.sample.substring(0, 40))}${field.sample.length > 40 ? '...' : ''}</div>` : ''}
                <div class="api-field-actions">
                  <button type="button" class="btn-add-column" ${isAdded ? 'disabled' : ''} onclick="ColumnManager.addFieldAsColumn('${colId}', '${this.escapeHtml(field.name)}', '${type}')">
                    ${isAdded ? 'Added' : 'Add Column'}
                  </button>
                </div>
              </div>
            `;
          }).join('');
        });
      },

      getCoreFields() {
        return [
          { id: 'uid', name: 'UID', sample: 'ABC123' },
          { id: 'account', name: 'Account', sample: 'Production' },
          { id: 'hostname', name: 'Hostname', sample: 'web-server-01' },
          { id: 'datacenter', name: 'DC', sample: 'B3' },
          { id: 'section', name: 'Section', sample: 'S2' },
          { id: 'row', name: 'Row', sample: 'R9' },
          { id: 'rack', name: 'Rack', sample: 'K8' },
          { id: 'location', name: 'Location', sample: 'B3-S2-R9-K8' },
          { id: 'prom', name: 'Prom Node', sample: 'prometheus-1' },
          { id: 'time', name: 'Start Time', sample: '2024-01-15 10:30' },
          { id: 'duration', name: 'Duration', sample: '2h 15m' },
          { id: 'services', name: 'Services', sample: 'nginx, php-fpm' }
        ];
      },

      async discoverFields() {
        const statusDot = document.getElementById('api-status-dot');
        const statusText = document.getElementById('api-status-text');
        const endpointInput = document.getElementById('api-endpoint');

        if (statusDot) statusDot.classList.add('loading');
        if (statusText) statusText.textContent = 'Scanning...';

        try {
          // Discover fields from current table data
          const labels = new Map();
          const annotations = new Map();

          // Scan table rows for data attributes
          document.querySelectorAll('.alert-row').forEach(row => {
            // Get all data attributes
            Object.keys(row.dataset).forEach(key => {
              const value = row.dataset[key];
              if (value && key !== 'uid') {
                if (!labels.has(key)) {
                  labels.set(key, { name: key, sample: value, count: 1 });
                } else {
                  labels.get(key).count++;
                }
              }
            });
          });

          // Check for additional fields in cells
          document.querySelectorAll('.alert-row td[data-field]').forEach(cell => {
            const field = cell.dataset.field;
            const value = cell.textContent.trim();
            if (field && value) {
              if (!labels.has(field)) {
                labels.set(field, { name: field, sample: value, count: 1 });
              }
            }
          });

          // Simulated additional AlertManager fields that might be available
          const commonLabels = [
            { name: 'alertname', sample: 'HighCPUUsage' },
            { name: 'severity', sample: 'critical' },
            { name: 'instance', sample: '10.0.0.1:9090' },
            { name: 'job', sample: 'node_exporter' },
            { name: 'env', sample: 'production' },
            { name: 'team', sample: 'infrastructure' },
            { name: 'datacenter', sample: 'dc1' }
          ];

          const commonAnnotations = [
            { name: 'summary', sample: 'High CPU usage detected' },
            { name: 'description', sample: 'CPU usage is above 80% for 5 minutes' },
            { name: 'runbook_url', sample: 'https://runbooks.example.com/high-cpu' },
            { name: 'dashboard_url', sample: 'https://grafana.example.com/d/xyz' }
          ];

          // Merge discovered with common
          commonLabels.forEach(l => {
            if (!labels.has(l.name)) {
              labels.set(l.name, l);
            }
          });

          this.discoveredFields.labels = Array.from(labels.values());
          this.discoveredFields.annotations = commonAnnotations;
          this.discoveredFields.core = this.getCoreFields();

          if (statusDot) statusDot.classList.remove('loading');
          if (statusText) statusText.textContent = `Found ${this.discoveredFields.labels.length + this.discoveredFields.annotations.length} fields`;
          if (endpointInput) endpointInput.value = window.location.origin + '/api/v1/alerts';

          this.saveConfig();
          this.renderApiFields();

        } catch (error) {
          if (statusDot) {
            statusDot.classList.remove('loading');
            statusDot.classList.add('error');
          }
          if (statusText) statusText.textContent = 'Error scanning fields';
          console.error('Field discovery error:', error);
        }
      },

      addFieldAsColumn(colId, fieldName, type) {
        if (this.columns.includes(colId)) return;

        // Add to discovered fields if not present
        if (type === 'labels' && !this.discoveredFields.labels.find(f => f.name === fieldName)) {
          this.discoveredFields.labels.push({ name: fieldName, sample: '' });
        } else if (type === 'annotations' && !this.discoveredFields.annotations.find(f => f.name === fieldName)) {
          this.discoveredFields.annotations.push({ name: fieldName, sample: '' });
        }

        // Insert before 'actions'
        const actionsIdx = this.columns.indexOf('actions');
        if (actionsIdx > -1) {
          this.columns.splice(actionsIdx, 0, colId);
        } else {
          this.columns.push(colId);
        }

        this.currentProfile = 'custom';
        this.profiles.custom = [...this.columns];
        this.renderVisibleColumns();
        this.renderApiFields();
        this.updatePreview();
        this.updateProfileButtons();
      },

      applyProfile(profileName) {
        if (this.profiles[profileName]) {
          this.columns = [...this.profiles[profileName]];
          if (this.columns.length === 0) {
            this.columns = [...this.profiles.default];
          }
        }
        this.currentProfile = profileName;
        this.renderVisibleColumns();
        this.updatePreview();
        this.updateProfileButtons();
      },

      updateProfileButtons() {
        document.querySelectorAll('.profile-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.profile === this.currentProfile);
        });
      },

      updatePreview() {
        const headerRow = document.getElementById('preview-header-row');
        const sampleRow = document.getElementById('preview-sample-row');
        if (!headerRow || !sampleRow) return;

        const allCols = this.getAllColumnDefinitions();
        const visibleCols = this.columns.filter(id => id !== 'checkbox' && id !== 'actions');

        headerRow.innerHTML = visibleCols.map(colId => {
          const col = allCols.find(c => c.id === colId) || { name: colId };
          return `<th>${this.escapeHtml(col.name)}</th>`;
        }).join('');

        // Generate sample data
        const firstRow = document.querySelector('.alert-row');
        sampleRow.innerHTML = visibleCols.map(colId => {
          let value = '—';
          if (firstRow) {
            if (colId === 'uid') value = firstRow.querySelector('.uid-badge')?.textContent || '—';
            else if (colId === 'account') value = firstRow.querySelector('.cell-primary')?.textContent || '—';
            else if (colId === 'hostname') value = firstRow.querySelector('.hostname')?.textContent?.trim() || '—';
            else if (colId === 'time') value = firstRow.querySelector('.time-badge')?.textContent || '—';
            else if (colId === 'services') value = firstRow.querySelector('.service-tags')?.textContent?.trim().substring(0, 20) || '—';
            else if (firstRow.dataset[colId]) value = firstRow.dataset[colId];
            else if (colId.startsWith('label_')) value = firstRow.dataset[colId.replace('label_', '')] || '—';
          }
          return `<td>${this.escapeHtml(value)}</td>`;
        }).join('');
      },

      applyColumns() {
        const tables = ['active-table', 'silenced-table'];
        const allCols = this.getAllColumnDefinitions();

        tables.forEach(tableId => {
          const table = document.getElementById(tableId);
          if (!table) return;

          // Update header visibility
          const headers = table.querySelectorAll('thead th');
          headers.forEach((th, index) => {
            const colId = this.getColumnIdByIndex(index);
            if (colId) {
              th.style.display = this.columns.includes(colId) ? '' : 'none';
            }
          });

          // Update cell visibility
          table.querySelectorAll('tbody tr').forEach(row => {
            row.querySelectorAll('td').forEach((td, index) => {
              const colId = this.getColumnIdByIndex(index);
              if (colId) {
                td.style.display = this.columns.includes(colId) ? '' : 'none';
              }
            });
          });
        });
      },

      getColumnIdByIndex(index) {
        const mapping = ['checkbox', 'uid', 'account', 'hostname', 'datacenter', 'section', 'row', 'rack', 'prom', 'time', 'duration', 'services', 'actions'];
        return mapping[index] || null;
      },

      resetToDefault() {
        this.columns = [...this.profiles.default];
        this.currentProfile = 'default';
        this.renderVisibleColumns();
        this.updatePreview();
        this.updateProfileButtons();
      },

      escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
    };

    // ========================================
    // INITIALIZATION
    // ========================================

    document.addEventListener('DOMContentLoaded', function() {
      ThemeManager.init();
      RefreshManager.init();
      ShortcutsModal.init();
      FilterManager.init();
      ExportManager.init();
      DensityManager.init();
      PresetsManager.init();
      SectionManager.init();
      TimeRangeManager.init();
      IncidentManager.init();
      ColumnManager.init();
      HelpModal.init();
      AlertDrawer.init();
      BulkActions.init();
      NewAlertsIndicator.init();
      URLState.init();
      AlertManagersModal.init();
      ViewPresets.init();
      InsightCards.init();
      PriorityQueueManager.init();

      // Initialize simplified prom display names
      initPromDisplayNames();

      // Initialize location display columns (DC, Section, Row, Rack)
      initLocationDisplayCells();

      // Close status dropdowns on outside click
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.status-selector')) {
          document.querySelectorAll('.status-dropdown.show').forEach(d => d.classList.remove('show'));
        }
      });

      // Close Alert Managers modal on overlay click
      document.getElementById('alert-managers-modal')?.addEventListener('click', (e) => {
        if (e.target.classList.contains('modal-overlay')) {
          AlertManagersModal.close();
        }
      });

      // Close metric modals on overlay click
      ['avg-duration-modal', 'oldest-alert-modal', 'velocity-modal', 'recurring-modal', 'health-score-modal'].forEach(modalId => {
        document.getElementById(modalId)?.addEventListener('click', (e) => {
          if (e.target.classList.contains('modal-overlay')) {
            const modalName = modalId.replace('-modal', '');
            MetricModals.close(modalName);
          }
        });
      });

      // Close modals on Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          const amModal = document.getElementById('alert-managers-modal');
          if (amModal?.classList.contains('show')) {
            AlertManagersModal.close();
          }
        }
      });

      updateCounts();

      // Calculate and display alert durations
      updateDurations();

      // Apply default sort by duration (most recent/new alerts first)
      applyDefaultSort();

      // Initialize stale alerts manager (after sort so stale alerts appear at bottom)
      StaleAlertsManager.init();

      // Update durations every minute
      setInterval(updateDurations, 60000);
    });

    // Apply default sort: duration ascending (newest/shortest first)
    function applyDefaultSort() {
      // Sort both tables by duration column (index 11)
      ['active-table', 'silenced-table'].forEach(tableId => {
        const table = document.getElementById(tableId);
        if (!table) return;

        const tbody = table.querySelector('tbody');
        const rows = Array.from(tbody.querySelectorAll('tr'));

        if (rows.length === 0) return;

        // Set initial sort state to ascending
        sortStates[`${tableId}-11`] = 'asc';

        rows.sort((a, b) => {
          const aVal = a.cells[11]?.textContent.trim().toLowerCase() || '';
          const bVal = b.cells[11]?.textContent.trim().toLowerCase() || '';

          // NEW alerts come first
          const aIsNew = aVal === 'new' || aVal === '--';
          const bIsNew = bVal === 'new' || bVal === '--';

          if (aIsNew && bIsNew) return 0;
          if (aIsNew) return -1;
          if (bIsNew) return 1;

          // Sort by duration in seconds (shortest/newest first)
          const aSeconds = parseDurationToSeconds(aVal);
          const bSeconds = parseDurationToSeconds(bVal);
          return aSeconds - bSeconds;
        });

        rows.forEach(row => tbody.appendChild(row));

        // Update header indicator
        const th = table.querySelectorAll('th')[11];
        if (th) {
          table.querySelectorAll('th').forEach(header => header.classList.remove('asc', 'desc'));
          th.classList.add('asc');
        }
      });
    }

    // Apply a saved sort configuration
    function applySavedSort(columnIndex, direction) {
      ['active-table', 'silenced-table'].forEach(tableId => {
        const table = document.getElementById(tableId);
        if (!table) return;

        const tbody = table.querySelector('tbody');
        const rows = Array.from(tbody.querySelectorAll('tr'));

        if (rows.length === 0) return;

        // Set sort state
        sortStates[`${tableId}-${columnIndex}`] = direction;

        rows.sort((a, b) => {
          const aVal = a.cells[columnIndex]?.textContent.trim().toLowerCase() || '';
          const bVal = b.cells[columnIndex]?.textContent.trim().toLowerCase() || '';

          // Handle duration column (index 11)
          if (columnIndex === 11) {
            const aIsNew = aVal === 'new' || aVal === '--';
            const bIsNew = bVal === 'new' || bVal === '--';

            if (aIsNew && bIsNew) return 0;
            if (aIsNew) return direction === 'asc' ? -1 : 1;
            if (bIsNew) return direction === 'asc' ? 1 : -1;

            const aSeconds = parseDurationToSeconds(aVal);
            const bSeconds = parseDurationToSeconds(bVal);
            return direction === 'asc' ? aSeconds - bSeconds : bSeconds - aSeconds;
          }

          // Handle time column (index 10)
          const datePattern = /^\d{4}-\d{2}-\d{2}/;
          if (datePattern.test(aVal) && datePattern.test(bVal)) {
            const aDate = new Date(aVal.replace(' ', 'T'));
            const bDate = new Date(bVal.replace(' ', 'T'));
            return direction === 'asc' ? aDate - bDate : bDate - aDate;
          }

          // Default string comparison
          if (aVal < bVal) return direction === 'asc' ? -1 : 1;
          if (aVal > bVal) return direction === 'asc' ? 1 : -1;
          return 0;
        });

        rows.forEach(row => tbody.appendChild(row));

        // Update header indicator
        const th = table.querySelectorAll('th')[columnIndex];
        if (th) {
          table.querySelectorAll('th').forEach(header => header.classList.remove('asc', 'desc'));
          th.classList.add(direction);
        }
      });
    }
  </script>
</body>
</html>
{{ end }}
