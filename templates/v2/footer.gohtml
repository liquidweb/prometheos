{{ define "foot" }}
  <style>
    /* ========================================
       DATA TABLE STYLES
       ======================================== */

    .tab-panel {
      animation: fadeIn 0.2s ease;
    }

    .table-container {
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-lg);
      overflow: hidden;
    }

    .data-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    .data-table thead {
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border-default);
    }

    .data-table th {
      padding: 14px 16px;
      text-align: left;
      font-weight: 600;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-secondary);
      white-space: nowrap;
      user-select: none;
    }

    .data-table th.sortable {
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .data-table th.sortable:hover {
      color: var(--text-primary);
      background: var(--bg-elevated);
    }

    .data-table th.sortable span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .sort-icon {
      opacity: 0.4;
      font-size: 12px;
      transition: opacity 0.15s ease;
    }

    .data-table th.sortable:hover .sort-icon,
    .data-table th.sortable.asc .sort-icon,
    .data-table th.sortable.desc .sort-icon {
      opacity: 1;
    }

    .data-table th.sortable.asc .sort-icon::after { content: ' ↑'; }
    .data-table th.sortable.desc .sort-icon::after { content: ' ↓'; }

    .data-table tbody tr {
      border-bottom: 1px solid var(--border-subtle);
      transition: background 0.1s ease;
    }

    .data-table tbody tr:last-child {
      border-bottom: none;
    }

    .data-table tbody tr:hover {
      background: var(--bg-tertiary);
    }

    .data-table tbody tr.selected {
      background: var(--accent-bg);
    }

    .data-table tbody tr.filtered-out {
      display: none;
    }

    .data-table td {
      padding: 14px 16px;
      vertical-align: middle;
    }

    /* Checkbox column */
    .col-checkbox {
      width: 40px;
      text-align: center;
    }

    .cell-checkbox {
      text-align: center;
    }

    .row-checkbox,
    .row-checkbox-header {
      width: 16px;
      height: 16px;
      cursor: pointer;
      accent-color: var(--accent);
    }

    /* Cell types */
    .cell-mono {
      font-family: var(--font-mono);
      font-size: 12px;
    }

    .cell-text {
      color: var(--text-primary);
    }

    .cell-muted {
      color: var(--text-muted);
    }

    .cell-primary {
      font-weight: 500;
    }

    /* UID Badge */
    .uid-badge {
      display: inline-block;
      padding: 4px 8px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-default);
      border-radius: var(--radius-sm);
      font-size: 11px;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .uid-badge.silenced {
      background: var(--silenced-bg);
      border-color: var(--silenced);
      color: var(--silenced);
    }

    /* Hostname with status dot */
    .hostname {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .status-dot.critical {
      background: var(--critical);
      box-shadow: 0 0 8px var(--critical);
      animation: pulse-critical 2s ease-in-out infinite;
    }

    .status-dot.silenced {
      background: var(--silenced);
    }

    @keyframes pulse-critical {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Time badge */
    .time-badge {
      display: inline-block;
      padding: 4px 8px;
      background: var(--bg-tertiary);
      border-radius: var(--radius-sm);
      font-size: 12px;
      color: var(--text-secondary);
    }

    /* Service tags */
    .cell-services {
      max-width: 300px;
    }

    .service-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .service-tag {
      display: inline-block;
      padding: 4px 10px;
      background: var(--critical-bg);
      border: 1px solid rgba(255, 107, 107, 0.3);
      border-radius: 20px;
      font-size: 11px;
      font-weight: 500;
      color: var(--critical);
    }

    .service-tag.silenced {
      background: var(--silenced-bg);
      border-color: rgba(139, 92, 246, 0.3);
      color: var(--silenced);
    }

    /* Actions column */
    .col-actions {
      width: 120px;
      text-align: right !important;
    }

    .cell-actions {
      text-align: right;
    }

    .action-form {
      display: inline;
    }

    .btn-action {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      font-family: var(--font-sans);
      font-size: 12px;
      font-weight: 500;
      border: 1px solid transparent;
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .btn-silence {
      background: var(--silenced-bg);
      border-color: rgba(139, 92, 246, 0.3);
      color: var(--silenced);
    }

    .btn-silence:hover {
      background: var(--silenced);
      color: white;
      transform: translateY(-1px);
    }

    .btn-unsilence {
      background: var(--healthy-bg);
      border-color: rgba(74, 222, 128, 0.3);
      color: var(--healthy);
    }

    .btn-unsilence:hover {
      background: var(--healthy);
      color: var(--bg-primary);
      transform: translateY(-1px);
    }

    /* Silenced row styling */
    .silenced-row {
      opacity: 0.7;
    }

    .silenced-row:hover {
      opacity: 1;
    }

    /* Empty state */
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-lg);
    }

    .empty-icon {
      margin-bottom: 16px;
      color: var(--text-muted);
    }

    .empty-state h3 {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--text-primary);
    }

    .empty-state p {
      color: var(--text-muted);
      font-size: 14px;
    }

    /* ========================================
       SKIP LINK FOR ACCESSIBILITY
       ======================================== */

    .skip-link {
      position: absolute;
      top: -100%;
      left: 16px;
      padding: 8px 16px;
      background: var(--accent);
      color: white;
      border-radius: var(--radius-md);
      z-index: 1000;
      transition: top 0.2s ease;
      text-decoration: none;
    }

    .skip-link:focus {
      top: 16px;
    }

    /* ========================================
       TOAST NOTIFICATIONS
       ======================================== */

    .toast-container {
      position: fixed;
      bottom: 24px;
      right: 24px;
      z-index: 1100;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .toast {
      padding: 12px 20px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-default);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-lg);
      font-size: 13px;
      color: var(--text-primary);
      animation: slideInRight 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .toast.success {
      border-color: var(--healthy);
    }

    .toast.error {
      border-color: var(--critical);
    }

    @keyframes slideInRight {
      from { opacity: 0; transform: translateX(20px); }
      to { opacity: 1; transform: translateX(0); }
    }

    /* ========================================
       RESPONSIVE DESIGN
       ======================================== */

    @media (max-width: 1200px) {
      .status-grid {
        grid-template-columns: repeat(2, 1fr);
      }

      .widgets-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 768px) {
      .dashboard-header {
        padding: 0 16px;
      }

      .header-meta {
        gap: 8px;
      }

      .last-update {
        display: none;
      }

      .status-overview {
        padding: 16px;
      }

      .status-grid {
        grid-template-columns: 1fr;
      }

      .controls-bar {
        flex-direction: column;
        align-items: stretch;
      }

      .search-form {
        min-width: 100%;
      }

      .filter-controls {
        justify-content: space-between;
      }

      .search-hint {
        display: none;
      }

      .main-content {
        padding: 0 16px 16px;
      }

      .table-container {
        overflow-x: auto;
      }

      .data-table {
        min-width: 900px;
      }

      .filters-grid {
        grid-template-columns: 1fr;
      }
    }

    /* ========================================
       KEYBOARD FOCUS STYLES
       ======================================== */

    .search-input:focus,
    .btn:focus,
    .btn-action:focus,
    .tab-btn:focus,
    .header-btn:focus,
    .filter-select:focus {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }
  </style>

  <!-- Toast Container -->
  <div class="toast-container" id="toast-container"></div>

  <script>
    // ========================================
    // THEME MANAGEMENT
    // ========================================

    const ThemeManager = {
      init() {
        const savedTheme = localStorage.getItem('prometheos-theme') || 'dark';
        this.setTheme(savedTheme);

        document.getElementById('theme-toggle').addEventListener('click', () => {
          const currentTheme = document.documentElement.getAttribute('data-theme');
          const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
          this.setTheme(newTheme);
          showToast(`Switched to ${newTheme} mode`, 'success');
        });
      },

      setTheme(theme) {
        document.documentElement.setAttribute('data-theme', theme);
        localStorage.setItem('prometheos-theme', theme);
      },

      toggle() {
        const currentTheme = document.documentElement.getAttribute('data-theme');
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
        this.setTheme(newTheme);
      }
    };

    // ========================================
    // AUTO-REFRESH MANAGEMENT
    // ========================================

    const RefreshManager = {
      interval: null,
      currentInterval: 60,

      init() {
        const savedInterval = localStorage.getItem('prometheos-refresh-interval');
        if (savedInterval !== null) {
          this.currentInterval = parseInt(savedInterval);
        }
        this.updateUI();
        this.startRefresh();

        // Dropdown toggle
        const refreshBtn = document.getElementById('refresh-btn');
        const dropdown = document.getElementById('refresh-dropdown');

        refreshBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          dropdown.classList.toggle('show');
        });

        // Option selection
        document.querySelectorAll('.refresh-option').forEach(option => {
          option.addEventListener('click', () => {
            const interval = parseInt(option.dataset.interval);
            this.setInterval(interval);
            dropdown.classList.remove('show');
          });
        });

        // Close dropdown on outside click
        document.addEventListener('click', () => {
          dropdown.classList.remove('show');
        });
      },

      setInterval(seconds) {
        this.currentInterval = seconds;
        localStorage.setItem('prometheos-refresh-interval', seconds);
        this.updateUI();
        this.startRefresh();

        if (seconds === 0) {
          showToast('Auto-refresh disabled', 'success');
        } else {
          showToast(`Auto-refresh set to ${seconds < 60 ? seconds + ' seconds' : (seconds / 60) + ' minute(s)'}`, 'success');
        }
      },

      updateUI() {
        const refreshBtn = document.getElementById('refresh-btn');
        document.querySelectorAll('.refresh-option').forEach(option => {
          const interval = parseInt(option.dataset.interval);
          option.classList.toggle('selected', interval === this.currentInterval);
        });

        if (this.currentInterval > 0) {
          refreshBtn.classList.add('active');
        } else {
          refreshBtn.classList.remove('active');
        }
      },

      startRefresh() {
        if (this.interval) {
          clearInterval(this.interval);
        }

        if (this.currentInterval > 0) {
          this.interval = setInterval(() => {
            this.refresh();
          }, this.currentInterval * 1000);
        }
      },

      refresh() {
        const indicator = document.getElementById('update-indicator');
        indicator.classList.add('refreshing');

        // Reload the page to get fresh data
        setTimeout(() => {
          window.location.reload();
        }, 500);
      }
    };

    // ========================================
    // SHORTCUTS MODAL
    // ========================================

    const ShortcutsModal = {
      init() {
        const modal = document.getElementById('shortcuts-modal');
        const openBtn = document.getElementById('shortcuts-btn');
        const closeBtn = document.getElementById('modal-close');

        openBtn.addEventListener('click', () => this.open());
        closeBtn.addEventListener('click', () => this.close());

        modal.addEventListener('click', (e) => {
          if (e.target === modal) this.close();
        });
      },

      open() {
        document.getElementById('shortcuts-modal').classList.add('show');
      },

      close() {
        document.getElementById('shortcuts-modal').classList.remove('show');
      },

      toggle() {
        const modal = document.getElementById('shortcuts-modal');
        modal.classList.toggle('show');
      }
    };

    // ========================================
    // TAB SWITCHING
    // ========================================

    function openAlerts(evt, alertType) {
      const panels = document.querySelectorAll('.tab-panel');
      panels.forEach(panel => {
        panel.style.display = 'none';
      });

      const tabs = document.querySelectorAll('.tab-btn');
      tabs.forEach(tab => {
        tab.classList.remove('active');
      });

      document.getElementById(alertType).style.display = 'block';
      evt.currentTarget.classList.add('active');
    }

    // ========================================
    // TABLE SORTING
    // ========================================

    const sortStates = {};

    function sortTable(tableId, columnIndex) {
      const table = document.getElementById(tableId);
      const tbody = table.querySelector('tbody');
      const rows = Array.from(tbody.querySelectorAll('tr:not(.filtered-out)'));
      const th = table.querySelectorAll('th')[columnIndex];

      const stateKey = `${tableId}-${columnIndex}`;
      if (!sortStates[stateKey]) {
        sortStates[stateKey] = 'asc';
      } else {
        sortStates[stateKey] = sortStates[stateKey] === 'asc' ? 'desc' : 'asc';
      }

      const direction = sortStates[stateKey];

      table.querySelectorAll('th').forEach(header => {
        header.classList.remove('asc', 'desc');
      });
      th.classList.add(direction);

      rows.sort((a, b) => {
        const aVal = a.cells[columnIndex].textContent.trim().toLowerCase();
        const bVal = b.cells[columnIndex].textContent.trim().toLowerCase();

        const datePattern = /^\d{4}-\d{2}-\d{2}/;
        if (datePattern.test(aVal) && datePattern.test(bVal)) {
          const aDate = new Date(aVal.replace(' ', 'T'));
          const bDate = new Date(bVal.replace(' ', 'T'));
          return direction === 'asc' ? aDate - bDate : bDate - aDate;
        }

        if (aVal < bVal) return direction === 'asc' ? -1 : 1;
        if (aVal > bVal) return direction === 'asc' ? 1 : -1;
        return 0;
      });

      rows.forEach(row => tbody.appendChild(row));
    }

    // ========================================
    // FILTERING
    // ========================================

    const FilterManager = {
      filters: {
        location: '',
        prom: '',
        time: '',
        service: ''
      },

      init() {
        this.populateFilterOptions();

        document.getElementById('filter-toggle').addEventListener('click', () => {
          this.togglePanel();
        });
      },

      togglePanel() {
        const panel = document.getElementById('filters-panel');
        panel.classList.toggle('show');
      },

      populateFilterOptions() {
        const rows = document.querySelectorAll('#active-table tbody tr, #silenced-table tbody tr');
        const locations = new Set();
        const proms = new Set();
        const services = new Set();

        rows.forEach(row => {
          if (row.dataset.location) locations.add(row.dataset.location);
          if (row.dataset.prom) proms.add(row.dataset.prom);
          if (row.dataset.services) {
            row.dataset.services.split(',').forEach(s => {
              if (s.trim()) services.add(s.trim());
            });
          }
        });

        this.populateSelect('filter-location', Array.from(locations).sort());
        this.populateSelect('filter-prom', Array.from(proms).sort());
        this.populateSelect('filter-service', Array.from(services).sort());
      },

      populateSelect(selectId, options) {
        const select = document.getElementById(selectId);
        const currentValue = select.value;

        // Keep the first "All" option
        while (select.options.length > 1) {
          select.remove(1);
        }

        options.forEach(opt => {
          const option = document.createElement('option');
          option.value = opt;
          option.textContent = opt;
          select.appendChild(option);
        });

        select.value = currentValue;
      },

      apply() {
        this.filters.location = document.getElementById('filter-location').value;
        this.filters.prom = document.getElementById('filter-prom').value;
        this.filters.time = document.getElementById('filter-time').value;
        this.filters.service = document.getElementById('filter-service').value;

        const rows = document.querySelectorAll('#active-table tbody tr, #silenced-table tbody tr');

        rows.forEach(row => {
          let show = true;

          if (this.filters.location && row.dataset.location !== this.filters.location) {
            show = false;
          }

          if (this.filters.prom && row.dataset.prom !== this.filters.prom) {
            show = false;
          }

          if (this.filters.service) {
            const rowServices = row.dataset.services ? row.dataset.services.split(',') : [];
            if (!rowServices.includes(this.filters.service)) {
              show = false;
            }
          }

          if (this.filters.time && row.dataset.time) {
            const alertTime = new Date(row.dataset.time.replace(' ', 'T'));
            const now = new Date();
            let cutoff;

            switch (this.filters.time) {
              case '1h': cutoff = new Date(now - 60 * 60 * 1000); break;
              case '6h': cutoff = new Date(now - 6 * 60 * 60 * 1000); break;
              case '24h': cutoff = new Date(now - 24 * 60 * 60 * 1000); break;
              case '7d': cutoff = new Date(now - 7 * 24 * 60 * 60 * 1000); break;
            }

            if (cutoff && alertTime < cutoff) {
              show = false;
            }
          }

          row.classList.toggle('filtered-out', !show);
        });

        this.updateActiveFilterTags();
        this.updateFilterBadge();
        updateCounts();
      },

      updateActiveFilterTags() {
        const container = document.getElementById('active-filters');
        container.innerHTML = '';

        const activeFilters = [];

        if (this.filters.location) {
          activeFilters.push({ type: 'location', label: `Location: ${this.filters.location}` });
        }
        if (this.filters.prom) {
          activeFilters.push({ type: 'prom', label: `Node: ${this.filters.prom}` });
        }
        if (this.filters.time) {
          const timeLabels = { '1h': 'Last 1 Hour', '6h': 'Last 6 Hours', '24h': 'Last 24 Hours', '7d': 'Last 7 Days' };
          activeFilters.push({ type: 'time', label: timeLabels[this.filters.time] });
        }
        if (this.filters.service) {
          activeFilters.push({ type: 'service', label: `Service: ${this.filters.service}` });
        }

        activeFilters.forEach(filter => {
          const tag = document.createElement('div');
          tag.className = 'active-filter-tag';
          tag.innerHTML = `
            <span>${filter.label}</span>
            <button type="button" onclick="removeFilter('${filter.type}')">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
          `;
          container.appendChild(tag);
        });
      },

      updateFilterBadge() {
        const count = Object.values(this.filters).filter(v => v).length;
        const badge = document.getElementById('filter-badge');
        badge.textContent = count;
        badge.classList.toggle('show', count > 0);
      },

      clearAll() {
        document.getElementById('filter-location').value = '';
        document.getElementById('filter-prom').value = '';
        document.getElementById('filter-time').value = '';
        document.getElementById('filter-service').value = '';

        this.filters = { location: '', prom: '', time: '', service: '' };

        document.querySelectorAll('#active-table tbody tr, #silenced-table tbody tr').forEach(row => {
          row.classList.remove('filtered-out');
        });

        this.updateActiveFilterTags();
        this.updateFilterBadge();
        updateCounts();
        showToast('Filters cleared', 'success');
      }
    };

    function applyFilters() {
      FilterManager.apply();
    }

    function clearAllFilters() {
      FilterManager.clearAll();
    }

    function removeFilter(type) {
      document.getElementById(`filter-${type}`).value = '';
      FilterManager.apply();
    }

    function toggleFiltersPanel() {
      FilterManager.togglePanel();
    }

    // ========================================
    // SELECTION & BULK ACTIONS
    // ========================================

    function updateSelectionCount() {
      const checkboxes = document.querySelectorAll('.row-checkbox:checked');
      const count = checkboxes.length;
      const countEl = document.getElementById('selected-count');
      const bulkBar = document.getElementById('bulk-actions');

      countEl.textContent = count;
      bulkBar.classList.toggle('show', count > 0);
    }

    function toggleAllInTable(tableId, checkbox) {
      const table = document.getElementById(tableId);
      const rowCheckboxes = table.querySelectorAll('tbody tr:not(.filtered-out) .row-checkbox');

      rowCheckboxes.forEach(cb => {
        cb.checked = checkbox.checked;
      });

      updateSelectionCount();
    }

    function toggleSelectAll(checkbox) {
      const activePanel = document.querySelector('.tab-panel[style*="block"]') || document.getElementById('active');
      const table = activePanel.querySelector('.data-table');

      if (table) {
        const rowCheckboxes = table.querySelectorAll('tbody tr:not(.filtered-out) .row-checkbox');
        rowCheckboxes.forEach(cb => {
          cb.checked = checkbox.checked;
        });
      }

      updateSelectionCount();
    }

    function clearSelection() {
      document.querySelectorAll('.row-checkbox').forEach(cb => {
        cb.checked = false;
      });
      document.querySelectorAll('.row-checkbox-header').forEach(cb => {
        cb.checked = false;
      });
      updateSelectionCount();
    }

    function bulkSilence() {
      const checkboxes = document.querySelectorAll('#active-table .row-checkbox:checked');
      const hostnames = [];

      checkboxes.forEach(cb => {
        hostnames.push(cb.dataset.hostname);
      });

      if (hostnames.length === 0) {
        showToast('No alerts selected', 'error');
        return;
      }

      // Create a form and submit for each hostname
      hostnames.forEach((hostname, index) => {
        setTimeout(() => {
          const form = document.createElement('form');
          form.method = 'POST';
          form.style.display = 'none';

          const input = document.createElement('input');
          input.type = 'hidden';
          input.name = 'silence-alert';
          input.value = hostname;

          form.appendChild(input);
          document.body.appendChild(form);

          if (index === hostnames.length - 1) {
            form.submit();
          } else {
            // For multiple, we'd need an API. For now, just submit the last one
            form.remove();
          }
        }, index * 100);
      });

      showToast(`Silencing ${hostnames.length} alert(s)...`, 'success');
    }

    // ========================================
    // EXPORT FUNCTIONALITY
    // ========================================

    const ExportManager = {
      init() {
        const exportBtn = document.getElementById('export-btn');
        const exportMenu = document.getElementById('export-menu');

        exportBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          exportMenu.classList.toggle('show');
        });

        document.addEventListener('click', () => {
          exportMenu.classList.remove('show');
        });
      }
    };

    function exportData(format) {
      const activePanel = document.querySelector('.tab-panel[style*="block"]') || document.getElementById('active');
      const table = activePanel.querySelector('.data-table');

      if (!table) return;

      const rows = table.querySelectorAll('tbody tr:not(.filtered-out)');
      const data = [];

      rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        data.push({
          uid: cells[1]?.textContent.trim() || '',
          account: cells[2]?.textContent.trim() || '',
          hostname: cells[3]?.textContent.trim() || '',
          location: cells[4]?.textContent.trim() || '',
          promNode: cells[5]?.textContent.trim() || '',
          startTime: cells[6]?.textContent.trim() || '',
          services: Array.from(cells[7]?.querySelectorAll('.service-tag') || []).map(t => t.textContent.trim())
        });
      });

      if (format === 'json') {
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        downloadBlob(blob, `prometheos-alerts-${new Date().toISOString().slice(0, 10)}.json`);
        showToast('Exported as JSON', 'success');
      } else if (format === 'csv') {
        let csv = 'UID,Account,Hostname,Location,Prom Node,Start Time,Services\n';
        data.forEach(row => {
          csv += `"${row.uid}","${row.account}","${row.hostname}","${row.location}","${row.promNode}","${row.startTime}","${row.services.join('; ')}"\n`;
        });
        const blob = new Blob([csv], { type: 'text/csv' });
        downloadBlob(blob, `prometheos-alerts-${new Date().toISOString().slice(0, 10)}.csv`);
        showToast('Exported as CSV', 'success');
      }

      document.getElementById('export-menu').classList.remove('show');
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // ========================================
    // DASHBOARD WIDGETS
    // ========================================

    function updateDashboardWidgets() {
      const rows = document.querySelectorAll('#active-table tbody tr:not(.filtered-out)');

      // Severity distribution (simulated based on service names)
      let critical = 0, warning = 0, info = 0;
      const serviceCounts = {};
      const locationCounts = {};

      rows.forEach(row => {
        const services = row.dataset.services ? row.dataset.services.split(',') : [];
        const location = row.dataset.location || 'Unknown';

        services.forEach(service => {
          if (service.trim()) {
            serviceCounts[service.trim()] = (serviceCounts[service.trim()] || 0) + 1;

            // Categorize by service name
            const s = service.toLowerCase();
            if (s.includes('critical') || s.includes('down') || s.includes('fail')) {
              critical++;
            } else if (s.includes('warn') || s.includes('high') || s.includes('load')) {
              warning++;
            } else {
              info++;
            }
          }
        });

        locationCounts[location] = (locationCounts[location] || 0) + 1;
      });

      // If no categorization, count all as critical
      if (critical === 0 && warning === 0 && info === 0) {
        critical = rows.length;
      }

      const total = critical + warning + info || 1;

      // Update severity bars
      document.getElementById('severity-critical').style.width = `${(critical / total) * 100}%`;
      document.getElementById('severity-warning').style.width = `${(warning / total) * 100}%`;
      document.getElementById('severity-info').style.width = `${(info / total) * 100}%`;

      document.getElementById('severity-critical-count').textContent = critical;
      document.getElementById('severity-warning-count').textContent = warning;
      document.getElementById('severity-info-count').textContent = info;

      // Update top services
      const topServices = Object.entries(serviceCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);

      const servicesContainer = document.getElementById('top-services');
      if (topServices.length > 0) {
        servicesContainer.innerHTML = topServices.map(([name, count]) => `
          <div class="service-row">
            <span class="service-name">${name}</span>
            <span class="service-count-badge">${count}</span>
          </div>
        `).join('');
      } else {
        servicesContainer.innerHTML = `
          <div class="service-row">
            <span class="service-name">No active alerts</span>
            <span class="service-count-badge">0</span>
          </div>
        `;
      }

      // Update top locations
      const topLocations = Object.entries(locationCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);

      const locationsContainer = document.getElementById('top-locations');
      if (topLocations.length > 0) {
        locationsContainer.innerHTML = topLocations.map(([name, count]) => `
          <div class="location-row" onclick="filterByLocation('${name}')">
            <span class="location-name">${name}</span>
            <span class="location-count-badge">${count}</span>
          </div>
        `).join('');
      } else {
        locationsContainer.innerHTML = `
          <div class="location-row">
            <span class="location-name">No locations</span>
            <span class="location-count-badge">0</span>
          </div>
        `;
      }

      // Update advanced analytics
      updateAdvancedAnalytics();
    }

    function filterByLocation(location) {
      document.getElementById('filter-location').value = location;
      FilterManager.apply();

      // Open filters panel if not open
      const panel = document.getElementById('filters-panel');
      if (!panel.classList.contains('show')) {
        panel.classList.add('show');
      }

      showToast(`Filtered by location: ${location}`, 'success');
    }

    // ========================================
    // ADVANCED ANALYTICS
    // ========================================

    function updateAdvancedAnalytics() {
      const rows = document.querySelectorAll('#active-table tbody tr:not(.filtered-out)');
      const now = new Date();

      // Collect alert data
      const alertData = [];
      rows.forEach(row => {
        const timeStr = row.dataset.time;
        if (timeStr) {
          const alertTime = new Date(timeStr.replace(' ', 'T'));
          const hostname = row.querySelector('.hostname')?.textContent.trim() || '';
          const account = row.querySelector('.cell-primary')?.textContent.trim() || '';
          const services = row.dataset.services || '';

          alertData.push({
            time: alertTime,
            hostname,
            account,
            services,
            duration: now - alertTime
          });
        }
      });

      // Update Quick Stats
      updateQuickStats(alertData, now);

      // Update Oldest Alert
      updateOldestAlert(alertData);

      // Update Alert Velocity
      updateAlertVelocity(alertData, now);

      // Update Recurring Systems
      updateRecurringSystems(alertData);

      // Update Recurring Accounts
      updateRecurringAccounts(alertData);

      // Update Timeline
      updateAlertTimeline(alertData, now);
    }

    function formatDuration(ms) {
      const seconds = Math.floor(ms / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);

      if (days > 0) {
        return `${days}d ${hours % 24}h`;
      } else if (hours > 0) {
        return `${hours}h ${minutes % 60}m`;
      } else if (minutes > 0) {
        return `${minutes}m`;
      } else {
        return `${seconds}s`;
      }
    }

    function updateQuickStats(alertData, now) {
      // Average time open
      if (alertData.length > 0) {
        const avgDuration = alertData.reduce((sum, a) => sum + a.duration, 0) / alertData.length;
        document.getElementById('avg-alert-time').textContent = formatDuration(avgDuration);
      } else {
        document.getElementById('avg-alert-time').textContent = '--';
      }

      // Oldest alert time
      if (alertData.length > 0) {
        const oldest = alertData.reduce((max, a) => a.duration > max.duration ? a : max);
        document.getElementById('oldest-alert-time').textContent = formatDuration(oldest.duration);
      } else {
        document.getElementById('oldest-alert-time').textContent = '--';
      }

      // Alert velocity (alerts in last hour)
      const oneHourAgo = new Date(now - 60 * 60 * 1000);
      const recentAlerts = alertData.filter(a => a.time >= oneHourAgo).length;
      document.getElementById('alert-velocity').textContent = recentAlerts;

      // Recurring systems count (systems with 2+ services alerting)
      const systemServices = {};
      alertData.forEach(a => {
        if (!systemServices[a.hostname]) {
          systemServices[a.hostname] = new Set();
        }
        a.services.split(',').forEach(s => {
          if (s.trim()) systemServices[a.hostname].add(s.trim());
        });
      });
      const recurringCount = Object.values(systemServices).filter(s => s.size >= 2).length;
      document.getElementById('recurring-count').textContent = recurringCount;
    }

    function updateOldestAlert(alertData) {
      const card = document.getElementById('oldest-alert-card');

      if (alertData.length === 0) {
        card.classList.remove('show');
        return;
      }

      const oldest = alertData.reduce((max, a) => a.duration > max.duration ? a : max);

      // Only show if older than 1 hour
      if (oldest.duration < 60 * 60 * 1000) {
        card.classList.remove('show');
        return;
      }

      card.classList.add('show');
      document.getElementById('oldest-hostname').textContent = oldest.hostname;
      document.getElementById('oldest-account').textContent = oldest.account;
      document.getElementById('oldest-started').textContent = oldest.time.toLocaleString();
      document.getElementById('oldest-duration').textContent = formatDuration(oldest.duration);
    }

    function updateAlertVelocity(alertData, now) {
      const chartContainer = document.getElementById('velocity-chart');

      // Generate 24 hourly buckets
      const buckets = [];
      for (let i = 23; i >= 0; i--) {
        const bucketStart = new Date(now - (i + 1) * 60 * 60 * 1000);
        const bucketEnd = new Date(now - i * 60 * 60 * 1000);
        const count = alertData.filter(a => a.time >= bucketStart && a.time < bucketEnd).length;
        buckets.push({
          hour: bucketEnd.getHours(),
          count
        });
      }

      const maxCount = Math.max(...buckets.map(b => b.count), 1);
      const totalAlerts = buckets.reduce((sum, b) => sum + b.count, 0);
      const avgAlerts = (totalAlerts / 24).toFixed(1);
      const peakAlerts = maxCount;

      // Update legend
      document.getElementById('velocity-peak').textContent = peakAlerts;
      document.getElementById('velocity-avg').textContent = avgAlerts;
      document.getElementById('velocity-total').textContent = totalAlerts;

      // Generate bars
      chartContainer.innerHTML = buckets.map((bucket, i) => {
        const height = (bucket.count / maxCount) * 100;
        const label = i % 4 === 0 ? `${bucket.hour}:00` : '';
        return `
          <div class="velocity-bar-wrapper">
            <div class="velocity-bar" style="height: ${Math.max(height, 4)}%" data-count="${bucket.count}"></div>
            <span class="velocity-label">${label}</span>
          </div>
        `;
      }).join('');
    }

    function updateRecurringSystems(alertData) {
      const container = document.getElementById('recurring-systems');

      // Count services per system
      const systemData = {};
      alertData.forEach(a => {
        if (!systemData[a.hostname]) {
          systemData[a.hostname] = {
            hostname: a.hostname,
            account: a.account,
            services: new Set(),
            alertCount: 0
          };
        }
        systemData[a.hostname].alertCount++;
        a.services.split(',').forEach(s => {
          if (s.trim()) systemData[a.hostname].services.add(s.trim());
        });
      });

      // Filter to recurring (2+ services) and sort
      const recurring = Object.values(systemData)
        .filter(s => s.services.size >= 2)
        .sort((a, b) => b.services.size - a.services.size)
        .slice(0, 5);

      if (recurring.length === 0) {
        container.innerHTML = `
          <div class="widget-empty">
            <div class="widget-empty-icon">
              <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                <polyline points="22 4 12 14.01 9 11.01"></polyline>
              </svg>
            </div>
            <span class="widget-empty-text">No recurring patterns detected</span>
          </div>
        `;
        return;
      }

      container.innerHTML = recurring.map((sys, i) => {
        const severity = sys.services.size >= 4 ? '' : sys.services.size >= 3 ? 'warning' : 'info';
        return `
          <div class="recurring-item ${severity}" onclick="filterByHostname('${sys.hostname}')">
            <span class="recurring-rank">${i + 1}</span>
            <div class="recurring-info">
              <div class="recurring-name">${sys.hostname}</div>
              <div class="recurring-meta">${sys.account}</div>
            </div>
            <div class="recurring-count">
              <span class="recurring-count-value">${sys.services.size}</span>
              <span class="recurring-count-label">services</span>
            </div>
          </div>
        `;
      }).join('');
    }

    function updateRecurringAccounts(alertData) {
      const container = document.getElementById('recurring-accounts');

      // Count alerts per account
      const accountData = {};
      alertData.forEach(a => {
        if (!accountData[a.account]) {
          accountData[a.account] = {
            account: a.account,
            hosts: new Set(),
            alertCount: 0
          };
        }
        accountData[a.account].alertCount++;
        accountData[a.account].hosts.add(a.hostname);
      });

      // Filter to accounts with 2+ hosts and sort
      const recurring = Object.values(accountData)
        .filter(a => a.hosts.size >= 2)
        .sort((a, b) => b.hosts.size - a.hosts.size)
        .slice(0, 5);

      if (recurring.length === 0) {
        container.innerHTML = `
          <div class="widget-empty">
            <div class="widget-empty-icon">
              <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                <polyline points="22 4 12 14.01 9 11.01"></polyline>
              </svg>
            </div>
            <span class="widget-empty-text">No recurring patterns detected</span>
          </div>
        `;
        return;
      }

      container.innerHTML = recurring.map((acct, i) => {
        const severity = acct.hosts.size >= 5 ? '' : acct.hosts.size >= 3 ? 'warning' : 'info';
        return `
          <div class="recurring-item ${severity}" onclick="filterByAccount('${acct.account}')">
            <span class="recurring-rank">${i + 1}</span>
            <div class="recurring-info">
              <div class="recurring-name">${acct.account}</div>
              <div class="recurring-meta">${acct.alertCount} total alerts</div>
            </div>
            <div class="recurring-count">
              <span class="recurring-count-value">${acct.hosts.size}</span>
              <span class="recurring-count-label">hosts</span>
            </div>
          </div>
        `;
      }).join('');
    }

    function updateAlertTimeline(alertData, now) {
      const timeline = document.getElementById('alert-timeline');
      const timelineWidth = timeline.offsetWidth;

      if (alertData.length === 0) {
        timeline.innerHTML = '';
        return;
      }

      // 24 hour range
      const rangeMs = 24 * 60 * 60 * 1000;
      const startTime = new Date(now - rangeMs);

      const markers = alertData
        .filter(a => a.time >= startTime)
        .map(a => {
          const position = ((a.time - startTime) / rangeMs) * 100;
          return `
            <div class="timeline-marker" style="left: ${position}%">
              <div class="timeline-tooltip">
                <strong>${a.hostname}</strong><br>
                ${a.time.toLocaleTimeString()}<br>
                ${a.services.split(',').slice(0, 2).join(', ')}
              </div>
            </div>
          `;
        }).join('');

      timeline.innerHTML = markers;
    }

    function filterByHostname(hostname) {
      document.getElementById('search-box').value = hostname;
      document.getElementById('search-form').submit();
    }

    function filterByAccount(account) {
      document.getElementById('search-box').value = account;
      document.getElementById('search-form').submit();
    }

    // ========================================
    // COUNT BADGES & EMPTY STATES
    // ========================================

    function updateCounts() {
      const activeTable = document.getElementById('active-table');
      const silencedTable = document.getElementById('silenced-table');

      const activeCount = activeTable ? activeTable.querySelectorAll('tbody tr:not(.filtered-out)').length : 0;
      const silencedCount = silencedTable ? silencedTable.querySelectorAll('tbody tr:not(.filtered-out)').length : 0;

      const activeBadge = document.getElementById('active-badge');
      const silencedBadge = document.getElementById('silenced-badge');
      const silencedCardCount = document.getElementById('silenced-count');

      if (activeBadge) activeBadge.textContent = activeCount;
      if (silencedBadge) silencedBadge.textContent = silencedCount;
      if (silencedCardCount) silencedCardCount.textContent = silencedCount;

      const activeEmpty = document.getElementById('active-empty');
      const silencedEmpty = document.getElementById('silenced-empty');
      const activeTableContainer = activeTable ? activeTable.closest('.table-container') : null;
      const silencedTableContainer = silencedTable ? silencedTable.closest('.table-container') : null;

      if (activeCount === 0) {
        if (activeTableContainer) activeTableContainer.style.display = 'none';
        if (activeEmpty) activeEmpty.style.display = 'block';
      } else {
        if (activeTableContainer) activeTableContainer.style.display = 'block';
        if (activeEmpty) activeEmpty.style.display = 'none';
      }

      if (silencedCount === 0) {
        if (silencedTableContainer) silencedTableContainer.style.display = 'none';
        if (silencedEmpty) silencedEmpty.style.display = 'block';
      } else {
        if (silencedTableContainer) silencedTableContainer.style.display = 'block';
        if (silencedEmpty) silencedEmpty.style.display = 'none';
      }

      // Update widgets
      updateDashboardWidgets();
    }

    // ========================================
    // TOAST NOTIFICATIONS
    // ========================================

    function showToast(message, type = 'success') {
      const container = document.getElementById('toast-container');
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          ${type === 'success' ?
            '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline>' :
            '<circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>'
          }
        </svg>
        <span>${message}</span>
      `;

      container.appendChild(toast);

      setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transform = 'translateX(20px)';
        setTimeout(() => toast.remove(), 200);
      }, 3000);
    }

    // ========================================
    // KEYBOARD NAVIGATION
    // ========================================

    document.addEventListener('keydown', function(e) {
      // Don't trigger shortcuts when typing in inputs
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
        if (e.key === 'Escape') {
          e.target.blur();
        }
        return;
      }

      // Alt+1 = Active tab, Alt+2 = Silenced tab
      if (e.altKey && e.key === '1') {
        e.preventDefault();
        document.querySelector('.tab-btn').click();
      }
      if (e.altKey && e.key === '2') {
        e.preventDefault();
        document.querySelectorAll('.tab-btn')[1].click();
      }

      // / to focus search
      if (e.key === '/' && !e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        document.getElementById('search-box').focus();
      }

      // ? to show shortcuts
      if (e.key === '?' || (e.shiftKey && e.key === '/')) {
        e.preventDefault();
        ShortcutsModal.toggle();
      }

      // F to toggle filters
      if (e.key === 'f' || e.key === 'F') {
        e.preventDefault();
        FilterManager.togglePanel();
      }

      // T to toggle theme
      if (e.key === 't' || e.key === 'T') {
        e.preventDefault();
        ThemeManager.toggle();
        showToast(`Switched to ${document.documentElement.getAttribute('data-theme')} mode`, 'success');
      }

      // R to refresh
      if (e.key === 'r' || e.key === 'R') {
        e.preventDefault();
        RefreshManager.refresh();
      }

      // Escape to close modals
      if (e.key === 'Escape') {
        ShortcutsModal.close();
        document.getElementById('filters-panel').classList.remove('show');
        document.getElementById('refresh-dropdown').classList.remove('show');
        document.getElementById('export-menu').classList.remove('show');
      }

      // Ctrl+A to select all in current table
      if (e.ctrlKey && e.key === 'a') {
        e.preventDefault();
        const activePanel = document.querySelector('.tab-panel[style*="block"]') || document.getElementById('active');
        const headerCheckbox = activePanel.querySelector('.row-checkbox-header');
        if (headerCheckbox) {
          headerCheckbox.checked = true;
          headerCheckbox.dispatchEvent(new Event('change'));
        }
      }

      // D to cycle through density modes
      if (e.key === 'd' || e.key === 'D') {
        e.preventDefault();
        const densities = ['compact', 'comfortable', 'spacious'];
        const currentIndex = densities.indexOf(DensityManager.current);
        const nextIndex = (currentIndex + 1) % densities.length;
        DensityManager.setDensity(densities[nextIndex]);
        showToast(`Switched to ${densities[nextIndex]} view`, 'success');
      }
    });

    // ========================================
    // DENSITY/VIEW MODE MANAGER
    // ========================================

    const DensityManager = {
      current: 'comfortable',

      init() {
        // Load saved density preference
        const savedDensity = localStorage.getItem('prometheos-density') || 'comfortable';
        this.setDensity(savedDensity);

        // Toggle dropdown
        const toggleBtn = document.getElementById('view-toggle-btn');
        const dropdown = document.getElementById('view-dropdown');

        if (toggleBtn && dropdown) {
          toggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            dropdown.classList.toggle('show');
          });

          // Option selection
          document.querySelectorAll('.view-option').forEach(option => {
            option.addEventListener('click', () => {
              const density = option.dataset.density;
              this.setDensity(density);
              dropdown.classList.remove('show');
              showToast(`Switched to ${density} view`, 'success');
            });
          });

          // Close on outside click
          document.addEventListener('click', () => {
            dropdown.classList.remove('show');
          });
        }
      },

      setDensity(density) {
        this.current = density;
        document.documentElement.setAttribute('data-density', density);
        localStorage.setItem('prometheos-density', density);

        // Update UI
        document.querySelectorAll('.view-option').forEach(option => {
          option.classList.toggle('selected', option.dataset.density === density);
        });
      }
    };

    // ========================================
    // SAVED FILTER PRESETS MANAGER
    // ========================================

    const PresetsManager = {
      presets: [],

      init() {
        // Load saved presets from localStorage
        const saved = localStorage.getItem('prometheos-filter-presets');
        this.presets = saved ? JSON.parse(saved) : [];

        this.render();
        this.bindEvents();
      },

      bindEvents() {
        const presetsBtn = document.getElementById('presets-btn');
        const presetsDropdown = document.getElementById('presets-dropdown');
        const presetNameInput = document.getElementById('preset-name-input');
        const savePresetBtn = document.getElementById('save-preset-btn');

        if (!presetsBtn || !presetsDropdown) return;

        // Toggle dropdown
        presetsBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          presetsDropdown.classList.toggle('show');
        });

        // Close on outside click
        document.addEventListener('click', (e) => {
          if (!presetsDropdown.contains(e.target)) {
            presetsDropdown.classList.remove('show');
          }
        });

        // Prevent dropdown from closing when clicking inside
        presetsDropdown.addEventListener('click', (e) => {
          e.stopPropagation();
        });

        // Enable/disable save button based on input
        if (presetNameInput && savePresetBtn) {
          presetNameInput.addEventListener('input', () => {
            const hasFilters = this.hasActiveFilters();
            const hasName = presetNameInput.value.trim().length > 0;
            savePresetBtn.disabled = !(hasFilters && hasName);
          });

          // Save preset on button click
          savePresetBtn.addEventListener('click', () => {
            this.saveCurrentFilters(presetNameInput.value.trim());
            presetNameInput.value = '';
            savePresetBtn.disabled = true;
          });

          // Save on Enter key
          presetNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !savePresetBtn.disabled) {
              this.saveCurrentFilters(presetNameInput.value.trim());
              presetNameInput.value = '';
              savePresetBtn.disabled = true;
            }
          });
        }
      },

      hasActiveFilters() {
        const location = document.getElementById('filter-location')?.value || '';
        const prom = document.getElementById('filter-prom')?.value || '';
        const time = document.getElementById('filter-time')?.value || '';
        const service = document.getElementById('filter-service')?.value || '';
        const search = document.getElementById('search-box')?.value || '';

        return location || prom || time || service || search;
      },

      getCurrentFilters() {
        return {
          location: document.getElementById('filter-location')?.value || '',
          prom: document.getElementById('filter-prom')?.value || '',
          time: document.getElementById('filter-time')?.value || '',
          service: document.getElementById('filter-service')?.value || '',
          search: document.getElementById('search-box')?.value || ''
        };
      },

      saveCurrentFilters(name) {
        if (!name || !this.hasActiveFilters()) return;

        const preset = {
          id: Date.now(),
          name: name,
          filters: this.getCurrentFilters(),
          createdAt: new Date().toISOString()
        };

        this.presets.unshift(preset);

        // Limit to 10 presets
        if (this.presets.length > 10) {
          this.presets = this.presets.slice(0, 10);
        }

        this.save();
        this.render();
        showToast(`Saved preset: ${name}`, 'success');
      },

      applyPreset(id) {
        const preset = this.presets.find(p => p.id === id);
        if (!preset) return;

        const filters = preset.filters;

        // Apply filter values
        if (document.getElementById('filter-location')) {
          document.getElementById('filter-location').value = filters.location || '';
        }
        if (document.getElementById('filter-prom')) {
          document.getElementById('filter-prom').value = filters.prom || '';
        }
        if (document.getElementById('filter-time')) {
          document.getElementById('filter-time').value = filters.time || '';
        }
        if (document.getElementById('filter-service')) {
          document.getElementById('filter-service').value = filters.service || '';
        }
        if (document.getElementById('search-box') && filters.search) {
          document.getElementById('search-box').value = filters.search;
        }

        // Apply the filters
        FilterManager.apply();

        // Close dropdown
        document.getElementById('presets-dropdown').classList.remove('show');

        showToast(`Applied preset: ${preset.name}`, 'success');
      },

      deletePreset(id) {
        this.presets = this.presets.filter(p => p.id !== id);
        this.save();
        this.render();
        showToast('Preset deleted', 'success');
      },

      save() {
        localStorage.setItem('prometheos-filter-presets', JSON.stringify(this.presets));
      },

      getFilterSummary(filters) {
        const parts = [];
        if (filters.location) parts.push(`Location: ${filters.location}`);
        if (filters.prom) parts.push(`Node: ${filters.prom}`);
        if (filters.time) parts.push(`Time: ${filters.time}`);
        if (filters.service) parts.push(`Service: ${filters.service}`);
        if (filters.search) parts.push(`Search: "${filters.search}"`);
        return parts.join(' | ') || 'No filters';
      },

      render() {
        const list = document.getElementById('presets-list');
        if (!list) return;

        if (this.presets.length === 0) {
          list.innerHTML = '<div class="presets-empty">No saved presets yet</div>';
          return;
        }

        list.innerHTML = this.presets.map(preset => `
          <div class="preset-item" data-id="${preset.id}">
            <div class="preset-info" onclick="PresetsManager.applyPreset(${preset.id})">
              <div class="preset-name">${this.escapeHtml(preset.name)}</div>
              <div class="preset-filters">${this.escapeHtml(this.getFilterSummary(preset.filters))}</div>
            </div>
            <div class="preset-actions">
              <button type="button" class="preset-action-btn delete" onclick="PresetsManager.deletePreset(${preset.id})" title="Delete preset">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <line x1="18" y1="6" x2="6" y2="18"></line>
                  <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
              </button>
            </div>
          </div>
        `).join('');
      },

      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
    };

    // ========================================
    // INITIALIZATION
    // ========================================

    document.addEventListener('DOMContentLoaded', function() {
      ThemeManager.init();
      RefreshManager.init();
      ShortcutsModal.init();
      FilterManager.init();
      ExportManager.init();
      DensityManager.init();
      PresetsManager.init();
      updateCounts();
    });
  </script>
</body>
</html>
{{ end }}
