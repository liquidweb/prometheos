{{ define "foot" }}
  <style>
    /* ========================================
       DATA TABLE STYLES
       ======================================== */

    .tab-panel {
      animation: fadeIn 0.2s ease;
    }

    .table-container {
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-lg);
      overflow: hidden;
    }

    .data-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    .data-table thead {
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border-default);
    }

    .data-table th {
      padding: 14px 16px;
      text-align: left;
      font-weight: 600;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-secondary);
      white-space: nowrap;
      user-select: none;
    }

    .data-table th.sortable {
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .data-table th.sortable:hover {
      color: var(--text-primary);
      background: var(--bg-elevated);
    }

    .data-table th.sortable span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .sort-icon {
      opacity: 0.4;
      font-size: 12px;
      transition: opacity 0.15s ease;
    }

    .data-table th.sortable:hover .sort-icon,
    .data-table th.sortable.asc .sort-icon,
    .data-table th.sortable.desc .sort-icon {
      opacity: 1;
    }

    .data-table th.sortable.asc .sort-icon::after { content: ' ↑'; }
    .data-table th.sortable.desc .sort-icon::after { content: ' ↓'; }

    .data-table tbody tr {
      border-bottom: 1px solid var(--border-subtle);
      transition: background 0.1s ease;
    }

    .data-table tbody tr:last-child {
      border-bottom: none;
    }

    .data-table tbody tr:hover {
      background: var(--bg-tertiary);
    }

    .data-table tbody tr.selected {
      background: var(--accent-bg);
    }

    .data-table tbody tr.filtered-out {
      display: none;
    }

    .data-table td {
      padding: 14px 16px;
      vertical-align: middle;
    }

    /* Checkbox column */
    .col-checkbox {
      width: 40px;
      text-align: center;
    }

    .cell-checkbox {
      text-align: center;
    }

    .row-checkbox,
    .row-checkbox-header {
      width: 16px;
      height: 16px;
      cursor: pointer;
      accent-color: var(--accent);
    }

    /* Cell types */
    .cell-mono {
      font-family: var(--font-mono);
      font-size: 12px;
    }

    .cell-text {
      color: var(--text-primary);
    }

    .cell-muted {
      color: var(--text-muted);
    }

    .cell-primary {
      font-weight: 500;
    }

    /* UID Badge */
    .uid-badge {
      display: inline-block;
      padding: 4px 8px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-default);
      border-radius: var(--radius-sm);
      font-size: 11px;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .uid-badge.silenced {
      background: var(--silenced-bg);
      border-color: var(--silenced);
      color: var(--silenced);
    }

    /* Hostname with status dot */
    .hostname {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .status-dot.critical {
      background: var(--critical);
      box-shadow: 0 0 8px var(--critical);
      animation: pulse-critical 2s ease-in-out infinite;
    }

    .status-dot.silenced {
      background: var(--silenced);
    }

    @keyframes pulse-critical {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Time badge */
    .time-badge {
      display: inline-block;
      padding: 4px 8px;
      background: var(--bg-tertiary);
      border-radius: var(--radius-sm);
      font-size: 12px;
      color: var(--text-secondary);
    }

    /* Duration badge */
    .duration-badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: var(--radius-sm);
      font-size: 12px;
      font-weight: 500;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
    }

    .duration-badge.short {
      background: var(--healthy-bg);
      color: var(--healthy);
    }

    .duration-badge.medium {
      background: var(--warning-bg);
      color: var(--warning);
    }

    .duration-badge.long {
      background: var(--critical-bg);
      color: var(--critical);
    }

    .duration-badge.silenced {
      background: var(--silenced-bg);
      color: var(--silenced);
    }

    /* Service tags */
    .cell-services {
      max-width: 300px;
    }

    .service-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .service-tag {
      display: inline-block;
      padding: 4px 10px;
      background: var(--critical-bg);
      border: 1px solid rgba(255, 107, 107, 0.3);
      border-radius: 20px;
      font-size: 11px;
      font-weight: 500;
      color: var(--critical);
    }

    .service-tag.silenced {
      background: var(--silenced-bg);
      border-color: rgba(139, 92, 246, 0.3);
      color: var(--silenced);
    }

    /* Actions column */
    .col-actions {
      width: 120px;
      text-align: right !important;
    }

    .cell-actions {
      text-align: right;
    }

    .action-form {
      display: inline;
    }

    .btn-action {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      font-family: var(--font-sans);
      font-size: 12px;
      font-weight: 500;
      border: 1px solid transparent;
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .btn-silence {
      background: var(--silenced-bg);
      border-color: rgba(139, 92, 246, 0.3);
      color: var(--silenced);
    }

    .btn-silence:hover {
      background: var(--silenced);
      color: white;
      transform: translateY(-1px);
    }

    .btn-unsilence {
      background: var(--healthy-bg);
      border-color: rgba(74, 222, 128, 0.3);
      color: var(--healthy);
    }

    .btn-unsilence:hover {
      background: var(--healthy);
      color: var(--bg-primary);
      transform: translateY(-1px);
    }

    /* Silenced row styling */
    .silenced-row {
      opacity: 0.7;
    }

    .silenced-row:hover {
      opacity: 1;
    }

    /* Empty state */
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-lg);
    }

    .empty-icon {
      margin-bottom: 16px;
      color: var(--text-muted);
    }

    .empty-state h3 {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--text-primary);
    }

    .empty-state p {
      color: var(--text-muted);
      font-size: 14px;
    }

    /* ========================================
       SKIP LINK FOR ACCESSIBILITY
       ======================================== */

    .skip-link {
      position: absolute;
      top: -100%;
      left: 16px;
      padding: 8px 16px;
      background: var(--accent);
      color: white;
      border-radius: var(--radius-md);
      z-index: 1000;
      transition: top 0.2s ease;
      text-decoration: none;
    }

    .skip-link:focus {
      top: 16px;
    }

    /* ========================================
       TOAST NOTIFICATIONS
       ======================================== */

    .toast-container {
      position: fixed;
      bottom: 24px;
      right: 24px;
      z-index: 1100;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .toast {
      padding: 12px 20px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-default);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-lg);
      font-size: 13px;
      color: var(--text-primary);
      animation: slideInRight 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .toast.success {
      border-color: var(--healthy);
    }

    .toast.error {
      border-color: var(--critical);
    }

    @keyframes slideInRight {
      from { opacity: 0; transform: translateX(20px); }
      to { opacity: 1; transform: translateX(0); }
    }

    /* ========================================
       RESPONSIVE DESIGN
       ======================================== */

    @media (max-width: 1200px) {
      .status-grid {
        grid-template-columns: repeat(2, 1fr);
      }

      .widgets-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 768px) {
      .dashboard-header {
        padding: 0 16px;
      }

      .header-meta {
        gap: 8px;
      }

      .last-update {
        display: none;
      }

      .status-overview {
        padding: 16px;
      }

      .status-grid {
        grid-template-columns: 1fr;
      }

      .controls-bar {
        flex-direction: column;
        align-items: stretch;
      }

      .search-form {
        min-width: 100%;
      }

      .filter-controls {
        justify-content: space-between;
      }

      .search-hint {
        display: none;
      }

      .main-content {
        padding: 0 16px 16px;
      }

      .table-container {
        overflow-x: auto;
      }

      .data-table {
        min-width: 900px;
      }

      .filters-grid {
        grid-template-columns: 1fr;
      }
    }

    /* ========================================
       KEYBOARD FOCUS STYLES
       ======================================== */

    .search-input:focus,
    .btn:focus,
    .btn-action:focus,
    .tab-btn:focus,
    .header-btn:focus,
    .filter-select:focus {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }
  </style>

  <!-- Toast Container -->
  <div class="toast-container" id="toast-container"></div>

  <script>
    // ========================================
    // THEME MANAGEMENT
    // ========================================

    const ThemeManager = {
      init() {
        const savedTheme = localStorage.getItem('prometheos-theme') || 'dark';
        this.setTheme(savedTheme);

        document.getElementById('theme-toggle').addEventListener('click', () => {
          const currentTheme = document.documentElement.getAttribute('data-theme');
          const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
          this.setTheme(newTheme);
          showToast(`Switched to ${newTheme} mode`, 'success');
        });
      },

      setTheme(theme) {
        document.documentElement.setAttribute('data-theme', theme);
        localStorage.setItem('prometheos-theme', theme);
      },

      toggle() {
        const currentTheme = document.documentElement.getAttribute('data-theme');
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
        this.setTheme(newTheme);
      }
    };

    // ========================================
    // AUTO-REFRESH MANAGEMENT
    // ========================================

    const RefreshManager = {
      interval: null,
      currentInterval: 60,

      init() {
        const savedInterval = localStorage.getItem('prometheos-refresh-interval');
        if (savedInterval !== null) {
          this.currentInterval = parseInt(savedInterval);
        }
        this.updateUI();
        this.startRefresh();

        // Dropdown toggle
        const refreshBtn = document.getElementById('refresh-btn');
        const dropdown = document.getElementById('refresh-dropdown');

        refreshBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          dropdown.classList.toggle('show');
        });

        // Option selection
        document.querySelectorAll('.refresh-option').forEach(option => {
          option.addEventListener('click', () => {
            const interval = parseInt(option.dataset.interval);
            this.setInterval(interval);
            dropdown.classList.remove('show');
          });
        });

        // Close dropdown on outside click
        document.addEventListener('click', () => {
          dropdown.classList.remove('show');
        });
      },

      setInterval(seconds) {
        this.currentInterval = seconds;
        localStorage.setItem('prometheos-refresh-interval', seconds);
        this.updateUI();
        this.startRefresh();

        if (seconds === 0) {
          showToast('Auto-refresh disabled', 'success');
        } else {
          showToast(`Auto-refresh set to ${seconds < 60 ? seconds + ' seconds' : (seconds / 60) + ' minute(s)'}`, 'success');
        }
      },

      updateUI() {
        const refreshBtn = document.getElementById('refresh-btn');
        document.querySelectorAll('.refresh-option').forEach(option => {
          const interval = parseInt(option.dataset.interval);
          option.classList.toggle('selected', interval === this.currentInterval);
        });

        if (this.currentInterval > 0) {
          refreshBtn.classList.add('active');
        } else {
          refreshBtn.classList.remove('active');
        }
      },

      startRefresh() {
        if (this.interval) {
          clearInterval(this.interval);
        }

        if (this.currentInterval > 0) {
          this.interval = setInterval(() => {
            this.refresh();
          }, this.currentInterval * 1000);
        }
      },

      refresh() {
        const indicator = document.getElementById('update-indicator');
        indicator.classList.add('refreshing');

        // Reload the page to get fresh data
        setTimeout(() => {
          window.location.reload();
        }, 500);
      }
    };

    // ========================================
    // SHORTCUTS MODAL
    // ========================================

    const ShortcutsModal = {
      init() {
        const modal = document.getElementById('shortcuts-modal');
        const openBtn = document.getElementById('shortcuts-btn');
        const closeBtn = document.getElementById('modal-close');

        openBtn.addEventListener('click', () => this.open());
        closeBtn.addEventListener('click', () => this.close());

        modal.addEventListener('click', (e) => {
          if (e.target === modal) this.close();
        });
      },

      open() {
        document.getElementById('shortcuts-modal').classList.add('show');
      },

      close() {
        document.getElementById('shortcuts-modal').classList.remove('show');
      },

      toggle() {
        const modal = document.getElementById('shortcuts-modal');
        modal.classList.toggle('show');
      }
    };

    // ========================================
    // HELP MODAL
    // ========================================

    const HelpModal = {
      modal: null,
      currentTab: 'overview',

      init() {
        this.modal = document.getElementById('help-modal');
        const openBtn = document.getElementById('help-btn');

        if (openBtn) {
          openBtn.addEventListener('click', () => this.open());
        }

        if (this.modal) {
          this.modal.addEventListener('click', (e) => {
            if (e.target === this.modal) this.close();
          });
        }
      },

      open() {
        if (this.modal) {
          this.modal.classList.add('show');
        }
      },

      close() {
        if (this.modal) {
          this.modal.classList.remove('show');
        }
      },

      toggle() {
        if (this.modal) {
          this.modal.classList.toggle('show');
        }
      },

      showTab(tabName) {
        this.currentTab = tabName;

        // Update tab buttons
        document.querySelectorAll('.help-tab').forEach(tab => {
          tab.classList.toggle('active', tab.dataset.tab === tabName);
        });

        // Update content visibility
        document.querySelectorAll('.help-content').forEach(content => {
          content.style.display = 'none';
        });

        const activeContent = document.getElementById(`help-content-${tabName}`);
        if (activeContent) {
          activeContent.style.display = 'block';
        }
      }
    };

    // ========================================
    // ALERT DETAILS DRAWER
    // ========================================

    const AlertDrawer = {
      overlay: null,
      currentAlert: null,
      currentIndex: 0,
      alerts: [],

      init() {
        this.overlay = document.getElementById('alert-drawer-overlay');

        // Close on overlay click
        if (this.overlay) {
          this.overlay.addEventListener('click', (e) => {
            if (e.target === this.overlay) this.close();
          });
        }

        // Make alert rows clickable
        this.bindRowClicks();

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
          if (!this.overlay?.classList.contains('show')) return;

          if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
            e.preventDefault();
            this.previous();
          } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
            e.preventDefault();
            this.next();
          }
        });
      },

      bindRowClicks() {
        document.querySelectorAll('.alert-row').forEach(row => {
          row.addEventListener('click', (e) => {
            // Don't open drawer if clicking on checkbox, button, or link
            if (e.target.closest('input, button, a, .row-checkbox')) return;
            this.openFromRow(row);
          });
        });
      },

      openFromRow(row) {
        // Build alerts array from visible rows
        const table = row.closest('table');
        this.alerts = Array.from(table.querySelectorAll('tbody tr:not(.filtered-out)'));
        this.currentIndex = this.alerts.indexOf(row);

        this.populateFromRow(row);
        this.open();
      },

      open() {
        if (this.overlay) {
          this.overlay.classList.add('show');
          this.updateNavigation();
        }
      },

      close() {
        if (this.overlay) {
          this.overlay.classList.remove('show');
        }
      },

      populateFromRow(row) {
        this.currentAlert = {
          uid: row.querySelector('.uid-badge')?.textContent || '',
          account: row.querySelector('.cell-primary')?.textContent || '',
          hostname: row.querySelector('.hostname')?.textContent?.trim() || '',
          location: row.dataset.location || '',
          prom: row.dataset.prom || '',
          time: row.dataset.time || '',
          services: row.dataset.services || '',
          isSilenced: row.closest('#silenced') !== null
        };

        // Populate fields
        document.getElementById('drawer-hostname').textContent = this.currentAlert.hostname;
        document.getElementById('drawer-uid').textContent = this.currentAlert.uid;
        document.getElementById('drawer-account').textContent = this.currentAlert.account;
        document.getElementById('drawer-hostname-full').textContent = this.currentAlert.hostname;
        document.getElementById('drawer-location').textContent = this.currentAlert.location || '—';
        document.getElementById('drawer-prom').textContent = this.currentAlert.prom || '—';
        document.getElementById('drawer-time').textContent = this.currentAlert.time || '—';

        // Calculate duration
        if (this.currentAlert.time) {
          const start = new Date(this.currentAlert.time.replace(' ', 'T'));
          const now = new Date();
          const diffMs = now - start;
          const hours = Math.floor(diffMs / (1000 * 60 * 60));
          const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
          document.getElementById('drawer-duration').textContent =
            hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;
        } else {
          document.getElementById('drawer-duration').textContent = '—';
        }

        // Populate services
        const servicesContainer = document.getElementById('drawer-services');
        const services = this.currentAlert.services.split(',').filter(s => s.trim());
        servicesContainer.innerHTML = services.length > 0
          ? services.map(s => `<span class="drawer-service-tag">${this.escapeHtml(s.trim())}</span>`).join('')
          : '<span class="drawer-info-value">No services</span>';

        // Populate labels from data attributes
        const labelsContainer = document.getElementById('drawer-labels');
        const labels = [];
        Object.keys(row.dataset).forEach(key => {
          if (!['time', 'services', 'location', 'prom', 'uid'].includes(key)) {
            labels.push({ key, value: row.dataset[key] });
          }
        });

        if (labels.length > 0) {
          labelsContainer.innerHTML = labels.map(l => `
            <span class="drawer-label">
              <span class="drawer-label-key">${this.escapeHtml(l.key)}:</span>
              <span class="drawer-label-value">${this.escapeHtml(l.value)}</span>
            </span>
          `).join('');
          document.getElementById('drawer-labels-section').style.display = 'block';
        } else {
          document.getElementById('drawer-labels-section').style.display = 'none';
        }

        // Update silence button
        const silenceBtn = document.getElementById('drawer-silence-btn');
        const silenceText = document.getElementById('drawer-silence-text');
        if (this.currentAlert.isSilenced) {
          silenceBtn.classList.remove('danger');
          silenceBtn.classList.add('secondary');
          silenceText.textContent = 'Unsilence Alert';
        } else {
          silenceBtn.classList.remove('secondary');
          silenceBtn.classList.add('danger');
          silenceText.textContent = 'Silence Alert';
        }
      },

      updateNavigation() {
        const prevBtn = document.getElementById('drawer-prev-btn');
        const nextBtn = document.getElementById('drawer-next-btn');
        const position = document.getElementById('drawer-position');

        prevBtn.disabled = this.currentIndex === 0;
        nextBtn.disabled = this.currentIndex === this.alerts.length - 1;
        position.textContent = `${this.currentIndex + 1} of ${this.alerts.length}`;
      },

      previous() {
        if (this.currentIndex > 0) {
          this.currentIndex--;
          this.populateFromRow(this.alerts[this.currentIndex]);
          this.updateNavigation();
        }
      },

      next() {
        if (this.currentIndex < this.alerts.length - 1) {
          this.currentIndex++;
          this.populateFromRow(this.alerts[this.currentIndex]);
          this.updateNavigation();
        }
      },

      silenceAlert() {
        if (!this.currentAlert) return;

        const form = document.createElement('form');
        form.method = 'POST';
        form.style.display = 'none';

        const input = document.createElement('input');
        input.name = this.currentAlert.isSilenced ? 'remove-silence' : 'silence-alert';
        input.value = this.currentAlert.hostname;
        form.appendChild(input);

        document.body.appendChild(form);
        form.submit();
      },

      copyAsText() {
        if (!this.currentAlert) return;

        const text = `Alert: ${this.currentAlert.hostname}
UID: ${this.currentAlert.uid}
Account: ${this.currentAlert.account}
Location: ${this.currentAlert.location}
Prom Node: ${this.currentAlert.prom}
Started: ${this.currentAlert.time}
Services: ${this.currentAlert.services}`;

        navigator.clipboard.writeText(text).then(() => {
          showToast('Alert details copied to clipboard', 'success');
        }).catch(() => {
          showToast('Failed to copy to clipboard', 'error');
        });
      },

      copyAsJSON() {
        if (!this.currentAlert) return;

        const json = JSON.stringify(this.currentAlert, null, 2);
        navigator.clipboard.writeText(json).then(() => {
          showToast('Alert JSON copied to clipboard', 'success');
        }).catch(() => {
          showToast('Failed to copy to clipboard', 'error');
        });
      },

      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
    };

    // ========================================
    // BULK ACTIONS
    // ========================================

    const BulkActions = {
      selectedRows: new Set(),
      bar: null,

      init() {
        this.bar = document.getElementById('bulk-actions-bar');
        this.bindCheckboxes();
      },

      bindCheckboxes() {
        // Row checkboxes
        document.querySelectorAll('.row-checkbox').forEach(checkbox => {
          checkbox.addEventListener('change', (e) => {
            e.stopPropagation();
            const row = checkbox.closest('tr');
            if (checkbox.checked) {
              this.selectedRows.add(row);
              row.classList.add('selected');
            } else {
              this.selectedRows.delete(row);
              row.classList.remove('selected');
            }
            this.updateBar();
          });
        });

        // Header checkboxes (select all)
        document.querySelectorAll('.row-checkbox-header').forEach(headerCheckbox => {
          headerCheckbox.addEventListener('change', () => {
            const table = headerCheckbox.closest('table');
            const checkboxes = table.querySelectorAll('tbody .row-checkbox');
            checkboxes.forEach(checkbox => {
              const row = checkbox.closest('tr');
              if (!row.classList.contains('filtered-out')) {
                checkbox.checked = headerCheckbox.checked;
                if (headerCheckbox.checked) {
                  this.selectedRows.add(row);
                  row.classList.add('selected');
                } else {
                  this.selectedRows.delete(row);
                  row.classList.remove('selected');
                }
              }
            });
            this.updateBar();
          });
        });
      },

      updateBar() {
        const count = this.selectedRows.size;
        document.getElementById('bulk-count').textContent = count;

        if (count > 0) {
          this.bar.classList.add('show');
        } else {
          this.bar.classList.remove('show');
        }
      },

      clearSelection() {
        this.selectedRows.forEach(row => {
          row.classList.remove('selected');
          const checkbox = row.querySelector('.row-checkbox');
          if (checkbox) checkbox.checked = false;
        });
        this.selectedRows.clear();

        // Uncheck header checkboxes
        document.querySelectorAll('.row-checkbox-header').forEach(cb => cb.checked = false);

        this.updateBar();
      },

      getSelectedData() {
        return Array.from(this.selectedRows).map(row => ({
          uid: row.querySelector('.uid-badge')?.textContent || '',
          account: row.querySelector('.cell-primary')?.textContent || '',
          hostname: row.querySelector('.hostname')?.textContent?.trim() || '',
          location: row.dataset.location || '',
          prom: row.dataset.prom || '',
          time: row.dataset.time || '',
          services: row.dataset.services || ''
        }));
      },

      silenceSelected() {
        const hostnames = this.getSelectedData().map(a => a.hostname);
        if (hostnames.length === 0) return;

        // For now, silence one at a time (could be batched with API)
        const form = document.createElement('form');
        form.method = 'POST';
        form.style.display = 'none';

        hostnames.forEach(hostname => {
          const input = document.createElement('input');
          input.name = 'silence-alert';
          input.value = hostname;
          form.appendChild(input);
        });

        document.body.appendChild(form);
        showToast(`Silencing ${hostnames.length} alert(s)...`, 'success');
        form.submit();
      },

      unsilenceSelected() {
        const hostnames = this.getSelectedData().map(a => a.hostname);
        if (hostnames.length === 0) return;

        const form = document.createElement('form');
        form.method = 'POST';
        form.style.display = 'none';

        hostnames.forEach(hostname => {
          const input = document.createElement('input');
          input.name = 'remove-silence';
          input.value = hostname;
          form.appendChild(input);
        });

        document.body.appendChild(form);
        showToast(`Unsilencing ${hostnames.length} alert(s)...`, 'success');
        form.submit();
      },

      createIncident() {
        const data = this.getSelectedData();
        if (data.length < 2) {
          showToast('Select at least 2 alerts to create an incident', 'error');
          return;
        }

        // Use IncidentManager to create incident
        IncidentManager.createFromAlerts(data);
        this.clearSelection();
        showToast(`Created incident with ${data.length} alerts`, 'success');
      },

      copySelected() {
        const data = this.getSelectedData();
        if (data.length === 0) return;

        const text = data.map(a =>
          `${a.hostname} | ${a.account} | ${a.services} | ${a.time}`
        ).join('\n');

        navigator.clipboard.writeText(text).then(() => {
          showToast(`Copied ${data.length} alert(s) to clipboard`, 'success');
        }).catch(() => {
          showToast('Failed to copy to clipboard', 'error');
        });
      }
    };

    // ========================================
    // NEW ALERTS INDICATOR
    // ========================================

    const NewAlertsIndicator = {
      banner: null,
      knownAlerts: new Set(),
      newAlerts: [],
      storageKey: 'prometheos-known-alerts',

      init() {
        this.banner = document.getElementById('new-alerts-banner');

        // Load known alerts from localStorage
        this.loadKnownAlerts();

        // Check for new alerts on page load
        this.checkForNewAlerts();

        // Save current alerts before page unload
        window.addEventListener('beforeunload', () => this.saveKnownAlerts());
      },

      loadKnownAlerts() {
        try {
          const saved = localStorage.getItem(this.storageKey);
          if (saved) {
            const data = JSON.parse(saved);
            // Only use saved data if it's less than 1 hour old
            if (data.timestamp && (Date.now() - data.timestamp) < 3600000) {
              this.knownAlerts = new Set(data.alerts || []);
              return;
            }
          }
        } catch (e) {
          console.warn('Failed to load known alerts:', e);
        }

        // If no valid saved data, initialize from current alerts (first load)
        this.initializeFromCurrentAlerts();
      },

      initializeFromCurrentAlerts() {
        document.querySelectorAll('#active-table tbody tr').forEach(row => {
          const id = this.getAlertId(row);
          if (id) this.knownAlerts.add(id);
        });
        this.saveKnownAlerts();
      },

      saveKnownAlerts() {
        try {
          // Keep only alerts that still exist in the DOM plus new ones
          const currentIds = new Set();
          document.querySelectorAll('#active-table tbody tr').forEach(row => {
            const id = this.getAlertId(row);
            if (id) currentIds.add(id);
          });

          // Merge with known (in case some alerts were dismissed but still exist)
          const toSave = [...currentIds];

          localStorage.setItem(this.storageKey, JSON.stringify({
            alerts: toSave,
            timestamp: Date.now()
          }));
        } catch (e) {
          console.warn('Failed to save known alerts:', e);
        }
      },

      getAlertId(row) {
        const hostname = row.querySelector('.hostname')?.textContent?.trim();
        const time = row.dataset.time;
        return hostname && time ? `${hostname}-${time}` : null;
      },

      checkForNewAlerts() {
        this.newAlerts = [];

        document.querySelectorAll('#active-table tbody tr').forEach(row => {
          const id = this.getAlertId(row);
          if (id && !this.knownAlerts.has(id)) {
            this.newAlerts.push(row);
            row.classList.add('new-alert');
          }
        });

        if (this.newAlerts.length > 0) {
          this.show();
        }
      },

      show() {
        if (this.banner) {
          document.getElementById('new-alerts-count').textContent = this.newAlerts.length;
          this.banner.classList.add('show');
        }
      },

      dismiss() {
        if (this.banner) {
          this.banner.classList.remove('show');
          // Add new alerts to known set
          this.newAlerts.forEach(row => {
            const id = this.getAlertId(row);
            if (id) this.knownAlerts.add(id);
            row.classList.remove('new-alert');
          });
          this.newAlerts = [];
          this.saveKnownAlerts();
        }
      },

      scrollToNew() {
        if (this.newAlerts.length > 0) {
          this.newAlerts[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
          this.dismiss();
        }
      }
    };

    // ========================================
    // URL STATE MANAGER
    // ========================================

    const URLState = {
      init() {
        // Read state from URL on load
        this.loadFromURL();

        // Update URL when state changes (debounced)
        this.setupListeners();

        // Handle browser back/forward
        window.addEventListener('popstate', () => this.loadFromURL());
      },

      loadFromURL() {
        const params = new URLSearchParams(window.location.search);

        // Tab
        const tab = params.get('tab');
        if (tab === 'silenced') {
          document.querySelectorAll('.tab-btn')[1]?.click();
        }

        // Search
        const search = params.get('q');
        if (search) {
          const searchBox = document.getElementById('search-box');
          if (searchBox) {
            searchBox.value = search;
            searchBox.dispatchEvent(new Event('input'));
          }
        }

        // Time range
        const range = params.get('range');
        if (range && TimeRangeManager.rangeMs[range]) {
          TimeRangeManager.setRange(range);
        }

        // Theme
        const theme = params.get('theme');
        if (theme === 'dark' || theme === 'light') {
          ThemeManager.setTheme(theme);
        }

        // Density
        const density = params.get('density');
        if (['compact', 'comfortable', 'spacious'].includes(density)) {
          DensityManager.setDensity(density);
        }

        // Filters
        const location = params.get('location');
        const account = params.get('account');
        const service = params.get('service');
        const prom = params.get('prom');

        if (location || account || service || prom) {
          // Open filters panel and set values
          if (location) {
            const el = document.getElementById('filter-location');
            if (el) el.value = location;
          }
          if (account) {
            const el = document.getElementById('filter-account');
            if (el) el.value = account;
          }
          if (service) {
            const el = document.getElementById('filter-service');
            if (el) el.value = service;
          }
          if (prom) {
            const el = document.getElementById('filter-prom');
            if (el) el.value = prom;
          }

          // Apply filters
          setTimeout(() => FilterManager.applyFilters(), 100);
        }
      },

      setupListeners() {
        // Search box
        const searchBox = document.getElementById('search-box');
        if (searchBox) {
          searchBox.addEventListener('input', this.debounce(() => this.updateURL(), 500));
        }

        // Tab buttons
        document.querySelectorAll('.tab-btn').forEach(btn => {
          btn.addEventListener('click', () => this.updateURL());
        });

        // Filter changes
        ['filter-location', 'filter-account', 'filter-service', 'filter-prom'].forEach(id => {
          const el = document.getElementById(id);
          if (el) {
            el.addEventListener('change', () => this.updateURL());
          }
        });
      },

      updateURL() {
        const params = new URLSearchParams();

        // Tab
        const activeTab = document.querySelector('.tab-btn.active');
        if (activeTab?.textContent?.toLowerCase().includes('silenced')) {
          params.set('tab', 'silenced');
        }

        // Search
        const search = document.getElementById('search-box')?.value;
        if (search) params.set('q', search);

        // Time range
        if (TimeRangeManager.current !== '24h') {
          params.set('range', TimeRangeManager.current);
        }

        // Filters
        const location = document.getElementById('filter-location')?.value;
        const account = document.getElementById('filter-account')?.value;
        const service = document.getElementById('filter-service')?.value;
        const prom = document.getElementById('filter-prom')?.value;

        if (location) params.set('location', location);
        if (account) params.set('account', account);
        if (service) params.set('service', service);
        if (prom) params.set('prom', prom);

        // Update URL without reload
        const newURL = params.toString()
          ? `${window.location.pathname}?${params.toString()}`
          : window.location.pathname;

        window.history.replaceState({}, '', newURL);
      },

      getShareableURL() {
        this.updateURL();
        return window.location.href;
      },

      copyShareableURL() {
        const url = this.getShareableURL();
        navigator.clipboard.writeText(url).then(() => {
          showToast('Dashboard URL copied to clipboard', 'success');
        }).catch(() => {
          showToast('Failed to copy URL', 'error');
        });
      },

      debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }
    };

    // ========================================
    // TAB SWITCHING
    // ========================================

    function openAlerts(evt, alertType) {
      const panels = document.querySelectorAll('.tab-panel');
      panels.forEach(panel => {
        panel.style.display = 'none';
      });

      const tabs = document.querySelectorAll('.tab-btn');
      tabs.forEach(tab => {
        tab.classList.remove('active');
      });

      document.getElementById(alertType).style.display = 'block';
      evt.currentTarget.classList.add('active');
    }

    // ========================================
    // TABLE SORTING
    // ========================================

    const sortStates = {};

    function sortTable(tableId, columnIndex) {
      const table = document.getElementById(tableId);
      const tbody = table.querySelector('tbody');
      const rows = Array.from(tbody.querySelectorAll('tr:not(.filtered-out)'));
      const th = table.querySelectorAll('th')[columnIndex];

      const stateKey = `${tableId}-${columnIndex}`;
      if (!sortStates[stateKey]) {
        sortStates[stateKey] = 'asc';
      } else {
        sortStates[stateKey] = sortStates[stateKey] === 'asc' ? 'desc' : 'asc';
      }

      const direction = sortStates[stateKey];

      table.querySelectorAll('th').forEach(header => {
        header.classList.remove('asc', 'desc');
      });
      th.classList.add(direction);

      rows.sort((a, b) => {
        const aVal = a.cells[columnIndex].textContent.trim().toLowerCase();
        const bVal = b.cells[columnIndex].textContent.trim().toLowerCase();

        const datePattern = /^\d{4}-\d{2}-\d{2}/;
        if (datePattern.test(aVal) && datePattern.test(bVal)) {
          const aDate = new Date(aVal.replace(' ', 'T'));
          const bDate = new Date(bVal.replace(' ', 'T'));
          return direction === 'asc' ? aDate - bDate : bDate - aDate;
        }

        if (aVal < bVal) return direction === 'asc' ? -1 : 1;
        if (aVal > bVal) return direction === 'asc' ? 1 : -1;
        return 0;
      });

      rows.forEach(row => tbody.appendChild(row));
    }

    // ========================================
    // FILTERING
    // ========================================

    const FilterManager = {
      filters: {
        datacenter: '',
        section: '',
        row: '',
        rack: '',
        prom: '',
        time: '',
        service: ''
      },

      init() {
        this.populateFilterOptions();

        document.getElementById('filter-toggle').addEventListener('click', () => {
          this.togglePanel();
        });

        // Update clear all button when search changes
        const searchBox = document.getElementById('search-box');
        if (searchBox) {
          searchBox.addEventListener('input', () => {
            this.updateClearAllButton();
          });
        }
      },

      togglePanel() {
        const panel = document.getElementById('filters-panel');
        panel.classList.toggle('show');
      },

      // Parse location code: B3S2R9K8U27 -> { datacenter, section, row, rack }
      parseLocation(location) {
        if (!location) return null;
        const match = location.match(/^B(\d+)S(\d+)R(\d+)K(\d+)(?:U(\d+))?$/i);
        if (!match) return null;
        return {
          datacenter: `B${match[1]}`,
          section: `B${match[1]}S${match[2]}`,
          row: `B${match[1]}S${match[2]}R${match[3]}`,
          rack: `B${match[1]}S${match[2]}R${match[3]}K${match[4]}`
        };
      },

      populateFilterOptions() {
        const rows = document.querySelectorAll('#active-table tbody tr, #silenced-table tbody tr');
        const datacenters = new Set();
        const sections = new Set();
        const rowsSet = new Set();
        const racks = new Set();
        const proms = new Set();
        const services = new Set();

        rows.forEach(row => {
          if (row.dataset.location) {
            const parsed = this.parseLocation(row.dataset.location);
            if (parsed) {
              datacenters.add(parsed.datacenter);
              sections.add(parsed.section);
              rowsSet.add(parsed.row);
              racks.add(parsed.rack);
            }
          }
          if (row.dataset.prom) proms.add(row.dataset.prom);
          if (row.dataset.services) {
            row.dataset.services.split(',').forEach(s => {
              if (s.trim()) services.add(s.trim());
            });
          }
        });

        this.populateSelect('filter-datacenter', Array.from(datacenters).sort());
        this.populateSelect('filter-section', Array.from(sections).sort());
        this.populateSelect('filter-row', Array.from(rowsSet).sort());
        this.populateSelect('filter-rack', Array.from(racks).sort());
        this.populateSelect('filter-prom', Array.from(proms).sort());
        this.populateSelect('filter-service', Array.from(services).sort());
      },

      populateSelect(selectId, options) {
        const select = document.getElementById(selectId);
        const currentValue = select.value;

        // Keep the first "All" option
        while (select.options.length > 1) {
          select.remove(1);
        }

        options.forEach(opt => {
          const option = document.createElement('option');
          option.value = opt;
          option.textContent = opt;
          select.appendChild(option);
        });

        select.value = currentValue;
      },

      apply() {
        this.filters.datacenter = document.getElementById('filter-datacenter')?.value || '';
        this.filters.section = document.getElementById('filter-section')?.value || '';
        this.filters.row = document.getElementById('filter-row')?.value || '';
        this.filters.rack = document.getElementById('filter-rack')?.value || '';
        this.filters.prom = document.getElementById('filter-prom')?.value || '';
        this.filters.time = document.getElementById('filter-time')?.value || '';
        this.filters.service = document.getElementById('filter-service')?.value || '';

        const rows = document.querySelectorAll('#active-table tbody tr, #silenced-table tbody tr');

        rows.forEach(row => {
          let show = true;
          const location = row.dataset.location || '';
          const parsed = this.parseLocation(location);

          // Location hierarchy filters
          if (this.filters.datacenter && parsed) {
            if (parsed.datacenter !== this.filters.datacenter) show = false;
          }
          if (this.filters.section && parsed) {
            if (parsed.section !== this.filters.section) show = false;
          }
          if (this.filters.row && parsed) {
            if (parsed.row !== this.filters.row) show = false;
          }
          if (this.filters.rack && parsed) {
            if (parsed.rack !== this.filters.rack) show = false;
          }

          if (this.filters.prom && row.dataset.prom !== this.filters.prom) {
            show = false;
          }

          if (this.filters.service) {
            const rowServices = row.dataset.services ? row.dataset.services.split(',') : [];
            if (!rowServices.includes(this.filters.service)) {
              show = false;
            }
          }

          if (this.filters.time && row.dataset.time) {
            const alertTime = new Date(row.dataset.time.replace(' ', 'T'));
            const now = new Date();
            let cutoff;

            switch (this.filters.time) {
              case '1h': cutoff = new Date(now - 60 * 60 * 1000); break;
              case '6h': cutoff = new Date(now - 6 * 60 * 60 * 1000); break;
              case '24h': cutoff = new Date(now - 24 * 60 * 60 * 1000); break;
              case '7d': cutoff = new Date(now - 7 * 24 * 60 * 60 * 1000); break;
            }

            if (cutoff && alertTime < cutoff) {
              show = false;
            }
          }

          row.classList.toggle('filtered-out', !show);
        });

        this.updateActiveFilterTags();
        this.updateFilterBadge();
        this.updateClearAllButton();
        updateCounts();
      },

      updateActiveFilterTags() {
        const container = document.getElementById('active-filters');
        container.innerHTML = '';

        const activeFilters = [];

        if (this.filters.datacenter) {
          activeFilters.push({ type: 'datacenter', label: `DC: ${this.filters.datacenter}` });
        }
        if (this.filters.section) {
          activeFilters.push({ type: 'section', label: `Section: ${this.filters.section}` });
        }
        if (this.filters.row) {
          activeFilters.push({ type: 'row', label: `Row: ${this.filters.row}` });
        }
        if (this.filters.rack) {
          activeFilters.push({ type: 'rack', label: `Rack: ${this.filters.rack}` });
        }
        if (this.filters.prom) {
          activeFilters.push({ type: 'prom', label: `Node: ${simplifyPromName(this.filters.prom)}` });
        }
        if (this.filters.time) {
          const timeLabels = { '1h': 'Last 1 Hour', '6h': 'Last 6 Hours', '24h': 'Last 24 Hours', '7d': 'Last 7 Days' };
          activeFilters.push({ type: 'time', label: timeLabels[this.filters.time] });
        }
        if (this.filters.service) {
          activeFilters.push({ type: 'service', label: `Service: ${this.filters.service}` });
        }

        activeFilters.forEach(filter => {
          const tag = document.createElement('div');
          tag.className = 'active-filter-tag';
          tag.innerHTML = `
            <span>${filter.label}</span>
            <button type="button" onclick="removeFilter('${filter.type}')">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
          `;
          container.appendChild(tag);
        });
      },

      updateFilterBadge() {
        const count = Object.values(this.filters).filter(v => v).length;
        const badge = document.getElementById('filter-badge');
        badge.textContent = count;
        badge.classList.toggle('show', count > 0);
      },

      clearAll() {
        // Clear filter dropdowns
        const filterIds = ['filter-datacenter', 'filter-section', 'filter-row', 'filter-rack', 'filter-prom', 'filter-time', 'filter-service'];
        filterIds.forEach(id => {
          const el = document.getElementById(id);
          if (el) el.value = '';
        });

        // Clear search box
        const searchBox = document.getElementById('search-box');
        if (searchBox && searchBox.value) {
          searchBox.value = '';
          searchBox.dispatchEvent(new Event('input'));
        }

        this.filters = { datacenter: '', section: '', row: '', rack: '', prom: '', time: '', service: '' };

        document.querySelectorAll('#active-table tbody tr, #silenced-table tbody tr').forEach(row => {
          row.classList.remove('filtered-out');
        });

        this.updateActiveFilterTags();
        this.updateFilterBadge();
        this.updateClearAllButton();
        updateCounts();
        showToast('All filters and search cleared', 'success');
      },

      updateClearAllButton() {
        const hasFilters = Object.values(this.filters).some(v => v);
        const hasSearch = document.getElementById('search-box')?.value?.trim();
        const clearBtn = document.getElementById('clear-all-btn');
        if (clearBtn) {
          clearBtn.classList.toggle('show', hasFilters || hasSearch);
        }
      }
    };

    function applyFilters() {
      FilterManager.apply();
    }

    function clearAllFilters() {
      FilterManager.clearAll();
    }

    function removeFilter(type) {
      const el = document.getElementById(`filter-${type}`);
      if (el) {
        el.value = '';
        FilterManager.filters[type] = '';
      }
      FilterManager.apply();
    }

    function toggleFiltersPanel() {
      FilterManager.togglePanel();
    }

    // ========================================
    // PROM NAME SIMPLIFICATION
    // ========================================

    // Simplify full prom name to short form: n01.b3.alertmanager.pro.mon.liquidweb.com -> n01.b3
    function simplifyPromName(fullName) {
      if (!fullName) return '';
      const parts = fullName.split('.');
      if (parts.length >= 2) {
        return `${parts[0]}.${parts[1]}`;
      }
      return fullName;
    }

    // Initialize prom display names in table cells
    function initPromDisplayNames() {
      document.querySelectorAll('.cell-prom').forEach(cell => {
        const fullName = cell.dataset.promFull || '';
        const shortName = simplifyPromName(fullName);
        const display = cell.querySelector('.prom-display');
        if (display) {
          display.innerHTML = `<span class="prom-short">${shortName}</span>`;
          display.title = fullName; // Show full name on hover
        }
      });
    }

    // Parse location code and populate separate location columns
    function initLocationDisplayCells() {
      // Parse location code: B3S2R9K8U27 -> { datacenter: B3, section: S2, row: R9, rack: K8 }
      function parseLocationParts(location) {
        if (!location) return null;
        const match = location.match(/^B(\d+)S(\d+)R(\d+)K(\d+)(?:U(\d+))?$/i);
        if (!match) return null;
        return {
          datacenter: `B${match[1]}`,
          section: `S${match[2]}`,
          row: `R${match[3]}`,
          rack: `K${match[4]}`
        };
      }

      // Process all rows that have location cells
      document.querySelectorAll('.cell-datacenter').forEach(cell => {
        const location = cell.dataset.location || '';
        const parsed = parseLocationParts(location);
        cell.textContent = parsed ? parsed.datacenter : '-';
        cell.title = location; // Show full location on hover
      });

      document.querySelectorAll('.cell-section').forEach(cell => {
        const location = cell.dataset.location || '';
        const parsed = parseLocationParts(location);
        cell.textContent = parsed ? parsed.section : '-';
        cell.title = location;
      });

      document.querySelectorAll('.cell-row').forEach(cell => {
        const location = cell.dataset.location || '';
        const parsed = parseLocationParts(location);
        cell.textContent = parsed ? parsed.row : '-';
        cell.title = location;
      });

      document.querySelectorAll('.cell-rack').forEach(cell => {
        const location = cell.dataset.location || '';
        const parsed = parseLocationParts(location);
        cell.textContent = parsed ? parsed.rack : '-';
        cell.title = location;
      });
    }

    // ========================================
    // STATUS CARDS NAVIGATION
    // ========================================

    const StatusCards = {
      goToActiveAlerts() {
        // Switch to active tab and scroll to table
        const activeTab = document.querySelector('.tab-btn');
        if (activeTab) activeTab.click();

        const table = document.getElementById('active-table');
        if (table) {
          table.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        showToast('Viewing active alerts', 'info');
      },

      goToAffectedServers() {
        // Switch to active tab and focus on unique hostnames
        const activeTab = document.querySelector('.tab-btn');
        if (activeTab) activeTab.click();

        // Show unique servers count
        const rows = document.querySelectorAll('#active-table tbody tr:not(.filtered-out)');
        const hosts = new Set();
        rows.forEach(row => {
          const hostname = row.querySelector('.hostname')?.textContent.trim();
          if (hostname) hosts.add(hostname);
        });

        const table = document.getElementById('active-table');
        if (table) {
          table.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        showToast(`${hosts.size} unique servers affected`, 'info');
      },

      goToIncidents() {
        // Expand incidents section and scroll to it
        const incidentsSection = document.getElementById('incidents-section');
        if (incidentsSection) {
          // Ensure section is expanded
          const content = incidentsSection.querySelector('.section-content');
          if (content && content.style.display === 'none') {
            SectionManager.toggle('incidents');
          }
          incidentsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        showToast('Viewing incidents', 'info');
      },

      goToSilenced() {
        // Switch to silenced tab
        const silencedTab = document.querySelectorAll('.tab-btn')[1];
        if (silencedTab) silencedTab.click();

        const table = document.getElementById('silenced-table');
        if (table) {
          table.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        showToast('Viewing silenced alerts', 'info');
      }
    };

    // ========================================
    // ALERT MANAGERS MODAL
    // ========================================

    const AlertManagersModal = {
      alertManagers: [
        'c01.b3.alertmanager.pro.mon.liquidweb.com',
        'c02.b3.alertmanager.pro.mon.liquidweb.com',
        'n01.b2.alertmanager.pro.mon.liquidweb.com',
        'n01.b3.alertmanager.pro.mon.liquidweb.com',
        'n01.b4.alertmanager.pro.mon.liquidweb.com',
        'n01.b5.alertmanager.pro.mon.liquidweb.com',
        'n02.b2.alertmanager.pro.mon.liquidweb.com',
        'n02.b3.alertmanager.pro.mon.liquidweb.com',
        'n02.b4.alertmanager.pro.mon.liquidweb.com',
        'n02.b5.alertmanager.pro.mon.liquidweb.com',
        'n03.b3.alertmanager.pro.mon.liquidweb.com',
        'n04.b3.alertmanager.pro.mon.liquidweb.com',
        'n05.b3.alertmanager.pro.mon.liquidweb.com',
        'n06.b3.alertmanager.pro.mon.liquidweb.com',
        'n07.b3.alertmanager.pro.mon.liquidweb.com',
        'n08.b3.alertmanager.pro.mon.liquidweb.com'
      ],

      promStats: {},

      init() {
        this.collectStats();
      },

      collectStats() {
        this.promStats = {};
        const rows = document.querySelectorAll('#active-table tbody tr, #silenced-table tbody tr');

        // Count alerts per prometheus node
        rows.forEach(row => {
          const prom = row.dataset.prom;
          const timeStr = row.dataset.time;

          if (prom) {
            if (!this.promStats[prom]) {
              this.promStats[prom] = { count: 0, lastSeen: null };
            }
            this.promStats[prom].count++;
            if (timeStr) {
              const alertTime = new Date(timeStr.replace(' ', 'T'));
              if (!this.promStats[prom].lastSeen || alertTime > this.promStats[prom].lastSeen) {
                this.promStats[prom].lastSeen = alertTime;
              }
            }
          }
        });
      },

      open() {
        this.collectStats();
        this.render();
        document.getElementById('alert-managers-modal').classList.add('show');
      },

      close() {
        document.getElementById('alert-managers-modal').classList.remove('show');
      },

      render() {
        const amList = document.getElementById('am-list');
        const promList = document.getElementById('prom-list');
        const amCount = document.getElementById('am-total-count');
        const promCount = document.getElementById('prom-total-count');
        const totalAlerts = document.getElementById('am-total-alerts');

        // Render Alert Managers (simple list)
        amList.innerHTML = this.alertManagers.map(am => {
          const shortName = simplifyPromName(am);
          return `<span class="am-tag" title="${am}">${shortName}</span>`;
        }).join('');

        amCount.textContent = this.alertManagers.length;

        // Render Prometheus Nodes with alerts
        const promNodes = Object.keys(this.promStats);
        let totalAlertCount = 0;

        // Sort by alert count descending
        const sortedProms = promNodes.sort((a, b) => {
          return (this.promStats[b]?.count || 0) - (this.promStats[a]?.count || 0);
        });

        promList.innerHTML = sortedProms.map(prom => {
          const stat = this.promStats[prom];
          const shortName = simplifyPromName(prom);
          totalAlertCount += stat.count;

          return `
            <div class="prom-item" onclick="AlertManagersModal.filterByProm('${prom}')">
              <span class="prom-name" title="${prom}">${shortName}</span>
              <span class="prom-alert-count">${stat.count}</span>
            </div>
          `;
        }).join('');

        if (sortedProms.length === 0) {
          promList.innerHTML = '<div class="prom-empty">No active alerts from any Prometheus node</div>';
        }

        promCount.textContent = sortedProms.length;
        totalAlerts.textContent = totalAlertCount;

        // Update the card count
        const cardCount = document.getElementById('alert-managers-count');
        if (cardCount) cardCount.textContent = this.alertManagers.length;
      },

      filterByProm(prom) {
        this.close();

        // Set the prom filter and apply
        const promFilter = document.getElementById('filter-prom');
        if (promFilter) {
          promFilter.value = prom;
          FilterManager.apply();
        }

        showToast(`Filtered by ${simplifyPromName(prom)}`, 'success');
      }
    };

    // ========================================
    // INSIGHT CARDS
    // ========================================

    const InsightCards = {
      alertData: [],

      init() {
        // Insight cards are updated via updateInsightCards() called from updateMetrics()
      },

      update(alertData) {
        this.alertData = alertData;
        this.updateOldestAlerts();
        this.updateRecurringSystems();
        this.updateRecentAlerts();
        this.updateAffectedAccounts();
      },

      updateOldestAlerts() {
        const card = document.getElementById('oldest-alerts-card');
        const list = document.getElementById('oldest-alerts-list');
        const badge = document.getElementById('oldest-alerts-badge');

        if (this.alertData.length === 0) {
          card.classList.remove('show');
          return;
        }

        // Sort by duration descending and get top 5
        const sorted = [...this.alertData].sort((a, b) => b.duration - a.duration).slice(0, 5);

        // Only show if there are alerts > 1 hour old
        const oldAlerts = sorted.filter(a => a.duration >= 60 * 60 * 1000);
        if (oldAlerts.length === 0) {
          card.classList.remove('show');
          return;
        }

        badge.textContent = oldAlerts.length;
        list.innerHTML = oldAlerts.map((alert, i) => `
          <li class="insight-list-item" onclick="InsightCards.openAlert('${alert.hostname}')">
            <span class="insight-rank ${i === 0 ? 'top' : ''}">${i + 1}</span>
            <div class="insight-item-info">
              <div class="insight-item-primary">${alert.hostname}</div>
              <div class="insight-item-secondary">${alert.account}</div>
            </div>
            <span class="insight-item-value">${formatDuration(alert.duration)}</span>
            <button class="insight-filter-btn" onclick="event.stopPropagation(); InsightCards.filterByHostname('${alert.hostname}')">Filter</button>
          </li>
        `).join('');

        card.classList.add('show');
      },

      updateRecurringSystems() {
        const card = document.getElementById('recurring-systems-card');
        const list = document.getElementById('recurring-systems-list');
        const badge = document.getElementById('recurring-systems-badge');

        // Group alerts by hostname and count unique services
        const hostServices = {};
        this.alertData.forEach(alert => {
          if (!hostServices[alert.hostname]) {
            hostServices[alert.hostname] = {
              services: new Set(),
              account: alert.account,
              alertCount: 0
            };
          }
          alert.services.split(',').forEach(s => {
            if (s.trim()) hostServices[alert.hostname].services.add(s.trim());
          });
          hostServices[alert.hostname].alertCount++;
        });

        // Filter to hosts with 2+ services
        const recurring = Object.entries(hostServices)
          .filter(([_, data]) => data.services.size >= 2)
          .map(([hostname, data]) => ({
            hostname,
            account: data.account,
            serviceCount: data.services.size,
            services: Array.from(data.services).slice(0, 3).join(', ')
          }))
          .sort((a, b) => b.serviceCount - a.serviceCount)
          .slice(0, 5);

        if (recurring.length === 0) {
          card.classList.remove('show');
          return;
        }

        badge.textContent = recurring.length;
        list.innerHTML = recurring.map((item, i) => `
          <li class="insight-list-item" onclick="InsightCards.openAlert('${item.hostname}')">
            <span class="insight-rank ${i === 0 ? 'top' : ''}">${i + 1}</span>
            <div class="insight-item-info">
              <div class="insight-item-primary">${item.hostname}</div>
              <div class="insight-item-secondary">${item.services}${item.serviceCount > 3 ? '...' : ''}</div>
            </div>
            <span class="insight-item-value" style="color: var(--warning);">${item.serviceCount} svc</span>
            <button class="insight-filter-btn" onclick="event.stopPropagation(); InsightCards.filterByHostname('${item.hostname}')">Filter</button>
          </li>
        `).join('');

        card.classList.add('show');
      },

      updateRecentAlerts() {
        const card = document.getElementById('recent-alerts-card');
        const list = document.getElementById('recent-alerts-list');
        const badge = document.getElementById('recent-alerts-badge');

        if (this.alertData.length === 0) {
          card.classList.remove('show');
          return;
        }

        // Sort by time descending (most recent first) and get top 5
        const now = new Date();
        const oneHourAgo = new Date(now - 60 * 60 * 1000);
        const recentAlerts = [...this.alertData]
          .filter(a => a.time >= oneHourAgo)
          .sort((a, b) => b.time - a.time)
          .slice(0, 5);

        if (recentAlerts.length === 0) {
          card.classList.remove('show');
          return;
        }

        badge.textContent = recentAlerts.length;
        list.innerHTML = recentAlerts.map((alert, i) => {
          const ago = Math.floor((now - alert.time) / 60000); // minutes ago
          const agoStr = ago < 60 ? `${ago}m ago` : `${Math.floor(ago / 60)}h ago`;
          return `
            <li class="insight-list-item" onclick="InsightCards.openAlert('${alert.hostname}')">
              <span class="insight-rank ${i === 0 ? 'top' : ''}">${i + 1}</span>
              <div class="insight-item-info">
                <div class="insight-item-primary">${alert.hostname}</div>
                <div class="insight-item-secondary">${alert.services.split(',')[0] || 'alert'}</div>
              </div>
              <span class="insight-item-value info">${agoStr}</span>
              <button class="insight-filter-btn" onclick="event.stopPropagation(); InsightCards.filterByHostname('${alert.hostname}')">Filter</button>
            </li>
          `;
        }).join('');

        card.classList.add('show');
      },

      updateAffectedAccounts() {
        const card = document.getElementById('affected-accounts-card');
        const list = document.getElementById('affected-accounts-list');
        const badge = document.getElementById('affected-accounts-badge');

        if (this.alertData.length === 0) {
          card.classList.remove('show');
          return;
        }

        // Group by account
        const accountStats = {};
        this.alertData.forEach(alert => {
          if (!accountStats[alert.account]) {
            accountStats[alert.account] = { alertCount: 0, hosts: new Set() };
          }
          accountStats[alert.account].alertCount++;
          accountStats[alert.account].hosts.add(alert.hostname);
        });

        // Get top 5 by alert count
        const topAccounts = Object.entries(accountStats)
          .map(([account, data]) => ({
            account,
            alertCount: data.alertCount,
            hostCount: data.hosts.size
          }))
          .sort((a, b) => b.alertCount - a.alertCount)
          .slice(0, 5);

        if (topAccounts.length <= 1) {
          // Don't show if only 1 account (not interesting)
          card.classList.remove('show');
          return;
        }

        badge.textContent = topAccounts.length;
        list.innerHTML = topAccounts.map((item, i) => `
          <li class="insight-list-item" onclick="InsightCards.filterByAccount('${item.account}')">
            <span class="insight-rank ${i === 0 ? 'top' : ''}">${i + 1}</span>
            <div class="insight-item-info">
              <div class="insight-item-primary">${item.account}</div>
              <div class="insight-item-secondary">${item.hostCount} server${item.hostCount !== 1 ? 's' : ''}</div>
            </div>
            <span class="insight-item-value warning">${item.alertCount} alerts</span>
            <button class="insight-filter-btn" onclick="event.stopPropagation(); InsightCards.filterByAccount('${item.account}')">Filter</button>
          </li>
        `).join('');

        card.classList.add('show');
      },

      openAlert(hostname) {
        // Find the row and open the drawer
        const row = document.querySelector(`#active-table tbody tr .hostname`);
        const rows = document.querySelectorAll('#active-table tbody tr');
        for (const r of rows) {
          const hn = r.querySelector('.hostname')?.textContent.trim();
          if (hn === hostname) {
            AlertDrawer.openFromRow(r);
            return;
          }
        }
      },

      filterByHostname(hostname) {
        const searchBox = document.getElementById('search-box');
        searchBox.value = hostname;
        searchBox.dispatchEvent(new Event('input'));
        showToast(`Filtered by: ${hostname}`, 'success');
      },

      filterByAccount(account) {
        const searchBox = document.getElementById('search-box');
        searchBox.value = account;
        searchBox.dispatchEvent(new Event('input'));
        showToast(`Filtered by account: ${account}`, 'success');
      },

      sortByDuration() {
        sortTable('active-table', 11); // Duration column
        showToast('Sorted by duration', 'success');
      },

      sortByTime() {
        sortTable('active-table', 10); // Start Time column
        showToast('Sorted by start time', 'success');
      },

      sortByAccount() {
        sortTable('active-table', 2); // Account column
        showToast('Sorted by account', 'success');
      }
    };

    // ========================================
    // METRIC MODALS
    // ========================================

    const MetricModals = {
      alertData: [],
      oldestAlert: null,
      healthBreakdown: null,

      update(alertData) {
        this.alertData = alertData;
        if (alertData.length > 0) {
          this.oldestAlert = alertData.reduce((max, a) => a.duration > max.duration ? a : max);
        }
      },

      open(modalId) {
        document.getElementById(`${modalId}-modal`).classList.add('show');
      },

      close(modalId) {
        document.getElementById(`${modalId}-modal`).classList.remove('show');
      },

      openAvgDuration() {
        if (this.alertData.length === 0) {
          showToast('No active alerts', 'info');
          return;
        }

        const avgDuration = this.alertData.reduce((sum, a) => sum + a.duration, 0) / this.alertData.length;
        document.getElementById('modal-avg-duration').textContent = formatDuration(avgDuration);

        // Calculate distribution
        const buckets = {
          '< 1h': { count: 0, class: 'info' },
          '1-4h': { count: 0, class: 'info' },
          '4-12h': { count: 0, class: 'warning' },
          '12-24h': { count: 0, class: 'warning' },
          '> 24h': { count: 0, class: 'critical' }
        };

        this.alertData.forEach(a => {
          const hours = a.duration / (60 * 60 * 1000);
          if (hours < 1) buckets['< 1h'].count++;
          else if (hours < 4) buckets['1-4h'].count++;
          else if (hours < 12) buckets['4-12h'].count++;
          else if (hours < 24) buckets['12-24h'].count++;
          else buckets['> 24h'].count++;
        });

        const maxCount = Math.max(...Object.values(buckets).map(b => b.count), 1);
        const total = this.alertData.length;

        const distribution = document.getElementById('duration-distribution');
        distribution.innerHTML = Object.entries(buckets).map(([label, data]) => {
          const pct = Math.round((data.count / total) * 100);
          const width = Math.round((data.count / maxCount) * 100);
          return `
            <div class="metric-dist-row">
              <span class="metric-dist-label">${label}</span>
              <div class="metric-dist-bar-container">
                <div class="metric-dist-bar ${data.class}" style="width: ${Math.max(width, 5)}%"></div>
              </div>
              <span class="metric-dist-count">${data.count} (${pct}%)</span>
            </div>
          `;
        }).join('');

        this.open('avg-duration');
      },

      openOldestAlert() {
        if (!this.oldestAlert) {
          showToast('No active alerts', 'info');
          return;
        }

        document.getElementById('modal-oldest-duration').textContent = formatDuration(this.oldestAlert.duration);

        const details = document.getElementById('oldest-alert-details');
        details.innerHTML = `
          <li class="metric-detail-item">
            <span class="metric-detail-name">Hostname</span>
            <span class="metric-detail-value">${this.oldestAlert.hostname}</span>
          </li>
          <li class="metric-detail-item">
            <span class="metric-detail-name">Account</span>
            <span class="metric-detail-value">${this.oldestAlert.account}</span>
          </li>
          <li class="metric-detail-item">
            <span class="metric-detail-name">Services</span>
            <span class="metric-detail-value">${this.oldestAlert.services || '--'}</span>
          </li>
          <li class="metric-detail-item">
            <span class="metric-detail-name">Location</span>
            <span class="metric-detail-value">${this.oldestAlert.location || '--'}</span>
          </li>
          <li class="metric-detail-item">
            <span class="metric-detail-name">Started</span>
            <span class="metric-detail-value">${this.oldestAlert.time.toLocaleString()}</span>
          </li>
          <li class="metric-detail-item">
            <span class="metric-detail-name">Prom Node</span>
            <span class="metric-detail-value">${this.oldestAlert.prom || '--'}</span>
          </li>
        `;

        this.open('oldest-alert');
      },

      openVelocity() {
        const rangeMs = TimeRangeManager.getRangeMs();
        const now = new Date();
        const rangeStart = new Date(now - rangeMs);

        const recentAlerts = this.alertData.filter(a => a.time >= rangeStart);
        document.getElementById('modal-velocity-count').textContent = recentAlerts.length;

        // Time breakdown by hour buckets
        const buckets = {};
        const bucketSize = rangeMs > 24 * 60 * 60 * 1000 ? 6 : (rangeMs > 6 * 60 * 60 * 1000 ? 1 : 0.25); // hours per bucket

        recentAlerts.forEach(a => {
          const hoursAgo = Math.floor((now - a.time) / (bucketSize * 60 * 60 * 1000));
          const label = bucketSize >= 1
            ? `${hoursAgo * bucketSize}-${(hoursAgo + 1) * bucketSize}h ago`
            : `${hoursAgo * bucketSize * 60}-${(hoursAgo + 1) * bucketSize * 60}m ago`;
          buckets[label] = (buckets[label] || 0) + 1;
        });

        const breakdown = document.getElementById('velocity-breakdown');
        const entries = Object.entries(buckets).slice(0, 8);

        if (entries.length === 0) {
          breakdown.innerHTML = '<li class="metric-detail-item"><span class="metric-detail-name">No alerts in this period</span></li>';
        } else {
          breakdown.innerHTML = entries.map(([label, count]) => `
            <li class="metric-detail-item">
              <span class="metric-detail-name">${label}</span>
              <span class="metric-detail-value">${count} alert${count !== 1 ? 's' : ''}</span>
            </li>
          `).join('');
        }

        this.open('velocity');
      },

      openRecurring() {
        // Group by hostname
        const hostServices = {};
        this.alertData.forEach(alert => {
          if (!hostServices[alert.hostname]) {
            hostServices[alert.hostname] = { services: new Set(), account: alert.account };
          }
          alert.services.split(',').forEach(s => {
            if (s.trim()) hostServices[alert.hostname].services.add(s.trim());
          });
        });

        const recurring = Object.entries(hostServices)
          .filter(([_, data]) => data.services.size >= 2)
          .map(([hostname, data]) => ({
            hostname,
            account: data.account,
            serviceCount: data.services.size,
            services: Array.from(data.services)
          }))
          .sort((a, b) => b.serviceCount - a.serviceCount);

        document.getElementById('modal-recurring-count').textContent = recurring.length;

        const details = document.getElementById('recurring-systems-details');
        if (recurring.length === 0) {
          details.innerHTML = '<li class="metric-detail-item"><span class="metric-detail-name">No recurring systems detected</span></li>';
        } else {
          details.innerHTML = recurring.slice(0, 10).map(item => `
            <li class="metric-detail-item" style="cursor: pointer;" onclick="InsightCards.filterByHostname('${item.hostname}'); MetricModals.close('recurring');">
              <span class="metric-detail-name">${item.hostname}</span>
              <span class="metric-detail-value">${item.serviceCount} services</span>
            </li>
          `).join('');
        }

        this.open('recurring');
      },

      openHealthScore() {
        const breakdown = this.calculateHealthBreakdown();

        document.getElementById('modal-health-score').textContent = breakdown.score;

        // Update icon color based on score
        const icon = document.getElementById('health-modal-icon');
        icon.className = 'metric-modal-icon';
        if (breakdown.score >= 80) icon.classList.add('healthy');
        else if (breakdown.score >= 50) icon.classList.add('warning');
        else icon.classList.add('critical');

        const breakdownEl = document.getElementById('health-breakdown');
        breakdownEl.innerHTML = breakdown.items.map(item => `
          <div class="health-item">
            <span class="health-item-label">${item.label}</span>
            <span class="health-item-detail">${item.detail}</span>
            <span class="health-item-impact ${item.impact === 0 ? 'none' : ''}">${item.impact === 0 ? '+0' : '-' + item.impact}</span>
          </div>
        `).join('');

        const finalEl = document.getElementById('health-final-value');
        finalEl.textContent = breakdown.score;
        finalEl.className = 'health-final-score';
        if (breakdown.score >= 80) finalEl.classList.add('healthy');
        else if (breakdown.score >= 50) finalEl.classList.add('warning');
        else finalEl.classList.add('critical');

        this.open('health-score');
      },

      calculateHealthBreakdown() {
        let score = 100;
        const items = [];

        // Alert count deduction
        const alertCount = this.alertData.length;
        const alertDeduction = Math.min(alertCount * 2, 30);
        score -= alertDeduction;
        items.push({
          label: 'Alert Count',
          detail: `${alertCount} alerts`,
          impact: alertDeduction
        });

        // Long-running alerts
        const longRunning = this.alertData.filter(a => a.duration >= 60 * 60 * 1000).length;
        const longDeduction = Math.min(longRunning * 5, 20);
        score -= longDeduction;
        items.push({
          label: 'Long-running (>1h)',
          detail: `${longRunning} alerts`,
          impact: longDeduction
        });

        // Recurring systems
        const hostServices = {};
        this.alertData.forEach(a => {
          if (!hostServices[a.hostname]) hostServices[a.hostname] = new Set();
          a.services.split(',').forEach(s => { if (s.trim()) hostServices[a.hostname].add(s.trim()); });
        });
        const recurringCount = Object.values(hostServices).filter(s => s.size >= 2).length;
        const recurringDeduction = Math.min(recurringCount * 5, 20);
        score -= recurringDeduction;
        items.push({
          label: 'Recurring Systems',
          detail: `${recurringCount} systems`,
          impact: recurringDeduction
        });

        // Recent velocity
        const now = new Date();
        const oneHourAgo = new Date(now - 60 * 60 * 1000);
        const recentCount = this.alertData.filter(a => a.time >= oneHourAgo).length;
        const velocityDeduction = Math.min(recentCount * 3, 15);
        score -= velocityDeduction;
        items.push({
          label: 'Recent Alerts (1h)',
          detail: `${recentCount} alerts`,
          impact: velocityDeduction
        });

        // Incidents
        const incidentCount = parseInt(document.getElementById('incidents-count')?.textContent || '0');
        const incidentDeduction = Math.min(incidentCount * 3, 15);
        score -= incidentDeduction;
        items.push({
          label: 'Active Incidents',
          detail: `${incidentCount} incidents`,
          impact: incidentDeduction
        });

        return { score: Math.max(0, score), items };
      },

      filterOldestAlert() {
        if (this.oldestAlert) {
          InsightCards.filterByHostname(this.oldestAlert.hostname);
          this.close('oldest-alert');
        }
      },

      silenceOldestAlert() {
        if (this.oldestAlert) {
          // Find the row and trigger silence
          const rows = document.querySelectorAll('#active-table tbody tr');
          for (const row of rows) {
            const hn = row.querySelector('.hostname')?.textContent.trim();
            if (hn === this.oldestAlert.hostname) {
              const btn = row.querySelector('.silence-btn');
              if (btn) btn.click();
              this.close('oldest-alert');
              return;
            }
          }
        }
      },

      filterByDuration(range) {
        // Clear existing filters first
        const searchBox = document.getElementById('search-box');

        // Apply duration-based filtering via the time filter
        const timeFilter = document.getElementById('filter-time');
        if (timeFilter) {
          if (range === '1h') {
            // For < 1h, we just show recent
            timeFilter.value = '1h';
          } else if (range === '1h+') {
            // Long-running: > 1 hour - no direct filter, use search
            showToast('Showing long-running alerts (>1h)', 'info');
          }
          applyFilters();
        }
        this.close('avg-duration');
        showToast(`Filtering by duration: ${range}`, 'success');
      },

      filterByTimeRange(range) {
        const timeFilter = document.getElementById('filter-time');
        if (timeFilter) {
          timeFilter.value = range;
          applyFilters();
        }
        this.close('velocity');
        showToast(`Filtering by time range: ${range}`, 'success');
      }
    };

    // ========================================
    // VIEW PRESETS
    // ========================================

    const ViewPresets = {
      current: 'detailed',

      presets: {
        detailed: {
          name: 'Detailed',
          columns: ['checkbox', 'uid', 'account', 'hostname', 'datacenter', 'section', 'row', 'rack', 'location', 'prom', 'time', 'duration', 'services', 'actions']
        },
        compact: {
          name: 'Compact',
          columns: ['checkbox', 'hostname', 'services', 'duration', 'actions']
        },
        location: {
          name: 'Location Focus',
          columns: ['checkbox', 'hostname', 'datacenter', 'section', 'row', 'rack', 'duration', 'actions']
        },
        account: {
          name: 'Account Focus',
          columns: ['checkbox', 'account', 'hostname', 'services', 'duration', 'actions']
        },
        triage: {
          name: 'Triage',
          columns: ['checkbox', 'hostname', 'services', 'duration', 'prom', 'actions']
        }
      },

      columnIndexMap: {
        'checkbox': 0,
        'uid': 1,
        'account': 2,
        'hostname': 3,
        'datacenter': 4,
        'section': 5,
        'row': 6,
        'rack': 7,
        'location': 8,
        'prom': 9,
        'time': 10,
        'duration': 11,
        'services': 12,
        'actions': 13
      },

      init() {
        // Load saved preset
        const saved = localStorage.getItem('prometheos-view-preset');
        if (saved && this.presets[saved]) {
          this.current = saved;
          this.apply(saved, false);
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
          if (!e.target.closest('.view-presets-control')) {
            document.getElementById('view-presets-dropdown')?.classList.remove('show');
          }
        });
      },

      toggle() {
        const dropdown = document.getElementById('view-presets-dropdown');
        dropdown.classList.toggle('show');
      },

      apply(presetId, showToastMsg = true) {
        if (!this.presets[presetId]) return;

        this.current = presetId;
        localStorage.setItem('prometheos-view-preset', presetId);

        const preset = this.presets[presetId];
        const visibleColumns = new Set(preset.columns);

        // Update both active and silenced tables
        ['active-table', 'silenced-table'].forEach(tableId => {
          const table = document.getElementById(tableId);
          if (!table) return;

          // Update header visibility
          const headers = table.querySelectorAll('thead th');
          headers.forEach((th, i) => {
            const colName = Object.keys(this.columnIndexMap).find(k => this.columnIndexMap[k] === i);
            if (colName) {
              th.style.display = visibleColumns.has(colName) ? '' : 'none';
            }
          });

          // Update row cell visibility
          const rows = table.querySelectorAll('tbody tr');
          rows.forEach(row => {
            const cells = row.querySelectorAll('td');
            cells.forEach((td, i) => {
              const colName = Object.keys(this.columnIndexMap).find(k => this.columnIndexMap[k] === i);
              if (colName) {
                td.style.display = visibleColumns.has(colName) ? '' : 'none';
              }
            });
          });
        });

        // Update UI
        document.getElementById('view-preset-current').textContent = preset.name;

        // Update active state in dropdown
        document.querySelectorAll('.view-preset-option').forEach(opt => {
          opt.classList.toggle('active', opt.dataset.preset === presetId);
        });

        // Close dropdown
        document.getElementById('view-presets-dropdown')?.classList.remove('show');

        if (showToastMsg) {
          showToast(`View: ${preset.name}`, 'success');
        }
      }
    };

    // ========================================
    // EXPORT FUNCTIONALITY
    // ========================================

    const ExportManager = {
      init() {
        const exportBtn = document.getElementById('export-btn');
        const exportMenu = document.getElementById('export-menu');

        exportBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          exportMenu.classList.toggle('show');
        });

        document.addEventListener('click', () => {
          exportMenu.classList.remove('show');
        });
      }
    };

    function exportData(format) {
      const activePanel = document.querySelector('.tab-panel[style*="block"]') || document.getElementById('active');
      const table = activePanel.querySelector('.data-table');

      if (!table) return;

      const rows = table.querySelectorAll('tbody tr:not(.filtered-out)');
      const data = [];

      rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        data.push({
          uid: cells[1]?.textContent.trim() || '',
          account: cells[2]?.textContent.trim() || '',
          hostname: cells[3]?.textContent.trim() || '',
          datacenter: cells[4]?.textContent.trim() || '',
          section: cells[5]?.textContent.trim() || '',
          row: cells[6]?.textContent.trim() || '',
          rack: cells[7]?.textContent.trim() || '',
          location: cells[8]?.textContent.trim() || '',
          promNode: cells[9]?.textContent.trim() || '',
          startTime: cells[10]?.textContent.trim() || '',
          duration: cells[11]?.textContent.trim() || '',
          services: Array.from(cells[12]?.querySelectorAll('.service-tag') || []).map(t => t.textContent.trim())
        });
      });

      if (format === 'json') {
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        downloadBlob(blob, `prometheos-alerts-${new Date().toISOString().slice(0, 10)}.json`);
        showToast('Exported as JSON', 'success');
      } else if (format === 'csv') {
        let csv = 'UID,Account,Hostname,DC,Section,Row,Rack,Location,Prom Node,Start Time,Duration,Services\n';
        data.forEach(row => {
          csv += `"${row.uid}","${row.account}","${row.hostname}","${row.datacenter}","${row.section}","${row.row}","${row.rack}","${row.location}","${row.promNode}","${row.startTime}","${row.duration}","${row.services.join('; ')}"\n`;
        });
        const blob = new Blob([csv], { type: 'text/csv' });
        downloadBlob(blob, `prometheos-alerts-${new Date().toISOString().slice(0, 10)}.csv`);
        showToast('Exported as CSV', 'success');
      }

      document.getElementById('export-menu').classList.remove('show');
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // ========================================
    // DASHBOARD WIDGETS
    // ========================================

    function updateDashboardWidgets() {
      const rows = document.querySelectorAll('#active-table tbody tr:not(.filtered-out)');

      // Severity distribution (simulated based on service names)
      let critical = 0, warning = 0, info = 0;
      const serviceCounts = {};
      const locationCounts = {};

      rows.forEach(row => {
        const services = row.dataset.services ? row.dataset.services.split(',') : [];
        const location = row.dataset.location || 'Unknown';

        services.forEach(service => {
          if (service.trim()) {
            serviceCounts[service.trim()] = (serviceCounts[service.trim()] || 0) + 1;

            // Categorize by service name
            const s = service.toLowerCase();
            if (s.includes('critical') || s.includes('down') || s.includes('fail')) {
              critical++;
            } else if (s.includes('warn') || s.includes('high') || s.includes('load')) {
              warning++;
            } else {
              info++;
            }
          }
        });

        locationCounts[location] = (locationCounts[location] || 0) + 1;
      });

      // If no categorization, count all as critical
      if (critical === 0 && warning === 0 && info === 0) {
        critical = rows.length;
      }

      const total = critical + warning + info || 1;

      // Update severity bars
      document.getElementById('severity-critical').style.width = `${(critical / total) * 100}%`;
      document.getElementById('severity-warning').style.width = `${(warning / total) * 100}%`;
      document.getElementById('severity-info').style.width = `${(info / total) * 100}%`;

      document.getElementById('severity-critical-count').textContent = critical;
      document.getElementById('severity-warning-count').textContent = warning;
      document.getElementById('severity-info-count').textContent = info;

      // Update top services
      const topServices = Object.entries(serviceCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);

      const servicesContainer = document.getElementById('top-services');
      if (topServices.length > 0) {
        servicesContainer.innerHTML = topServices.map(([name, count]) => `
          <div class="service-row clickable" onclick="filterByService('${name.replace(/'/g, "\\'")}')">
            <span class="service-name">${name}</span>
            <span class="service-count-badge">${count}</span>
          </div>
        `).join('');
      } else {
        servicesContainer.innerHTML = `
          <div class="service-row">
            <span class="service-name">No active alerts</span>
            <span class="service-count-badge">0</span>
          </div>
        `;
      }

      // Update top locations
      const topLocations = Object.entries(locationCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);

      const locationsContainer = document.getElementById('top-locations');
      if (topLocations.length > 0) {
        locationsContainer.innerHTML = topLocations.map(([name, count]) => `
          <div class="location-row" onclick="filterByLocation('${name}')">
            <span class="location-name">${name}</span>
            <span class="location-count-badge">${count}</span>
          </div>
        `).join('');
      } else {
        locationsContainer.innerHTML = `
          <div class="location-row">
            <span class="location-name">No locations</span>
            <span class="location-count-badge">0</span>
          </div>
        `;
      }

      // Update advanced analytics
      updateAdvancedAnalytics();
    }

    function filterByLocation(location) {
      document.getElementById('filter-location').value = location;
      FilterManager.apply();

      // Open filters panel if not open
      const panel = document.getElementById('filters-panel');
      if (!panel.classList.contains('show')) {
        panel.classList.add('show');
      }

      showToast(`Filtered by location: ${location}`, 'success');
    }

    function filterByService(service) {
      document.getElementById('filter-service').value = service;
      FilterManager.apply();

      // Open filters panel if not open
      const panel = document.getElementById('filters-panel');
      if (!panel.classList.contains('show')) {
        panel.classList.add('show');
      }

      showToast(`Filtered by service: ${service}`, 'success');
    }

    function filterBySeverity(severity) {
      // Search for alerts matching severity keywords
      const searchBox = document.getElementById('search-box');
      let keywords = '';

      switch (severity) {
        case 'critical':
          keywords = 'critical down fail';
          break;
        case 'warning':
          keywords = 'warn high load';
          break;
        case 'info':
          // For info, we exclude critical and warning
          keywords = '!critical !down !fail !warn !high !load';
          break;
      }

      searchBox.value = keywords;
      searchBox.dispatchEvent(new Event('input'));
      showToast(`Showing ${severity} severity alerts`, 'success');
    }

    function filterByHostname(hostname) {
      const searchBox = document.getElementById('search-box');
      searchBox.value = hostname;
      searchBox.dispatchEvent(new Event('input'));
      showToast(`Filtered by hostname: ${hostname}`, 'success');
    }

    function filterByAccount(account) {
      // Search for the specific account
      const searchBox = document.getElementById('search-box');
      searchBox.value = account;
      searchBox.dispatchEvent(new Event('input'));
      showToast(`Filtered by account: ${account}`, 'success');
    }

    function filterRecurringSystems() {
      // Find hosts with 2+ services and filter to show them
      const rows = document.querySelectorAll('#active-table tbody tr');
      const hostServiceCounts = {};

      rows.forEach(row => {
        const hostname = row.querySelector('.hostname')?.textContent.trim();
        if (hostname) {
          const services = row.dataset.services ? row.dataset.services.split(',').filter(s => s.trim()) : [];
          hostServiceCounts[hostname] = (hostServiceCounts[hostname] || 0) + services.length;
        }
      });

      // Get recurring hosts (2+ services)
      const recurringHosts = Object.entries(hostServiceCounts)
        .filter(([_, count]) => count >= 2)
        .map(([host]) => host);

      if (recurringHosts.length > 0) {
        const searchBox = document.getElementById('search-box');
        searchBox.value = recurringHosts[0]; // Filter to first recurring host
        searchBox.dispatchEvent(new Event('input'));
        showToast(`Showing recurring system: ${recurringHosts[0]} (${recurringHosts.length} total)`, 'success');
      } else {
        showToast('No recurring systems found', 'info');
      }
    }

    function filterOldestAlert() {
      const hostname = document.getElementById('oldest-hostname').textContent;
      if (hostname && hostname !== '--') {
        filterByHostname(hostname);
      } else {
        showToast('No oldest alert to filter', 'info');
      }
    }

    // ========================================
    // ADVANCED ANALYTICS
    // ========================================

    function updateAdvancedAnalytics() {
      const rows = document.querySelectorAll('#active-table tbody tr:not(.filtered-out)');
      const now = new Date();

      // Collect alert data
      const alertData = [];
      rows.forEach(row => {
        const timeStr = row.dataset.time;
        if (timeStr) {
          const alertTime = new Date(timeStr.replace(' ', 'T'));
          const hostname = row.querySelector('.hostname')?.textContent.trim() || '';
          const account = row.querySelector('.cell-primary')?.textContent.trim() || '';
          const services = row.dataset.services || '';

          alertData.push({
            time: alertTime,
            hostname,
            account,
            services,
            duration: now - alertTime
          });
        }
      });

      // Update Quick Stats
      updateQuickStats(alertData, now);

      // Update Oldest Alert (legacy)
      updateOldestAlert(alertData);

      // Update Insight Cards and Metric Modals
      InsightCards.update(alertData);
      MetricModals.update(alertData);

      // Update Alert Velocity
      updateAlertVelocity(alertData, now);

      // Update Recurring Systems
      updateRecurringSystems(alertData);

      // Update Recurring Accounts
      updateRecurringAccounts(alertData);

      // Update Timeline
      updateAlertTimeline(alertData, now);
    }

    function formatDuration(ms) {
      const seconds = Math.floor(ms / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);

      if (days > 0) {
        return `${days}d ${hours % 24}h`;
      } else if (hours > 0) {
        return `${hours}h ${minutes % 60}m`;
      } else if (minutes > 0) {
        return `${minutes}m`;
      } else {
        return `${seconds}s`;
      }
    }

    function updateQuickStats(alertData, now) {
      // Average time open
      if (alertData.length > 0) {
        const avgDuration = alertData.reduce((sum, a) => sum + a.duration, 0) / alertData.length;
        document.getElementById('avg-alert-time').textContent = formatDuration(avgDuration);
      } else {
        document.getElementById('avg-alert-time').textContent = '--';
      }

      // Oldest alert time
      if (alertData.length > 0) {
        const oldest = alertData.reduce((max, a) => a.duration > max.duration ? a : max);
        document.getElementById('oldest-alert-time').textContent = formatDuration(oldest.duration);
      } else {
        document.getElementById('oldest-alert-time').textContent = '--';
      }

      // Alert velocity (alerts in selected time range)
      const rangeMs = TimeRangeManager.getRangeMs();
      const rangeStart = new Date(now - rangeMs);
      const recentAlerts = alertData.filter(a => a.time >= rangeStart).length;
      document.getElementById('alert-velocity').textContent = recentAlerts;

      // Recurring systems count (systems with 2+ services alerting)
      const systemServices = {};
      alertData.forEach(a => {
        if (!systemServices[a.hostname]) {
          systemServices[a.hostname] = new Set();
        }
        a.services.split(',').forEach(s => {
          if (s.trim()) systemServices[a.hostname].add(s.trim());
        });
      });
      const recurringCount = Object.values(systemServices).filter(s => s.size >= 2).length;
      document.getElementById('recurring-count').textContent = recurringCount;

      // Health Score
      const healthScore = calculateHealthScore(alertData);
      const healthEl = document.getElementById('health-score');
      if (healthEl) {
        healthEl.textContent = healthScore;
        // Color based on score
        const parentIcon = healthEl.closest('.quick-stat')?.querySelector('.quick-stat-icon');
        if (parentIcon) {
          if (healthScore >= 80) {
            parentIcon.style.background = 'var(--healthy-bg)';
            parentIcon.style.color = 'var(--healthy)';
          } else if (healthScore >= 50) {
            parentIcon.style.background = 'var(--warning-bg)';
            parentIcon.style.color = 'var(--warning)';
          } else {
            parentIcon.style.background = 'var(--critical-bg)';
            parentIcon.style.color = 'var(--critical)';
          }
        }
      }

      // Alert Trend indicator
      const trendEl = document.getElementById('alert-trend');
      if (trendEl) {
        // Compare current period vs previous period
        const halfRange = rangeMs / 2;
        const midPoint = new Date(now - halfRange);
        const currentPeriod = alertData.filter(a => a.time >= midPoint).length;
        const previousPeriod = alertData.filter(a => a.time < midPoint && a.time >= rangeStart).length;

        if (previousPeriod === 0) {
          trendEl.className = 'trend-indicator stable';
          trendEl.textContent = '—';
        } else {
          const changePercent = Math.round(((currentPeriod - previousPeriod) / previousPeriod) * 100);
          if (changePercent > 10) {
            trendEl.className = 'trend-indicator up';
            trendEl.textContent = `↑ ${changePercent}%`;
          } else if (changePercent < -10) {
            trendEl.className = 'trend-indicator down';
            trendEl.textContent = `↓ ${Math.abs(changePercent)}%`;
          } else {
            trendEl.className = 'trend-indicator stable';
            trendEl.textContent = '— stable';
          }
        }
      }

      // Update export counts
      IncidentManager.updateExportCounts();
    }

    function updateOldestAlert(alertData) {
      const card = document.getElementById('oldest-alert-card');

      if (alertData.length === 0) {
        card.classList.remove('show');
        return;
      }

      const oldest = alertData.reduce((max, a) => a.duration > max.duration ? a : max);

      // Only show if older than 1 hour
      if (oldest.duration < 60 * 60 * 1000) {
        card.classList.remove('show');
        return;
      }

      card.classList.add('show');
      document.getElementById('oldest-hostname').textContent = oldest.hostname;
      document.getElementById('oldest-account').textContent = oldest.account;
      document.getElementById('oldest-started').textContent = oldest.time.toLocaleString();
      document.getElementById('oldest-duration').textContent = formatDuration(oldest.duration);
    }

    function updateAlertVelocity(alertData, now) {
      const chartContainer = document.getElementById('velocity-chart');
      const rangeMs = TimeRangeManager.getRangeMs();
      const range = TimeRangeManager.current;

      // Determine bucket count and size based on range
      let bucketCount, bucketMs, labelInterval;
      if (range === '1h') {
        bucketCount = 12; // 5-minute buckets
        bucketMs = 5 * 60 * 1000;
        labelInterval = 3;
      } else if (range === '6h') {
        bucketCount = 12; // 30-minute buckets
        bucketMs = 30 * 60 * 1000;
        labelInterval = 2;
      } else if (range === '7d') {
        bucketCount = 14; // 12-hour buckets
        bucketMs = 12 * 60 * 60 * 1000;
        labelInterval = 2;
      } else {
        // 24h default
        bucketCount = 24; // 1-hour buckets
        bucketMs = 60 * 60 * 1000;
        labelInterval = 4;
      }

      // Generate buckets
      const buckets = [];
      for (let i = bucketCount - 1; i >= 0; i--) {
        const bucketStart = new Date(now - (i + 1) * bucketMs);
        const bucketEnd = new Date(now - i * bucketMs);
        const count = alertData.filter(a => a.time >= bucketStart && a.time < bucketEnd).length;

        let label = '';
        if (i % labelInterval === 0) {
          if (range === '7d') {
            label = bucketEnd.toLocaleDateString('en-US', { weekday: 'short' });
          } else {
            label = `${bucketEnd.getHours()}:00`;
          }
        }

        buckets.push({ label, count });
      }

      const maxCount = Math.max(...buckets.map(b => b.count), 1);
      const totalAlerts = buckets.reduce((sum, b) => sum + b.count, 0);
      const avgAlerts = (totalAlerts / bucketCount).toFixed(1);
      const peakAlerts = maxCount;

      // Update legend
      document.getElementById('velocity-peak').textContent = peakAlerts;
      document.getElementById('velocity-avg').textContent = avgAlerts;
      document.getElementById('velocity-total').textContent = totalAlerts;

      // Generate bars
      chartContainer.innerHTML = buckets.map((bucket, i) => {
        const height = (bucket.count / maxCount) * 100;
        return `
          <div class="velocity-bar-wrapper">
            <div class="velocity-bar" style="height: ${Math.max(height, 4)}%" data-count="${bucket.count}"></div>
            <span class="velocity-label">${bucket.label}</span>
          </div>
        `;
      }).join('');
    }

    function updateRecurringSystems(alertData) {
      const container = document.getElementById('recurring-systems');

      // Count services per system
      const systemData = {};
      alertData.forEach(a => {
        if (!systemData[a.hostname]) {
          systemData[a.hostname] = {
            hostname: a.hostname,
            account: a.account,
            services: new Set(),
            alertCount: 0
          };
        }
        systemData[a.hostname].alertCount++;
        a.services.split(',').forEach(s => {
          if (s.trim()) systemData[a.hostname].services.add(s.trim());
        });
      });

      // Filter to recurring (2+ services) and sort
      const recurring = Object.values(systemData)
        .filter(s => s.services.size >= 2)
        .sort((a, b) => b.services.size - a.services.size)
        .slice(0, 5);

      if (recurring.length === 0) {
        container.innerHTML = `
          <div class="widget-empty">
            <div class="widget-empty-icon">
              <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                <polyline points="22 4 12 14.01 9 11.01"></polyline>
              </svg>
            </div>
            <span class="widget-empty-text">No recurring patterns detected</span>
          </div>
        `;
        return;
      }

      container.innerHTML = recurring.map((sys, i) => {
        const severity = sys.services.size >= 4 ? '' : sys.services.size >= 3 ? 'warning' : 'info';
        return `
          <div class="recurring-item ${severity}" onclick="filterByHostname('${sys.hostname}')">
            <span class="recurring-rank">${i + 1}</span>
            <div class="recurring-info">
              <div class="recurring-name">${sys.hostname}</div>
              <div class="recurring-meta">${sys.account}</div>
            </div>
            <div class="recurring-count">
              <span class="recurring-count-value">${sys.services.size}</span>
              <span class="recurring-count-label">services</span>
            </div>
          </div>
        `;
      }).join('');
    }

    function updateRecurringAccounts(alertData) {
      const container = document.getElementById('recurring-accounts');

      // Count alerts per account
      const accountData = {};
      alertData.forEach(a => {
        if (!accountData[a.account]) {
          accountData[a.account] = {
            account: a.account,
            hosts: new Set(),
            alertCount: 0
          };
        }
        accountData[a.account].alertCount++;
        accountData[a.account].hosts.add(a.hostname);
      });

      // Filter to accounts with 2+ hosts and sort
      const recurring = Object.values(accountData)
        .filter(a => a.hosts.size >= 2)
        .sort((a, b) => b.hosts.size - a.hosts.size)
        .slice(0, 5);

      if (recurring.length === 0) {
        container.innerHTML = `
          <div class="widget-empty">
            <div class="widget-empty-icon">
              <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                <polyline points="22 4 12 14.01 9 11.01"></polyline>
              </svg>
            </div>
            <span class="widget-empty-text">No recurring patterns detected</span>
          </div>
        `;
        return;
      }

      container.innerHTML = recurring.map((acct, i) => {
        const severity = acct.hosts.size >= 5 ? '' : acct.hosts.size >= 3 ? 'warning' : 'info';
        return `
          <div class="recurring-item ${severity}" onclick="filterByAccount('${acct.account}')">
            <span class="recurring-rank">${i + 1}</span>
            <div class="recurring-info">
              <div class="recurring-name">${acct.account}</div>
              <div class="recurring-meta">${acct.alertCount} total alerts</div>
            </div>
            <div class="recurring-count">
              <span class="recurring-count-value">${acct.hosts.size}</span>
              <span class="recurring-count-label">hosts</span>
            </div>
          </div>
        `;
      }).join('');
    }

    function updateAlertTimeline(alertData, now) {
      const timeline = document.getElementById('alert-timeline');
      const timelineWidth = timeline.offsetWidth;

      if (alertData.length === 0) {
        timeline.innerHTML = '';
        return;
      }

      // Use selected time range
      const rangeMs = TimeRangeManager.getRangeMs();
      const startTime = new Date(now - rangeMs);

      const markers = alertData
        .filter(a => a.time >= startTime)
        .map(a => {
          const position = ((a.time - startTime) / rangeMs) * 100;
          return `
            <div class="timeline-marker" style="left: ${position}%">
              <div class="timeline-tooltip">
                <strong>${a.hostname}</strong><br>
                ${a.time.toLocaleTimeString()}<br>
                ${a.services.split(',').slice(0, 2).join(', ')}
              </div>
            </div>
          `;
        }).join('');

      timeline.innerHTML = markers;
    }

    function filterByHostname(hostname) {
      document.getElementById('search-box').value = hostname;
      document.getElementById('search-form').submit();
    }

    function filterByAccount(account) {
      document.getElementById('search-box').value = account;
      document.getElementById('search-form').submit();
    }

    // ========================================
    // DURATION CALCULATION
    // ========================================

    function updateDurations() {
      const now = new Date();
      document.querySelectorAll('.cell-duration').forEach(cell => {
        const startTimeStr = cell.dataset.startTime;
        if (!startTimeStr) return;

        const startTime = new Date(startTimeStr.replace(' ', 'T'));
        const diffMs = now - startTime;

        if (isNaN(diffMs) || diffMs < 0) {
          cell.querySelector('.duration-badge').textContent = '--';
          return;
        }

        const seconds = Math.floor(diffMs / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);

        let durationText;
        if (days > 0) {
          durationText = `${days}d ${hours % 24}h`;
        } else if (hours > 0) {
          durationText = `${hours}h ${minutes % 60}m`;
        } else if (minutes > 0) {
          durationText = `${minutes}m`;
        } else {
          durationText = `${seconds}s`;
        }

        const badge = cell.querySelector('.duration-badge');
        badge.textContent = durationText;

        // Color-code based on duration (skip if silenced)
        if (!badge.classList.contains('silenced')) {
          badge.classList.remove('short', 'medium', 'long');
          if (hours >= 24) {
            badge.classList.add('long');
          } else if (hours >= 1) {
            badge.classList.add('medium');
          } else {
            badge.classList.add('short');
          }
        }
      });
    }

    // ========================================
    // COUNT BADGES & EMPTY STATES
    // ========================================

    function updateCounts() {
      const activeTable = document.getElementById('active-table');
      const silencedTable = document.getElementById('silenced-table');

      const activeCount = activeTable ? activeTable.querySelectorAll('tbody tr:not(.filtered-out)').length : 0;
      const silencedCount = silencedTable ? silencedTable.querySelectorAll('tbody tr:not(.filtered-out)').length : 0;

      const activeBadge = document.getElementById('active-badge');
      const silencedBadge = document.getElementById('silenced-badge');
      const silencedCardCount = document.getElementById('silenced-count');

      if (activeBadge) activeBadge.textContent = activeCount;
      if (silencedBadge) silencedBadge.textContent = silencedCount;
      if (silencedCardCount) silencedCardCount.textContent = silencedCount;

      const activeEmpty = document.getElementById('active-empty');
      const silencedEmpty = document.getElementById('silenced-empty');
      const activeTableContainer = activeTable ? activeTable.closest('.table-container') : null;
      const silencedTableContainer = silencedTable ? silencedTable.closest('.table-container') : null;

      if (activeCount === 0) {
        if (activeTableContainer) activeTableContainer.style.display = 'none';
        if (activeEmpty) activeEmpty.style.display = 'block';
      } else {
        if (activeTableContainer) activeTableContainer.style.display = 'block';
        if (activeEmpty) activeEmpty.style.display = 'none';
      }

      if (silencedCount === 0) {
        if (silencedTableContainer) silencedTableContainer.style.display = 'none';
        if (silencedEmpty) silencedEmpty.style.display = 'block';
      } else {
        if (silencedTableContainer) silencedTableContainer.style.display = 'block';
        if (silencedEmpty) silencedEmpty.style.display = 'none';
      }

      // Update widgets
      updateDashboardWidgets();
    }

    // ========================================
    // TOAST NOTIFICATIONS
    // ========================================

    function showToast(message, type = 'success') {
      const container = document.getElementById('toast-container');
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          ${type === 'success' ?
            '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline>' :
            '<circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>'
          }
        </svg>
        <span>${message}</span>
      `;

      container.appendChild(toast);

      setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transform = 'translateX(20px)';
        setTimeout(() => toast.remove(), 200);
      }, 3000);
    }

    // ========================================
    // KEYBOARD NAVIGATION
    // ========================================

    document.addEventListener('keydown', function(e) {
      // Don't trigger shortcuts when typing in inputs
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
        if (e.key === 'Escape') {
          e.target.blur();
        }
        return;
      }

      // Alt+1 = Active tab, Alt+2 = Silenced tab
      if (e.altKey && e.key === '1') {
        e.preventDefault();
        document.querySelector('.tab-btn').click();
      }
      if (e.altKey && e.key === '2') {
        e.preventDefault();
        document.querySelectorAll('.tab-btn')[1].click();
      }

      // / to focus search
      if (e.key === '/' && !e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        document.getElementById('search-box').focus();
      }

      // ? to show shortcuts
      if (e.key === '?' || (e.shiftKey && e.key === '/')) {
        e.preventDefault();
        ShortcutsModal.toggle();
      }

      // F to toggle filters
      if (e.key === 'f' || e.key === 'F') {
        e.preventDefault();
        FilterManager.togglePanel();
      }

      // T to toggle theme
      if (e.key === 't' || e.key === 'T') {
        e.preventDefault();
        ThemeManager.toggle();
        showToast(`Switched to ${document.documentElement.getAttribute('data-theme')} mode`, 'success');
      }

      // R to refresh
      if (e.key === 'r' || e.key === 'R') {
        e.preventDefault();
        RefreshManager.refresh();
      }

      // Escape to close modals
      if (e.key === 'Escape') {
        ShortcutsModal.close();
        HelpModal.close();
        ColumnManager.close();
        AlertDrawer.close();
        MetricModals.close('avg-duration');
        MetricModals.close('oldest-alert');
        MetricModals.close('velocity');
        MetricModals.close('recurring');
        MetricModals.close('health-score');
        document.getElementById('filters-panel').classList.remove('show');
        document.getElementById('refresh-dropdown').classList.remove('show');
        document.getElementById('export-menu').classList.remove('show');
        document.getElementById('view-presets-dropdown')?.classList.remove('show');
      }

      // Ctrl+A to select all in current table
      if (e.ctrlKey && e.key === 'a') {
        e.preventDefault();
        const activePanel = document.querySelector('.tab-panel[style*="block"]') || document.getElementById('active');
        const headerCheckbox = activePanel.querySelector('.row-checkbox-header');
        if (headerCheckbox) {
          headerCheckbox.checked = true;
          headerCheckbox.dispatchEvent(new Event('change'));
        }
      }

      // O to open Oldest Alert modal
      if (e.key === 'o' || e.key === 'O') {
        e.preventDefault();
        MetricModals.openOldestAlert();
      }

      // G to open Health Score modal (G for "Good/bad" health)
      if (e.key === 'g' || e.key === 'G') {
        e.preventDefault();
        MetricModals.openHealthScore();
      }

      // V to open Velocity modal
      if (e.key === 'v' || e.key === 'V') {
        e.preventDefault();
        MetricModals.openVelocity();
      }

      // 1-5 to filter to top oldest alerts (when insight card visible)
      if (['1', '2', '3', '4', '5'].includes(e.key) && !e.altKey && !e.ctrlKey && !e.metaKey) {
        const oldestCard = document.getElementById('oldest-alerts-card');
        if (oldestCard?.classList.contains('show')) {
          const items = oldestCard.querySelectorAll('.insight-list-item');
          const index = parseInt(e.key) - 1;
          if (items[index]) {
            e.preventDefault();
            const hostname = items[index].querySelector('.insight-item-primary')?.textContent;
            if (hostname) {
              InsightCards.filterByHostname(hostname);
            }
          }
        }
      }

      // D to cycle through density modes
      if (e.key === 'd' || e.key === 'D') {
        e.preventDefault();
        const densities = ['compact', 'comfortable', 'spacious'];
        const currentIndex = densities.indexOf(DensityManager.current);
        const nextIndex = (currentIndex + 1) % densities.length;
        DensityManager.setDensity(densities[nextIndex]);
        showToast(`Switched to ${densities[nextIndex]} view`, 'success');
      }

      // C to open column configuration
      if (e.key === 'c' || e.key === 'C') {
        e.preventDefault();
        ColumnManager.open();
      }

      // H to open help
      if (e.key === 'h' || e.key === 'H') {
        e.preventDefault();
        HelpModal.toggle();
      }
    });

    // ========================================
    // SECTION COLLAPSE MANAGER
    // ========================================

    const SectionManager = {
      collapsed: {},
      // Sections that should be collapsed by default
      defaultCollapsed: ['distribution', 'metrics', 'charts', 'incidents'],

      init() {
        const saved = localStorage.getItem('prometheos-collapsed-sections');

        if (saved) {
          // Use saved preferences
          this.collapsed = JSON.parse(saved);
        } else {
          // First load: collapse all analytics sections by default
          this.defaultCollapsed.forEach(section => {
            this.collapsed[section] = true;
          });
        }

        // Apply states
        Object.keys(this.collapsed).forEach(section => {
          if (this.collapsed[section]) {
            this.setCollapsed(section, true, false);
          }
        });

        // Save initial state if first load
        if (!saved) {
          localStorage.setItem('prometheos-collapsed-sections', JSON.stringify(this.collapsed));
        }
      },

      toggle(section) {
        const isCollapsed = this.collapsed[section] || false;
        this.setCollapsed(section, !isCollapsed, true);
      },

      setCollapsed(section, collapsed, save = true) {
        const header = document.querySelector(`#${section}-section .section-header`);
        const content = document.getElementById(`${section}-content`);

        if (header && content) {
          header.classList.toggle('collapsed', collapsed);
          content.classList.toggle('collapsed', collapsed);
        }

        this.collapsed[section] = collapsed;

        if (save) {
          localStorage.setItem('prometheos-collapsed-sections', JSON.stringify(this.collapsed));
        }
      }
    };

    // ========================================
    // TIME RANGE MANAGER
    // ========================================

    const TimeRangeManager = {
      current: '24h',
      rangeMs: {
        '1h': 60 * 60 * 1000,
        '6h': 6 * 60 * 60 * 1000,
        '24h': 24 * 60 * 60 * 1000,
        '7d': 7 * 24 * 60 * 60 * 1000
      },

      init() {
        const saved = localStorage.getItem('prometheos-analytics-range');
        if (saved && this.rangeMs[saved]) {
          this.current = saved;
        }

        this.updateUI();
        this.bindEvents();
      },

      bindEvents() {
        document.querySelectorAll('.time-range-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const range = btn.dataset.range;
            this.setRange(range);
          });
        });
      },

      setRange(range) {
        this.current = range;
        localStorage.setItem('prometheos-analytics-range', range);
        this.updateUI();
        updateAdvancedAnalytics();
        showToast(`Analytics range set to ${this.getRangeLabel(range)}`, 'success');
      },

      updateUI() {
        document.querySelectorAll('.time-range-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.range === this.current);
        });

        // Update labels
        const velocityLabel = document.getElementById('velocity-range-label');
        if (velocityLabel) {
          velocityLabel.textContent = this.getRangeLabel(this.current);
        }

        const timelineStart = document.getElementById('timeline-start');
        if (timelineStart) {
          timelineStart.textContent = this.getRangeLabel(this.current) + ' ago';
        }
      },

      getRangeLabel(range) {
        const labels = { '1h': '1 hour', '6h': '6 hours', '24h': '24 hours', '7d': '7 days' };
        return labels[range] || range;
      },

      getRangeMs() {
        return this.rangeMs[this.current] || this.rangeMs['24h'];
      }
    };

    // ========================================
    // INCIDENT MANAGER - Infrastructure-Based Detection
    // ========================================

    const IncidentManager = {
      incidents: [],
      dismissedIncidents: [], // Track deleted incidents to prevent re-detection
      selectedAlerts: new Set(),
      windowMinutes: 5,
      CLUSTER_WINDOW_MS: 5 * 60 * 1000, // 5 minutes (default)
      minAlerts: 3,  // Minimum alerts to form an incident
      minHosts: 2,   // Minimum unique hosts to form an incident
      useCustomWindow: false, // Whether using custom date range
      customDateStart: null,  // Custom date range start
      customDateEnd: null,    // Custom date range end
      // Incident type filters - which types to detect
      enabledTypes: {
        rack: true,
        row: true,
        section: true,
        account: true
      },

      // Hostnames to exclude from account-based grouping (internal infrastructure)
      excludedHostnamePatterns: [
        /\.liquidweb\.com$/i,
        /\.nexcess\.net$/i,
        /^metalseed\./i
      ],

      init() {
        // Load saved window setting
        const savedWindow = localStorage.getItem('prometheos-incident-window');
        if (savedWindow === 'custom') {
          this.useCustomWindow = true;
          // Load saved date range
          const savedDateStart = localStorage.getItem('prometheos-incident-date-start');
          const savedDateEnd = localStorage.getItem('prometheos-incident-date-end');
          if (savedDateStart) this.customDateStart = new Date(savedDateStart);
          if (savedDateEnd) this.customDateEnd = new Date(savedDateEnd);
        } else if (savedWindow) {
          this.windowMinutes = parseInt(savedWindow) || 5;
          this.CLUSTER_WINDOW_MS = this.windowMinutes * 60 * 1000;
        }

        // Load saved threshold settings
        const savedMinAlerts = localStorage.getItem('prometheos-incident-min-alerts');
        const savedMinHosts = localStorage.getItem('prometheos-incident-min-hosts');
        if (savedMinAlerts) {
          if (savedMinAlerts === 'custom') {
            const customValue = localStorage.getItem('prometheos-incident-min-alerts-custom');
            this.minAlerts = parseInt(customValue) || 3;
          } else {
            this.minAlerts = parseInt(savedMinAlerts) || 3;
          }
        }
        if (savedMinHosts) {
          if (savedMinHosts === 'custom') {
            const customValue = localStorage.getItem('prometheos-incident-min-hosts-custom');
            this.minHosts = parseInt(customValue) || 2;
          } else {
            this.minHosts = parseInt(savedMinHosts) || 2;
          }
        }

        // Load saved type filters
        const savedTypes = localStorage.getItem('prometheos-incident-enabled-types');
        if (savedTypes) {
          try {
            this.enabledTypes = JSON.parse(savedTypes);
          } catch (e) {
            // Use defaults
          }
        }

        // Update select elements
        const windowSelect = document.getElementById('incident-window-select');
        if (windowSelect) {
          if (this.useCustomWindow) {
            windowSelect.value = 'custom';
          } else {
            windowSelect.value = this.windowMinutes.toString();
          }
        }

        // Show/hide date range picker
        this.updateDateRangeVisibility();

        // Update date inputs if we have saved values
        if (this.customDateStart) {
          const startInput = document.getElementById('incident-date-start');
          if (startInput) startInput.value = this.formatDateTimeLocal(this.customDateStart);
        }
        if (this.customDateEnd) {
          const endInput = document.getElementById('incident-date-end');
          if (endInput) endInput.value = this.formatDateTimeLocal(this.customDateEnd);
        }

        // Update min alerts select and custom input
        const minAlertsSelect = document.getElementById('incident-min-alerts');
        const minAlertsCustom = document.getElementById('incident-min-alerts-custom');
        const savedMinAlertsRaw = localStorage.getItem('prometheos-incident-min-alerts');
        if (savedMinAlertsRaw === 'custom') {
          if (minAlertsSelect) minAlertsSelect.value = 'custom';
          if (minAlertsCustom) {
            minAlertsCustom.style.display = 'block';
            minAlertsCustom.value = this.minAlerts;
          }
        } else if (minAlertsSelect) {
          // Check if value exists in options
          const options = Array.from(minAlertsSelect.options).map(o => o.value);
          if (options.includes(this.minAlerts.toString())) {
            minAlertsSelect.value = this.minAlerts.toString();
          } else {
            minAlertsSelect.value = 'custom';
            if (minAlertsCustom) {
              minAlertsCustom.style.display = 'block';
              minAlertsCustom.value = this.minAlerts;
            }
          }
        }

        // Update min hosts select and custom input
        const minHostsSelect = document.getElementById('incident-min-hosts');
        const minHostsCustom = document.getElementById('incident-min-hosts-custom');
        const savedMinHostsRaw = localStorage.getItem('prometheos-incident-min-hosts');
        if (savedMinHostsRaw === 'custom') {
          if (minHostsSelect) minHostsSelect.value = 'custom';
          if (minHostsCustom) {
            minHostsCustom.style.display = 'block';
            minHostsCustom.value = this.minHosts;
          }
        } else if (minHostsSelect) {
          // Check if value exists in options
          const options = Array.from(minHostsSelect.options).map(o => o.value);
          if (options.includes(this.minHosts.toString())) {
            minHostsSelect.value = this.minHosts.toString();
          } else {
            minHostsSelect.value = 'custom';
            if (minHostsCustom) {
              minHostsCustom.style.display = 'block';
              minHostsCustom.value = this.minHosts;
            }
          }
        }

        // Update type filter toggles
        this.updateTypeFilterUI();

        const saved = localStorage.getItem('prometheos-incidents');
        this.incidents = saved ? JSON.parse(saved) : [];

        // Load dismissed incidents
        const dismissed = localStorage.getItem('prometheos-dismissed-incidents');
        this.dismissedIncidents = dismissed ? JSON.parse(dismissed) : [];

        this.detectIncidents();
        this.render();
        this.updateExportCounts();
      },

      // Format date for datetime-local input
      formatDateTimeLocal(date) {
        const d = new Date(date);
        const year = d.getFullYear();
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        const hours = String(d.getHours()).padStart(2, '0');
        const minutes = String(d.getMinutes()).padStart(2, '0');
        return `${year}-${month}-${day}T${hours}:${minutes}`;
      },

      // Toggle incident type filter
      toggleType(type, element) {
        this.enabledTypes[type] = !this.enabledTypes[type];

        // Update UI
        if (this.enabledTypes[type]) {
          element.classList.add('active');
        } else {
          element.classList.remove('active');
        }

        // Save to localStorage
        localStorage.setItem('prometheos-incident-enabled-types', JSON.stringify(this.enabledTypes));

        // Rescan with new filters
        this.rescanWithMessage(`${type} detection ${this.enabledTypes[type] ? 'enabled' : 'disabled'}`);
      },

      // Update type filter UI from state
      updateTypeFilterUI() {
        ['rack', 'row', 'section', 'account'].forEach(type => {
          const toggle = document.getElementById(`incident-type-${type}`);
          if (toggle) {
            if (this.enabledTypes[type]) {
              toggle.classList.add('active');
            } else {
              toggle.classList.remove('active');
            }
          }
        });
      },

      // Show/hide date range picker based on window selection
      updateDateRangeVisibility() {
        const dateRange = document.getElementById('incident-date-range');
        if (dateRange) {
          if (this.useCustomWindow) {
            dateRange.classList.add('visible');
          } else {
            dateRange.classList.remove('visible');
          }
        }
      },

      // Set custom date range
      setDateRange() {
        const startInput = document.getElementById('incident-date-start');
        const endInput = document.getElementById('incident-date-end');

        if (startInput && startInput.value) {
          this.customDateStart = new Date(startInput.value);
          localStorage.setItem('prometheos-incident-date-start', this.customDateStart.toISOString());
        }
        if (endInput && endInput.value) {
          this.customDateEnd = new Date(endInput.value);
          localStorage.setItem('prometheos-incident-date-end', this.customDateEnd.toISOString());
        }

        if (this.customDateStart && this.customDateEnd) {
          this.rescanWithMessage('Custom date range updated');
        }
      },

      // Set custom min alerts value
      setMinAlertsCustom(value) {
        const count = parseInt(value) || 3;
        this.minAlerts = Math.max(1, count);
        localStorage.setItem('prometheos-incident-min-alerts', 'custom');
        localStorage.setItem('prometheos-incident-min-alerts-custom', this.minAlerts.toString());
        this.rescanWithMessage(`Min alerts changed to ${this.minAlerts}`);
      },

      // Set custom min hosts value
      setMinHostsCustom(value) {
        const count = parseInt(value) || 2;
        this.minHosts = Math.max(1, count);
        localStorage.setItem('prometheos-incident-min-hosts', 'custom');
        localStorage.setItem('prometheos-incident-min-hosts-custom', this.minHosts.toString());
        this.rescanWithMessage(`Min hosts changed to ${this.minHosts}`);
      },

      // Generate a signature for an incident to track dismissals
      getIncidentSignature(incident) {
        // Signature based on type + key (location or account)
        if (incident.type === 'account') {
          return `account:${incident.account}`;
        } else if (incident.locationKey) {
          return `${incident.type}:${incident.locationKey}`;
        }
        // Fallback: use sorted hostnames
        const hostnames = incident.alerts.map(a => a.hostname).sort().join(',');
        return `hosts:${hostnames}`;
      },

      // Check if an incident signature is dismissed
      isIncidentDismissed(signature) {
        return this.dismissedIncidents.includes(signature);
      },

      // Dismiss an incident by its signature
      dismissIncident(signature) {
        if (!this.dismissedIncidents.includes(signature)) {
          this.dismissedIncidents.push(signature);
          this.saveDismissed();
        }
      },

      // Clear all dismissed incidents (allows them to be re-detected)
      clearDismissed() {
        this.dismissedIncidents = [];
        this.saveDismissed();
        this.detectIncidents();
        this.render();
        showToast('Dismissed incidents cleared - they may reappear on next scan', 'info');
      },

      saveDismissed() {
        localStorage.setItem('prometheos-dismissed-incidents', JSON.stringify(this.dismissedIncidents));
      },

      // Parse location code: B3S2R9K8U27 -> { datacenter, section, row, rack, unit }
      parseLocation(location) {
        if (!location) return null;

        // Pattern: B{num}S{num}R{num}K{num}U{num}
        const match = location.match(/^B(\d+)S(\d+)R(\d+)K(\d+)(?:U(\d+))?$/i);
        if (!match) return null;

        return {
          datacenter: `B${match[1]}`,
          section: `B${match[1]}S${match[2]}`,
          row: `B${match[1]}S${match[2]}R${match[3]}`,
          rack: `B${match[1]}S${match[2]}R${match[3]}K${match[4]}`,
          unit: match[5] ? `B${match[1]}S${match[2]}R${match[3]}K${match[4]}U${match[5]}` : null,
          raw: location
        };
      },

      // Check if hostname should be excluded from account-based grouping
      isExcludedHostname(hostname) {
        return this.excludedHostnamePatterns.some(pattern => pattern.test(hostname));
      },

      setWindow(minutes) {
        if (minutes === 'custom') {
          this.useCustomWindow = true;
          localStorage.setItem('prometheos-incident-window', 'custom');
          this.updateDateRangeVisibility();
          // Initialize date range to now and 24 hours ago if not set
          if (!this.customDateStart || !this.customDateEnd) {
            const now = new Date();
            const dayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
            this.customDateEnd = now;
            this.customDateStart = dayAgo;
            const startInput = document.getElementById('incident-date-start');
            const endInput = document.getElementById('incident-date-end');
            if (startInput) startInput.value = this.formatDateTimeLocal(dayAgo);
            if (endInput) endInput.value = this.formatDateTimeLocal(now);
            localStorage.setItem('prometheos-incident-date-start', dayAgo.toISOString());
            localStorage.setItem('prometheos-incident-date-end', now.toISOString());
          }
          showToast('Custom date range enabled - select start and end dates', 'info');
          return;
        }

        this.useCustomWindow = false;
        this.windowMinutes = parseInt(minutes) || 5;
        this.CLUSTER_WINDOW_MS = this.windowMinutes * 60 * 1000;
        localStorage.setItem('prometheos-incident-window', this.windowMinutes.toString());
        this.updateDateRangeVisibility();
        this.rescanWithMessage(`Window changed to ${this.windowMinutes}min`);
      },

      setMinAlerts(count) {
        const minAlertsCustom = document.getElementById('incident-min-alerts-custom');

        if (count === 'custom') {
          if (minAlertsCustom) {
            minAlertsCustom.style.display = 'block';
            minAlertsCustom.value = this.minAlerts;
            minAlertsCustom.focus();
          }
          localStorage.setItem('prometheos-incident-min-alerts', 'custom');
          localStorage.setItem('prometheos-incident-min-alerts-custom', this.minAlerts.toString());
          return;
        }

        if (minAlertsCustom) {
          minAlertsCustom.style.display = 'none';
        }
        this.minAlerts = parseInt(count) || 3;
        localStorage.setItem('prometheos-incident-min-alerts', this.minAlerts.toString());
        this.rescanWithMessage(`Min alerts changed to ${this.minAlerts}`);
      },

      setMinHosts(count) {
        const minHostsCustom = document.getElementById('incident-min-hosts-custom');

        if (count === 'custom') {
          if (minHostsCustom) {
            minHostsCustom.style.display = 'block';
            minHostsCustom.value = this.minHosts;
            minHostsCustom.focus();
          }
          localStorage.setItem('prometheos-incident-min-hosts', 'custom');
          localStorage.setItem('prometheos-incident-min-hosts-custom', this.minHosts.toString());
          return;
        }

        if (minHostsCustom) {
          minHostsCustom.style.display = 'none';
        }
        this.minHosts = parseInt(count) || 2;
        localStorage.setItem('prometheos-incident-min-hosts', this.minHosts.toString());
        this.rescanWithMessage(`Min hosts changed to ${this.minHosts}`);
      },

      rescan() {
        this.rescanWithMessage('Manual rescan');
      },

      rescanWithMessage(reason) {
        const previousCount = this.incidents.length;
        const savedIncidents = this.incidents.filter(inc => this.isIncidentSaved(inc));
        const clearedCount = previousCount - savedIncidents.length;

        this.incidents = savedIncidents;
        this.detectIncidents();

        const newCount = this.incidents.length - savedIncidents.length;

        let message = reason ? `${reason}: ` : '';
        const parts = [];
        if (newCount > 0) parts.push(`${newCount} new`);
        if (clearedCount > 0) parts.push(`${clearedCount} cleared`);
        if (savedIncidents.length > 0) parts.push(`${savedIncidents.length} preserved`);

        message += parts.length > 0 ? parts.join(', ') : 'No incidents found';
        showToast(message, 'success');
      },

      isIncidentSaved(incident) {
        const autoGeneratedPrefixes = [
          'Rack Outage',
          'Row Outage',
          'Section Outage',
          'Datacenter Outage',
          'Account Outage',
          'Infrastructure Incident',
          'Manual Incident'
        ];
        const isAutoName = autoGeneratedPrefixes.some(prefix => incident.name.startsWith(prefix));

        // An incident is "saved" (should be preserved) if:
        // 1. It has notes
        // 2. Its name was manually changed
        // 3. Its status was changed from 'new' (meaning user acknowledged it)
        return (
          (incident.notes && incident.notes.length > 0) ||
          !isAutoName ||
          incident.status !== 'new'
        );
      },

      detectIncidents() {
        const rows = document.querySelectorAll('#active-table tbody tr:not(.filtered-out)');
        let alerts = [];

        // Collect all alerts with parsed location data
        rows.forEach(row => {
          const timeStr = row.dataset.time;
          const hostname = row.querySelector('.hostname')?.textContent.trim() || '';

          if (timeStr && hostname) {
            const location = row.dataset.location || '';
            const parsedLocation = this.parseLocation(location);

            alerts.push({
              id: hostname + '-' + timeStr,
              hostname: hostname,
              account: row.querySelector('.cell-primary')?.textContent.trim() || '',
              time: new Date(timeStr.replace(' ', 'T')),
              timeStr: timeStr,
              services: row.dataset.services || '',
              location: location,
              parsedLocation: parsedLocation,
              isExcluded: this.isExcludedHostname(hostname)
            });
          }
        });

        // Filter alerts by custom date range if using custom window mode
        if (this.useCustomWindow && this.customDateStart && this.customDateEnd) {
          alerts = alerts.filter(a => {
            return a.time >= this.customDateStart && a.time <= this.customDateEnd;
          });
        }

        // Group alerts by infrastructure hierarchy (rack > row > section > datacenter)
        // and by account for non-excluded hosts
        // IMPORTANT: Within each group, cluster by time window to avoid grouping unrelated alerts
        const newIncidents = [];

        // Helper to check if incident should be created (not dismissed and type enabled)
        const shouldCreateIncident = (type, key) => {
          // Check if type is enabled in filters
          if (!this.enabledTypes[type]) return false;
          const signature = type === 'account' ? `account:${key}` : `${type}:${key}`;
          return !this.isIncidentDismissed(signature);
        };

        // Helper to process a location group - clusters by time and creates incidents
        const processLocationGroup = (groupAlerts, type, key) => {
          if (!key || !shouldCreateIncident(type, key)) return [];

          // Cluster alerts within this location group by time window
          const timeClusters = this.clusterByTimeWindow(groupAlerts);
          const incidents = [];

          timeClusters.forEach(cluster => {
            if (this.meetsInfrastructureCriteria(cluster)) {
              incidents.push(this.createInfrastructureIncident(cluster, type, key));
            }
          });

          return incidents;
        };

        // 1. First, detect RACK-level incidents (highest priority)
        if (this.enabledTypes.rack) {
          const rackGroups = this.groupAlertsByKey(alerts, a => a.parsedLocation?.rack);
          rackGroups.forEach((groupAlerts, rack) => {
            const incidents = processLocationGroup(groupAlerts, 'rack', rack);
            newIncidents.push(...incidents);
          });
        }

        // Get alerts already in rack incidents to avoid double-counting
        const rackAlertIds = new Set(newIncidents.flatMap(i => i.alerts.map(a => a.id)));

        // 2. Detect ROW-level incidents (alerts not already in rack incidents)
        if (this.enabledTypes.row) {
          const remainingForRow = alerts.filter(a => !rackAlertIds.has(a.id));
          const rowGroups = this.groupAlertsByKey(remainingForRow, a => a.parsedLocation?.row);
          rowGroups.forEach((groupAlerts, row) => {
            const incidents = processLocationGroup(groupAlerts, 'row', row);
            newIncidents.push(...incidents);
          });
        }

        // Get alerts in rack or row incidents
        const infraAlertIds = new Set(newIncidents.flatMap(i => i.alerts.map(a => a.id)));

        // 3. Detect SECTION-level incidents
        if (this.enabledTypes.section) {
          const remainingForSection = alerts.filter(a => !infraAlertIds.has(a.id));
          const sectionGroups = this.groupAlertsByKey(remainingForSection, a => a.parsedLocation?.section);
          sectionGroups.forEach((groupAlerts, section) => {
            const incidents = processLocationGroup(groupAlerts, 'section', section);
            newIncidents.push(...incidents);
          });
        }

        // Update infraAlertIds
        const allInfraAlertIds = new Set(newIncidents.flatMap(i => i.alerts.map(a => a.id)));

        // 4. Detect ACCOUNT-based incidents (for non-excluded hosts not in infra incidents)
        if (this.enabledTypes.account) {
          const remainingForAccount = alerts.filter(a =>
            !allInfraAlertIds.has(a.id) && !a.isExcluded
          );
          const accountGroups = this.groupAlertsByKey(remainingForAccount, a => a.account);
          accountGroups.forEach((groupAlerts, account) => {
            if (!account || !shouldCreateIncident('account', account)) return;

            // Cluster by time window for account groups too
            const timeClusters = this.clusterByTimeWindow(groupAlerts);
            timeClusters.forEach(cluster => {
              if (this.meetsAccountCriteria(cluster)) {
                newIncidents.push(this.createAccountIncident(cluster, account));
              }
            });
          });
        }

        this.mergeIncidents(newIncidents);
        this.save();
        this.render();
        this.updateIncidentCounts();
      },

      groupAlertsByKey(alerts, keyFn) {
        const groups = new Map();
        alerts.forEach(alert => {
          const key = keyFn(alert);
          if (key) {
            if (!groups.has(key)) {
              groups.set(key, []);
            }
            groups.get(key).push(alert);
          }
        });
        return groups;
      },

      // Cluster alerts by time window - returns array of clusters
      clusterByTimeWindow(alerts) {
        if (alerts.length === 0) return [];

        // When using custom date range, treat all alerts in range as one cluster
        if (this.useCustomWindow) {
          return [alerts];
        }

        // Sort by time
        const sorted = [...alerts].sort((a, b) => a.time - b.time);
        const clusters = [];
        let currentCluster = [sorted[0]];

        for (let i = 1; i < sorted.length; i++) {
          const alert = sorted[i];
          const lastInCluster = currentCluster[currentCluster.length - 1];
          const timeDiff = alert.time - lastInCluster.time;

          if (timeDiff <= this.CLUSTER_WINDOW_MS) {
            currentCluster.push(alert);
          } else {
            clusters.push(currentCluster);
            currentCluster = [alert];
          }
        }

        // Don't forget the last cluster
        if (currentCluster.length > 0) {
          clusters.push(currentCluster);
        }

        return clusters;
      },

      meetsInfrastructureCriteria(alerts) {
        // For infrastructure incidents: need minimum alerts AND minimum hosts in same location
        const minAlerts = this.minAlerts || 3;
        const minHosts = this.minHosts || 2;
        const uniqueHosts = new Set(alerts.map(a => a.hostname)).size;
        return alerts.length >= minAlerts && uniqueHosts >= minHosts;
      },

      meetsAccountCriteria(alerts) {
        // For account incidents: need minimum alerts AND multiple hosts from same account
        const minAlerts = this.minAlerts || 3;
        const minHosts = this.minHosts || 2;
        const uniqueHosts = new Set(alerts.map(a => a.hostname)).size;
        return alerts.length >= minAlerts && uniqueHosts >= minHosts;
      },

      createInfrastructureIncident(alerts, level, locationKey) {
        const firstAlert = alerts.reduce((min, a) => a.time < min.time ? a : min);
        const lastAlert = alerts.reduce((max, a) => a.time > max.time ? a : max);
        const stats = this.getClusterStats(alerts);

        // Format level-appropriate name
        let levelLabel;
        switch (level) {
          case 'rack': levelLabel = 'Rack'; break;
          case 'row': levelLabel = 'Row'; break;
          case 'section': levelLabel = 'Section'; break;
          case 'datacenter': levelLabel = 'Datacenter'; break;
          default: levelLabel = 'Infrastructure';
        }

        const name = `${levelLabel} Outage: ${locationKey} (${stats.hostCount} hosts)`;

        return {
          id: Date.now() + Math.random().toString(36).substr(2, 9),
          name: name,
          type: level, // 'rack', 'row', 'section', 'datacenter'
          locationKey: locationKey,
          status: 'new',
          alerts: alerts,
          stats: stats,
          startTime: firstAlert.time.toISOString(),
          endTime: lastAlert.time.toISOString(),
          notes: [],
          createdAt: new Date().toISOString()
        };
      },

      createAccountIncident(alerts, account) {
        const firstAlert = alerts.reduce((min, a) => a.time < min.time ? a : min);
        const lastAlert = alerts.reduce((max, a) => a.time > max.time ? a : max);
        const stats = this.getClusterStats(alerts);

        const name = `Account Outage: ${account} (${stats.hostCount} hosts)`;

        return {
          id: Date.now() + Math.random().toString(36).substr(2, 9),
          name: name,
          type: 'account',
          account: account,
          status: 'new',
          alerts: alerts,
          stats: stats,
          startTime: firstAlert.time.toISOString(),
          endTime: lastAlert.time.toISOString(),
          notes: [],
          createdAt: new Date().toISOString()
        };
      },

      getClusterStats(cluster) {
        const uniqueHosts = new Set(cluster.map(a => a.hostname));
        const uniqueAccounts = new Set(cluster.map(a => a.account));
        const uniqueLocations = new Set(cluster.map(a => a.location).filter(l => l));

        return {
          alertCount: cluster.length,
          hostCount: uniqueHosts.size,
          accountCount: uniqueAccounts.size,
          locationCount: uniqueLocations.size,
          hosts: [...uniqueHosts],
          accounts: [...uniqueAccounts],
          locations: [...uniqueLocations]
        };
      },

      createFromAlerts(alertsData) {
        // Create incident from bulk-selected alerts
        const alerts = alertsData.map(a => ({
          id: a.hostname + '-' + a.time,
          hostname: a.hostname,
          account: a.account,
          time: new Date(a.time?.replace(' ', 'T') || Date.now()),
          timeStr: a.time,
          services: a.services,
          location: a.location
        }));

        alerts.sort((a, b) => a.time - b.time);

        const incident = {
          id: Date.now() + Math.random().toString(36).substr(2, 9),
          name: `Manual Incident ${new Date().toLocaleString()}`,
          status: 'investigating',
          alerts: alerts,
          startTime: alerts[0]?.time?.toISOString() || new Date().toISOString(),
          endTime: alerts[alerts.length - 1]?.time?.toISOString() || new Date().toISOString(),
          notes: [],
          createdAt: new Date().toISOString()
        };

        this.incidents.push(incident);
        this.save();
        this.render();
        this.updateIncidentCounts();

        // Expand incidents section
        SectionManager.setCollapsed('incidents', false);
      },

      mergeIncidents(newIncidents) {
        // Simple merge: keep existing incident data if alert IDs overlap
        const existingById = {};
        this.incidents.forEach(inc => {
          const alertIds = inc.alerts.map(a => a.id).join(',');
          existingById[alertIds] = inc;
        });

        this.incidents = newIncidents.map(newInc => {
          const alertIds = newInc.alerts.map(a => a.id).join(',');
          if (existingById[alertIds]) {
            // Preserve name, status, and notes from existing
            return {
              ...newInc,
              id: existingById[alertIds].id,
              name: existingById[alertIds].name,
              status: existingById[alertIds].status,
              notes: existingById[alertIds].notes
            };
          }
          return newInc;
        });
      },

      updateIncidentCounts() {
        const countEl = document.getElementById('incidents-count');
        const badgeEl = document.getElementById('incidents-badge');

        if (countEl) countEl.textContent = this.incidents.length;
        if (badgeEl) badgeEl.textContent = `${this.incidents.length} groups`;
      },

      updateExportCounts() {
        const activeRows = document.querySelectorAll('#active-table tbody tr:not(.filtered-out)');
        const csvCount = document.getElementById('export-csv-count');
        const jsonCount = document.getElementById('export-json-count');
        const incidentsCount = document.getElementById('export-incidents-count');

        if (csvCount) csvCount.textContent = `${activeRows.length} rows`;
        if (jsonCount) jsonCount.textContent = `${activeRows.length} rows`;
        if (incidentsCount) incidentsCount.textContent = `${this.incidents.length} incidents`;
      },

      render() {
        const container = document.getElementById('incidents-list');
        if (!container) return;

        if (this.incidents.length === 0) {
          container.innerHTML = `
            <div class="widget-empty">
              <div class="widget-empty-icon">
                <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                  <path d="M12 2L2 7l10 5 10-5-10-5z"></path>
                  <path d="M2 17l10 5 10-5"></path>
                  <path d="M2 12l10 5 10-5"></path>
                </svg>
              </div>
              <span class="widget-empty-text">No infrastructure incidents detected. Requires ${this.minHosts}+ hosts in same rack, row, section, or account.</span>
            </div>
          `;
          return;
        }

        container.innerHTML = this.incidents.map(incident => this.renderIncident(incident)).join('');
      },

      renderIncident(incident) {
        const alertCount = incident.alerts.length;
        const duration = new Date(incident.endTime) - new Date(incident.startTime);
        const durationStr = formatDuration(duration);

        // Get stats (either from stored stats or calculate)
        const stats = incident.stats || this.getClusterStats(incident.alerts);
        const hostCount = stats.hostCount || new Set(incident.alerts.map(a => a.hostname)).size;

        // Color based on incident type (infrastructure level)
        let severityClass = '';
        let typeLabel = '';
        switch (incident.type) {
          case 'rack':
            severityClass = ''; // Critical (red) - same rack is highest priority
            typeLabel = 'RACK';
            break;
          case 'row':
            severityClass = 'warning'; // Warning (orange)
            typeLabel = 'ROW';
            break;
          case 'section':
            severityClass = 'info'; // Info (cyan)
            typeLabel = 'SECTION';
            break;
          case 'account':
            severityClass = 'account'; // Purple
            typeLabel = 'ACCOUNT';
            break;
          default:
            severityClass = hostCount >= 5 ? '' : hostCount >= 3 ? 'warning' : 'info';
            typeLabel = 'INFRA';
        }

        return `
          <div class="incident-group" id="incident-${incident.id}" data-id="${incident.id}" data-type="${incident.type || 'unknown'}">
            <div class="incident-header" onclick="IncidentManager.toggleExpand('${incident.id}')">
              <div class="incident-expand-icon">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <polyline points="9 18 15 12 9 6"></polyline>
                </svg>
              </div>
              <div class="incident-color-bar ${severityClass}"></div>
              <div class="incident-info">
                <div class="incident-name-row">
                  <span class="incident-name" id="incident-name-${incident.id}">${this.escapeHtml(incident.name)}</span>
                  <button type="button" class="incident-edit-btn" onclick="event.stopPropagation(); IncidentManager.editName('${incident.id}')" title="Edit name">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                      <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                    </svg>
                  </button>
                  <span class="incident-status-badge ${incident.status}">${incident.status}</span>
                </div>
                <div class="incident-meta">
                  Started ${new Date(incident.startTime).toLocaleString()} &bull; Span: ${durationStr}
                </div>
              </div>
              <div class="incident-stats">
                <div class="incident-stat">
                  <div class="incident-stat-value">${hostCount}</div>
                  <div class="incident-stat-label">Hosts</div>
                </div>
                <div class="incident-stat">
                  <div class="incident-stat-value">${alertCount}</div>
                  <div class="incident-stat-label">Alerts</div>
                </div>
              </div>
              <div class="incident-actions">
                <div class="status-selector">
                  <button type="button" class="incident-action-btn" onclick="event.stopPropagation(); IncidentManager.toggleStatusDropdown('${incident.id}')" title="Change status">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <circle cx="12" cy="12" r="10"></circle>
                      <polyline points="12 6 12 12 16 14"></polyline>
                    </svg>
                  </button>
                  <div class="status-dropdown" id="status-dropdown-${incident.id}">
                    <div class="status-option" onclick="event.stopPropagation(); IncidentManager.setStatus('${incident.id}', 'new')">
                      <span class="status-dot new"></span>
                      <span>New</span>
                    </div>
                    <div class="status-option" onclick="event.stopPropagation(); IncidentManager.setStatus('${incident.id}', 'investigating')">
                      <span class="status-dot investigating"></span>
                      <span>Investigating</span>
                    </div>
                    <div class="status-option" onclick="event.stopPropagation(); IncidentManager.setStatus('${incident.id}', 'identified')">
                      <span class="status-dot identified"></span>
                      <span>Identified</span>
                    </div>
                    <div class="status-option" onclick="event.stopPropagation(); IncidentManager.setStatus('${incident.id}', 'monitoring')">
                      <span class="status-dot monitoring"></span>
                      <span>Monitoring</span>
                    </div>
                    <div class="status-option" onclick="event.stopPropagation(); IncidentManager.setStatus('${incident.id}', 'resolved')">
                      <span class="status-dot resolved"></span>
                      <span>Resolved</span>
                    </div>
                  </div>
                </div>
                <button type="button" class="incident-action-btn" onclick="event.stopPropagation(); IncidentManager.deleteIncident('${incident.id}')" title="Delete incident">
                  <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                  </svg>
                </button>
              </div>
            </div>
            <div class="incident-body">
              <div class="incident-alerts">
                ${incident.alerts.map(alert => `
                  <div class="incident-alert-item">
                    <div class="incident-alert-info">
                      <div class="incident-alert-hostname">${this.escapeHtml(alert.hostname)}</div>
                      <div class="incident-alert-meta">${this.escapeHtml(alert.account)} &bull; ${this.escapeHtml(alert.services.split(',').slice(0, 2).join(', '))}</div>
                    </div>
                    <div class="incident-alert-time">${alert.timeStr}</div>
                  </div>
                `).join('')}
              </div>
              <div class="incident-notes">
                <div class="incident-notes-header">
                  <span class="incident-notes-title">Notes & Annotations</span>
                </div>
                <div class="incident-notes-list" id="notes-list-${incident.id}">
                  ${incident.notes.length === 0 ? '' : incident.notes.map(note => `
                    <div class="incident-note">
                      <div class="incident-note-header">
                        <span class="incident-note-author">${this.escapeHtml(note.author || 'User')}</span>
                        <span class="incident-note-time">${new Date(note.createdAt).toLocaleString()}</span>
                      </div>
                      <div class="incident-note-text">${this.escapeHtml(note.text)}</div>
                    </div>
                  `).join('')}
                </div>
                <div class="incident-note-input">
                  <textarea class="incident-note-textarea" id="note-input-${incident.id}" placeholder="Add a note about this incident..."></textarea>
                  <button type="button" class="btn btn-sm btn-primary" onclick="IncidentManager.addNote('${incident.id}')">Add</button>
                </div>
              </div>
            </div>
          </div>
        `;
      },

      toggleExpand(id) {
        const el = document.getElementById(`incident-${id}`);
        if (el) {
          el.classList.toggle('expanded');
        }
      },

      toggleStatusDropdown(id) {
        // Close all other dropdowns first
        document.querySelectorAll('.status-dropdown.show').forEach(d => d.classList.remove('show'));

        const dropdown = document.getElementById(`status-dropdown-${id}`);
        if (dropdown) {
          dropdown.classList.toggle('show');
        }
      },

      setStatus(id, status) {
        const incident = this.incidents.find(i => i.id === id);
        if (incident) {
          incident.status = status;
          this.save();
          this.render();
          showToast(`Incident status set to ${status}`, 'success');
        }
      },

      editName(id) {
        const nameEl = document.getElementById(`incident-name-${id}`);
        if (!nameEl) return;

        const currentName = nameEl.textContent;
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'incident-name-input';
        input.value = currentName;

        const saveName = () => {
          const newName = input.value.trim() || currentName;
          const incident = this.incidents.find(i => i.id === id);
          if (incident) {
            incident.name = newName;
            this.save();
            this.render();
          }
        };

        input.addEventListener('blur', saveName);
        input.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            saveName();
          }
        });

        nameEl.replaceWith(input);
        input.focus();
        input.select();
      },

      addNote(id) {
        const input = document.getElementById(`note-input-${id}`);
        if (!input || !input.value.trim()) return;

        const incident = this.incidents.find(i => i.id === id);
        if (incident) {
          incident.notes.push({
            id: Date.now(),
            text: input.value.trim(),
            author: 'User',
            createdAt: new Date().toISOString()
          });
          this.save();
          this.render();
          showToast('Note added', 'success');

          // Re-expand the incident
          setTimeout(() => {
            const el = document.getElementById(`incident-${id}`);
            if (el) el.classList.add('expanded');
          }, 10);
        }
      },

      deleteIncident(id) {
        const incident = this.incidents.find(i => i.id === id);
        if (!incident) return;

        if (!confirm('Delete this incident grouping? It will not reappear on rescan. The alerts will remain but the grouping and notes will be lost.')) {
          return;
        }

        // Add to dismissed list so it won't be re-detected
        const signature = this.getIncidentSignature(incident);
        this.dismissIncident(signature);

        this.incidents = this.incidents.filter(i => i.id !== id);
        this.save();
        this.render();
        this.updateIncidentCounts();
        showToast('Incident deleted and dismissed', 'success');
      },

      save() {
        localStorage.setItem('prometheos-incidents', JSON.stringify(this.incidents));
      },

      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      },

      // Selection for manual incident creation
      toggleAlertSelection(alertId) {
        if (this.selectedAlerts.has(alertId)) {
          this.selectedAlerts.delete(alertId);
        } else {
          this.selectedAlerts.add(alertId);
        }
        this.updateSelectionUI();
      },

      updateSelectionUI() {
        const bar = document.getElementById('create-incident-bar');
        const countEl = document.getElementById('selected-for-incident');

        if (this.selectedAlerts.size > 0) {
          bar.classList.add('show');
          countEl.textContent = this.selectedAlerts.size;
        } else {
          bar.classList.remove('show');
        }
      },

      clearSelection() {
        this.selectedAlerts.clear();
        this.updateSelectionUI();
      },

      createFromSelection() {
        // Implementation for manual incident creation from selected alerts
        showToast('Manual incident creation - select alerts from the table first', 'info');
      }
    };

    // ========================================
    // ENHANCED EXPORT MANAGER
    // ========================================

    const ExportManagerEnhanced = {
      exportWithAnnotations(format) {
        const activePanel = document.querySelector('.tab-panel[style*="block"]') || document.getElementById('active');
        const table = activePanel.querySelector('.data-table');

        if (!table) return;

        const rows = table.querySelectorAll('tbody tr:not(.filtered-out)');
        const data = [];

        rows.forEach(row => {
          const cells = row.querySelectorAll('td');
          const hostname = cells[3]?.textContent.trim() || '';

          // Find if this alert is part of any incident
          let incidentName = '';
          let incidentStatus = '';
          let incidentNotes = [];

          IncidentManager.incidents.forEach(incident => {
            incident.alerts.forEach(alert => {
              if (alert.hostname === hostname) {
                incidentName = incident.name;
                incidentStatus = incident.status;
                incidentNotes = incident.notes.map(n => n.text);
              }
            });
          });

          data.push({
            uid: cells[1]?.textContent.trim() || '',
            account: cells[2]?.textContent.trim() || '',
            hostname: hostname,
            datacenter: cells[4]?.textContent.trim() || '',
            section: cells[5]?.textContent.trim() || '',
            row: cells[6]?.textContent.trim() || '',
            rack: cells[7]?.textContent.trim() || '',
            promNode: cells[8]?.textContent.trim() || '',
            startTime: cells[9]?.textContent.trim() || '',
            duration: cells[10]?.textContent.trim() || '',
            services: Array.from(cells[11]?.querySelectorAll('.service-tag') || []).map(t => t.textContent.trim()),
            incidentName: incidentName,
            incidentStatus: incidentStatus,
            notes: incidentNotes
          });
        });

        if (format === 'json') {
          const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
          downloadBlob(blob, `prometheos-alerts-annotated-${new Date().toISOString().slice(0, 10)}.json`);
          showToast('Exported with annotations as JSON', 'success');
        } else if (format === 'csv') {
          let csv = 'UID,Account,Hostname,DC,Section,Row,Rack,Prom Node,Start Time,Duration,Services,Incident,Status,Notes\n';
          data.forEach(row => {
            csv += `"${row.uid}","${row.account}","${row.hostname}","${row.datacenter}","${row.section}","${row.row}","${row.rack}","${row.promNode}","${row.startTime}","${row.duration}","${row.services.join('; ')}","${row.incidentName}","${row.incidentStatus}","${row.notes.join(' | ')}"\n`;
          });
          const blob = new Blob([csv], { type: 'text/csv' });
          downloadBlob(blob, `prometheos-alerts-annotated-${new Date().toISOString().slice(0, 10)}.csv`);
          showToast('Exported with annotations as CSV', 'success');
        }

        document.getElementById('export-menu').classList.remove('show');
      },

      exportIncidents(format) {
        const incidents = IncidentManager.incidents;

        if (incidents.length === 0) {
          showToast('No incidents to export', 'error');
          return;
        }

        const data = incidents.map(incident => ({
          id: incident.id,
          name: incident.name,
          status: incident.status,
          startTime: incident.startTime,
          endTime: incident.endTime,
          alertCount: incident.alerts.length,
          alerts: incident.alerts.map(a => ({
            hostname: a.hostname,
            account: a.account,
            time: a.timeStr,
            services: a.services
          })),
          notes: incident.notes.map(n => ({
            text: n.text,
            author: n.author,
            time: n.createdAt
          })),
          createdAt: incident.createdAt
        }));

        if (format === 'json') {
          const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
          downloadBlob(blob, `prometheos-incidents-${new Date().toISOString().slice(0, 10)}.json`);
          showToast('Incidents exported as JSON', 'success');
        } else if (format === 'csv') {
          let csv = 'Incident ID,Name,Status,Start Time,End Time,Alert Count,Hostnames,Notes\n';
          data.forEach(inc => {
            const hostnames = inc.alerts.map(a => a.hostname).join('; ');
            const notes = inc.notes.map(n => n.text).join(' | ');
            csv += `"${inc.id}","${inc.name}","${inc.status}","${inc.startTime}","${inc.endTime}","${inc.alertCount}","${hostnames}","${notes}"\n`;
          });
          const blob = new Blob([csv], { type: 'text/csv' });
          downloadBlob(blob, `prometheos-incidents-${new Date().toISOString().slice(0, 10)}.csv`);
          showToast('Incidents exported as CSV', 'success');
        }

        document.getElementById('export-menu').classList.remove('show');
      }
    };

    // Attach to ExportManager for button onclick handlers
    if (typeof ExportManager !== 'undefined') {
      ExportManager.exportWithAnnotations = ExportManagerEnhanced.exportWithAnnotations;
      ExportManager.exportIncidents = ExportManagerEnhanced.exportIncidents;
    }

    // ========================================
    // HEALTH SCORE CALCULATOR
    // ========================================

    function calculateHealthScore(alertData) {
      if (alertData.length === 0) return 100;

      const now = new Date();
      let score = 100;

      // Deduct points based on various factors
      // Alert count penalty (max -30)
      score -= Math.min(alertData.length * 2, 30);

      // Long-running alerts penalty (max -20)
      const longRunning = alertData.filter(a => a.duration > 60 * 60 * 1000).length;
      score -= Math.min(longRunning * 5, 20);

      // Recurring systems penalty (max -20)
      const systemCounts = {};
      alertData.forEach(a => {
        systemCounts[a.hostname] = (systemCounts[a.hostname] || 0) + 1;
      });
      const recurringCount = Object.values(systemCounts).filter(c => c >= 2).length;
      score -= Math.min(recurringCount * 5, 20);

      // Recent velocity penalty (max -15)
      const oneHourAgo = new Date(now - 60 * 60 * 1000);
      const recentAlerts = alertData.filter(a => a.time >= oneHourAgo).length;
      score -= Math.min(recentAlerts * 3, 15);

      // Incident count penalty (max -15)
      score -= Math.min(IncidentManager.incidents.length * 3, 15);

      return Math.max(0, Math.round(score));
    }

    // ========================================
    // DENSITY/VIEW MODE MANAGER
    // ========================================

    const DensityManager = {
      current: 'comfortable',

      init() {
        // Load saved density preference
        const savedDensity = localStorage.getItem('prometheos-density') || 'comfortable';
        this.setDensity(savedDensity);

        // Toggle dropdown
        const toggleBtn = document.getElementById('view-toggle-btn');
        const dropdown = document.getElementById('view-dropdown');

        if (toggleBtn && dropdown) {
          toggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            dropdown.classList.toggle('show');
          });

          // Option selection
          document.querySelectorAll('.view-option').forEach(option => {
            option.addEventListener('click', () => {
              const density = option.dataset.density;
              this.setDensity(density);
              dropdown.classList.remove('show');
              showToast(`Switched to ${density} view`, 'success');
            });
          });

          // Close on outside click
          document.addEventListener('click', () => {
            dropdown.classList.remove('show');
          });
        }
      },

      setDensity(density) {
        this.current = density;
        document.documentElement.setAttribute('data-density', density);
        localStorage.setItem('prometheos-density', density);

        // Update UI
        document.querySelectorAll('.view-option').forEach(option => {
          option.classList.toggle('selected', option.dataset.density === density);
        });
      }
    };

    // ========================================
    // SAVED FILTER PRESETS MANAGER
    // ========================================

    const PresetsManager = {
      presets: [],

      init() {
        // Load saved presets from localStorage
        const saved = localStorage.getItem('prometheos-filter-presets');
        this.presets = saved ? JSON.parse(saved) : [];

        this.render();
        this.bindEvents();
      },

      bindEvents() {
        const presetsBtn = document.getElementById('presets-btn');
        const presetsDropdown = document.getElementById('presets-dropdown');
        const presetNameInput = document.getElementById('preset-name-input');
        const savePresetBtn = document.getElementById('save-preset-btn');

        if (!presetsBtn || !presetsDropdown) return;

        // Toggle dropdown
        presetsBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          presetsDropdown.classList.toggle('show');
        });

        // Close on outside click
        document.addEventListener('click', (e) => {
          if (!presetsDropdown.contains(e.target)) {
            presetsDropdown.classList.remove('show');
          }
        });

        // Prevent dropdown from closing when clicking inside
        presetsDropdown.addEventListener('click', (e) => {
          e.stopPropagation();
        });

        // Enable/disable save button based on input
        if (presetNameInput && savePresetBtn) {
          presetNameInput.addEventListener('input', () => {
            const hasFilters = this.hasActiveFilters();
            const hasName = presetNameInput.value.trim().length > 0;
            savePresetBtn.disabled = !(hasFilters && hasName);
          });

          // Save preset on button click
          savePresetBtn.addEventListener('click', () => {
            this.saveCurrentFilters(presetNameInput.value.trim());
            presetNameInput.value = '';
            savePresetBtn.disabled = true;
          });

          // Save on Enter key
          presetNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !savePresetBtn.disabled) {
              this.saveCurrentFilters(presetNameInput.value.trim());
              presetNameInput.value = '';
              savePresetBtn.disabled = true;
            }
          });
        }
      },

      hasActiveFilters() {
        const location = document.getElementById('filter-location')?.value || '';
        const prom = document.getElementById('filter-prom')?.value || '';
        const time = document.getElementById('filter-time')?.value || '';
        const service = document.getElementById('filter-service')?.value || '';
        const search = document.getElementById('search-box')?.value || '';

        return location || prom || time || service || search;
      },

      getCurrentFilters() {
        return {
          location: document.getElementById('filter-location')?.value || '',
          prom: document.getElementById('filter-prom')?.value || '',
          time: document.getElementById('filter-time')?.value || '',
          service: document.getElementById('filter-service')?.value || '',
          search: document.getElementById('search-box')?.value || ''
        };
      },

      saveCurrentFilters(name) {
        if (!name || !this.hasActiveFilters()) return;

        const preset = {
          id: Date.now(),
          name: name,
          filters: this.getCurrentFilters(),
          createdAt: new Date().toISOString()
        };

        this.presets.unshift(preset);

        // Limit to 10 presets
        if (this.presets.length > 10) {
          this.presets = this.presets.slice(0, 10);
        }

        this.save();
        this.render();
        showToast(`Saved preset: ${name}`, 'success');
      },

      applyPreset(id) {
        const preset = this.presets.find(p => p.id === id);
        if (!preset) return;

        const filters = preset.filters;

        // Apply filter values
        if (document.getElementById('filter-location')) {
          document.getElementById('filter-location').value = filters.location || '';
        }
        if (document.getElementById('filter-prom')) {
          document.getElementById('filter-prom').value = filters.prom || '';
        }
        if (document.getElementById('filter-time')) {
          document.getElementById('filter-time').value = filters.time || '';
        }
        if (document.getElementById('filter-service')) {
          document.getElementById('filter-service').value = filters.service || '';
        }
        if (document.getElementById('search-box') && filters.search) {
          document.getElementById('search-box').value = filters.search;
        }

        // Apply the filters
        FilterManager.apply();

        // Close dropdown
        document.getElementById('presets-dropdown').classList.remove('show');

        showToast(`Applied preset: ${preset.name}`, 'success');
      },

      deletePreset(id) {
        this.presets = this.presets.filter(p => p.id !== id);
        this.save();
        this.render();
        showToast('Preset deleted', 'success');
      },

      save() {
        localStorage.setItem('prometheos-filter-presets', JSON.stringify(this.presets));
      },

      getFilterSummary(filters) {
        const parts = [];
        if (filters.location) parts.push(`Location: ${filters.location}`);
        if (filters.prom) parts.push(`Node: ${filters.prom}`);
        if (filters.time) parts.push(`Time: ${filters.time}`);
        if (filters.service) parts.push(`Service: ${filters.service}`);
        if (filters.search) parts.push(`Search: "${filters.search}"`);
        return parts.join(' | ') || 'No filters';
      },

      render() {
        const list = document.getElementById('presets-list');
        if (!list) return;

        if (this.presets.length === 0) {
          list.innerHTML = '<div class="presets-empty">No saved presets yet</div>';
          return;
        }

        list.innerHTML = this.presets.map(preset => `
          <div class="preset-item" data-id="${preset.id}">
            <div class="preset-info" onclick="PresetsManager.applyPreset(${preset.id})">
              <div class="preset-name">${this.escapeHtml(preset.name)}</div>
              <div class="preset-filters">${this.escapeHtml(this.getFilterSummary(preset.filters))}</div>
            </div>
            <div class="preset-actions">
              <button type="button" class="preset-action-btn delete" onclick="PresetsManager.deletePreset(${preset.id})" title="Delete preset">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <line x1="18" y1="6" x2="6" y2="18"></line>
                  <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
              </button>
            </div>
          </div>
        `).join('');
      },

      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
    };

    // ========================================
    // COLUMN MANAGER
    // ========================================

    const ColumnManager = {
      modal: null,
      columns: [],
      discoveredFields: { labels: [], annotations: [], core: [] },
      profiles: {
        default: ['checkbox', 'uid', 'account', 'hostname', 'datacenter', 'section', 'row', 'rack', 'location', 'prom', 'time', 'duration', 'services', 'actions'],
        compact: ['checkbox', 'hostname', 'account', 'services', 'time', 'actions'],
        detailed: ['checkbox', 'uid', 'account', 'hostname', 'datacenter', 'section', 'row', 'rack', 'location', 'prom', 'time', 'duration', 'services', 'actions'],
        custom: []
      },
      currentProfile: 'default',

      init() {
        this.modal = document.getElementById('column-config-modal');
        this.loadConfig();
        this.applyColumns();

        // Close modal on overlay click
        if (this.modal) {
          this.modal.addEventListener('click', (e) => {
            if (e.target === this.modal) this.close();
          });
        }

        // Keyboard shortcut
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && this.modal?.classList.contains('show')) {
            this.close();
          }
        });
      },

      loadConfig() {
        const saved = localStorage.getItem('prometheos_column_config');
        if (saved) {
          try {
            const config = JSON.parse(saved);
            this.columns = config.columns || this.profiles.default;
            this.currentProfile = config.profile || 'default';
            this.profiles.custom = config.customProfile || [];
            this.discoveredFields = config.discoveredFields || { labels: [], annotations: [], core: [] };
          } catch (e) {
            this.columns = [...this.profiles.default];
          }
        } else {
          this.columns = [...this.profiles.default];
        }
      },

      saveConfig() {
        localStorage.setItem('prometheos_column_config', JSON.stringify({
          columns: this.columns,
          profile: this.currentProfile,
          customProfile: this.profiles.custom,
          discoveredFields: this.discoveredFields
        }));
      },

      open() {
        if (!this.modal) return;
        this.renderVisibleColumns();
        this.renderApiFields();
        this.updatePreview();
        this.updateProfileButtons();
        this.modal.classList.add('show');
      },

      close() {
        if (this.modal) {
          this.modal.classList.remove('show');
        }
      },

      applyAndClose() {
        this.applyColumns();
        this.saveConfig();
        this.close();
      },

      renderVisibleColumns() {
        const list = document.getElementById('visible-columns-list');
        const countBadge = document.getElementById('visible-columns-count');
        if (!list) return;

        const allColumns = this.getAllColumnDefinitions();

        list.innerHTML = this.columns
          .filter(colId => colId !== 'checkbox' && colId !== 'actions')
          .map((colId, index) => {
            const col = allColumns.find(c => c.id === colId) || { id: colId, name: colId, source: 'custom' };
            return `
              <div class="column-item selected" data-column-id="${col.id}" draggable="true">
                <input type="checkbox" class="column-checkbox" checked onchange="ColumnManager.toggleColumn('${col.id}')">
                <div class="column-info">
                  <div class="column-name">${this.escapeHtml(col.name)}</div>
                  <div class="column-source">${col.source}</div>
                </div>
                <div class="column-drag-handle">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="8" y1="6" x2="16" y2="6"></line>
                    <line x1="8" y1="12" x2="16" y2="12"></line>
                    <line x1="8" y1="18" x2="16" y2="18"></line>
                  </svg>
                </div>
              </div>
            `;
          }).join('');

        // Add available but not visible columns
        const availableCols = allColumns.filter(col =>
          !this.columns.includes(col.id) && col.id !== 'checkbox' && col.id !== 'actions'
        );

        if (availableCols.length > 0) {
          list.innerHTML += availableCols.map(col => `
            <div class="column-item" data-column-id="${col.id}">
              <input type="checkbox" class="column-checkbox" onchange="ColumnManager.toggleColumn('${col.id}')">
              <div class="column-info">
                <div class="column-name">${this.escapeHtml(col.name)}</div>
                <div class="column-source">${col.source}</div>
              </div>
              <div class="column-drag-handle">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <line x1="8" y1="6" x2="16" y2="6"></line>
                  <line x1="8" y1="12" x2="16" y2="12"></line>
                  <line x1="8" y1="18" x2="16" y2="18"></line>
                </svg>
              </div>
            </div>
          `).join('');
        }

        if (countBadge) {
          countBadge.textContent = `${this.columns.length - 2} columns`; // -2 for checkbox and actions
        }

        this.initDragDrop();
      },

      getAllColumnDefinitions() {
        const defaultCols = [
          { id: 'uid', name: 'UID', source: 'core' },
          { id: 'account', name: 'Account', source: 'core' },
          { id: 'hostname', name: 'Hostname', source: 'core' },
          { id: 'datacenter', name: 'DC', source: 'core' },
          { id: 'section', name: 'Section', source: 'core' },
          { id: 'row', name: 'Row', source: 'core' },
          { id: 'rack', name: 'Rack', source: 'core' },
          { id: 'location', name: 'Location', source: 'core' },
          { id: 'prom', name: 'Prom Node', source: 'core' },
          { id: 'time', name: 'Start Time', source: 'core' },
          { id: 'duration', name: 'Duration', source: 'core' },
          { id: 'services', name: 'Services', source: 'core' }
        ];

        // Add discovered fields
        const labelCols = this.discoveredFields.labels.map(f => ({
          id: `label_${f.name}`, name: f.name, source: 'label'
        }));
        const annotationCols = this.discoveredFields.annotations.map(f => ({
          id: `annotation_${f.name}`, name: f.name, source: 'annotation'
        }));

        return [...defaultCols, ...labelCols, ...annotationCols];
      },

      toggleColumn(colId) {
        const idx = this.columns.indexOf(colId);
        if (idx > -1) {
          this.columns.splice(idx, 1);
        } else {
          // Insert before 'actions'
          const actionsIdx = this.columns.indexOf('actions');
          if (actionsIdx > -1) {
            this.columns.splice(actionsIdx, 0, colId);
          } else {
            this.columns.push(colId);
          }
        }
        this.currentProfile = 'custom';
        this.profiles.custom = [...this.columns];
        this.renderVisibleColumns();
        this.updatePreview();
        this.updateProfileButtons();
      },

      initDragDrop() {
        const list = document.getElementById('visible-columns-list');
        if (!list) return;

        const items = list.querySelectorAll('.column-item[draggable="true"]');
        items.forEach(item => {
          item.addEventListener('dragstart', (e) => {
            item.classList.add('dragging');
            e.dataTransfer.setData('text/plain', item.dataset.columnId);
          });
          item.addEventListener('dragend', () => {
            item.classList.remove('dragging');
          });
          item.addEventListener('dragover', (e) => {
            e.preventDefault();
            const dragging = list.querySelector('.dragging');
            if (dragging && item !== dragging) {
              const rect = item.getBoundingClientRect();
              const midY = rect.top + rect.height / 2;
              if (e.clientY < midY) {
                item.parentNode.insertBefore(dragging, item);
              } else {
                item.parentNode.insertBefore(dragging, item.nextSibling);
              }
            }
          });
          item.addEventListener('drop', () => {
            this.updateColumnOrder();
          });
        });
      },

      updateColumnOrder() {
        const list = document.getElementById('visible-columns-list');
        if (!list) return;

        const newOrder = ['checkbox'];
        list.querySelectorAll('.column-item.selected').forEach(item => {
          newOrder.push(item.dataset.columnId);
        });
        newOrder.push('actions');

        this.columns = newOrder;
        this.currentProfile = 'custom';
        this.profiles.custom = [...this.columns];
        this.updatePreview();
        this.updateProfileButtons();
      },

      renderApiFields() {
        // Update field grids
        ['labels', 'annotations', 'core'].forEach(type => {
          const grid = document.getElementById(`${type === 'labels' ? 'label' : type === 'annotations' ? 'annotation' : type}-fields-grid`);
          const count = document.getElementById(`${type === 'labels' ? 'label' : type === 'annotations' ? 'annotation' : type}-fields-count`);

          if (!grid) return;

          const fields = type === 'core' ? this.getCoreFields() : this.discoveredFields[type];

          if (count) count.textContent = fields.length;

          if (fields.length === 0) {
            grid.innerHTML = '<div class="api-fields-empty">Click "Discover Fields" to scan for available fields</div>';
            return;
          }

          grid.innerHTML = fields.map(field => {
            const colId = type === 'core' ? field.id : `${type === 'labels' ? 'label' : 'annotation'}_${field.name}`;
            const isAdded = this.columns.includes(colId);
            return `
              <div class="api-field-card ${isAdded ? 'added' : ''}" data-field-id="${colId}">
                <div class="api-field-header">
                  <span class="api-field-name">${this.escapeHtml(field.name)}</span>
                  <span class="api-field-type ${type === 'labels' ? 'label' : type === 'annotations' ? 'annotation' : 'core'}">${type === 'labels' ? 'Label' : type === 'annotations' ? 'Ann.' : 'Core'}</span>
                </div>
                ${field.sample ? `<div class="api-field-sample" title="${this.escapeHtml(field.sample)}">${this.escapeHtml(field.sample.substring(0, 40))}${field.sample.length > 40 ? '...' : ''}</div>` : ''}
                <div class="api-field-actions">
                  <button type="button" class="btn-add-column" ${isAdded ? 'disabled' : ''} onclick="ColumnManager.addFieldAsColumn('${colId}', '${this.escapeHtml(field.name)}', '${type}')">
                    ${isAdded ? 'Added' : 'Add Column'}
                  </button>
                </div>
              </div>
            `;
          }).join('');
        });
      },

      getCoreFields() {
        return [
          { id: 'uid', name: 'UID', sample: 'ABC123' },
          { id: 'account', name: 'Account', sample: 'Production' },
          { id: 'hostname', name: 'Hostname', sample: 'web-server-01' },
          { id: 'datacenter', name: 'DC', sample: 'B3' },
          { id: 'section', name: 'Section', sample: 'S2' },
          { id: 'row', name: 'Row', sample: 'R9' },
          { id: 'rack', name: 'Rack', sample: 'K8' },
          { id: 'location', name: 'Location', sample: 'B3-S2-R9-K8' },
          { id: 'prom', name: 'Prom Node', sample: 'prometheus-1' },
          { id: 'time', name: 'Start Time', sample: '2024-01-15 10:30' },
          { id: 'duration', name: 'Duration', sample: '2h 15m' },
          { id: 'services', name: 'Services', sample: 'nginx, php-fpm' }
        ];
      },

      async discoverFields() {
        const statusDot = document.getElementById('api-status-dot');
        const statusText = document.getElementById('api-status-text');
        const endpointInput = document.getElementById('api-endpoint');

        if (statusDot) statusDot.classList.add('loading');
        if (statusText) statusText.textContent = 'Scanning...';

        try {
          // Discover fields from current table data
          const labels = new Map();
          const annotations = new Map();

          // Scan table rows for data attributes
          document.querySelectorAll('.alert-row').forEach(row => {
            // Get all data attributes
            Object.keys(row.dataset).forEach(key => {
              const value = row.dataset[key];
              if (value && key !== 'uid') {
                if (!labels.has(key)) {
                  labels.set(key, { name: key, sample: value, count: 1 });
                } else {
                  labels.get(key).count++;
                }
              }
            });
          });

          // Check for additional fields in cells
          document.querySelectorAll('.alert-row td[data-field]').forEach(cell => {
            const field = cell.dataset.field;
            const value = cell.textContent.trim();
            if (field && value) {
              if (!labels.has(field)) {
                labels.set(field, { name: field, sample: value, count: 1 });
              }
            }
          });

          // Simulated additional AlertManager fields that might be available
          const commonLabels = [
            { name: 'alertname', sample: 'HighCPUUsage' },
            { name: 'severity', sample: 'critical' },
            { name: 'instance', sample: '10.0.0.1:9090' },
            { name: 'job', sample: 'node_exporter' },
            { name: 'env', sample: 'production' },
            { name: 'team', sample: 'infrastructure' },
            { name: 'datacenter', sample: 'dc1' }
          ];

          const commonAnnotations = [
            { name: 'summary', sample: 'High CPU usage detected' },
            { name: 'description', sample: 'CPU usage is above 80% for 5 minutes' },
            { name: 'runbook_url', sample: 'https://runbooks.example.com/high-cpu' },
            { name: 'dashboard_url', sample: 'https://grafana.example.com/d/xyz' }
          ];

          // Merge discovered with common
          commonLabels.forEach(l => {
            if (!labels.has(l.name)) {
              labels.set(l.name, l);
            }
          });

          this.discoveredFields.labels = Array.from(labels.values());
          this.discoveredFields.annotations = commonAnnotations;
          this.discoveredFields.core = this.getCoreFields();

          if (statusDot) statusDot.classList.remove('loading');
          if (statusText) statusText.textContent = `Found ${this.discoveredFields.labels.length + this.discoveredFields.annotations.length} fields`;
          if (endpointInput) endpointInput.value = window.location.origin + '/api/v1/alerts';

          this.saveConfig();
          this.renderApiFields();

        } catch (error) {
          if (statusDot) {
            statusDot.classList.remove('loading');
            statusDot.classList.add('error');
          }
          if (statusText) statusText.textContent = 'Error scanning fields';
          console.error('Field discovery error:', error);
        }
      },

      addFieldAsColumn(colId, fieldName, type) {
        if (this.columns.includes(colId)) return;

        // Add to discovered fields if not present
        if (type === 'labels' && !this.discoveredFields.labels.find(f => f.name === fieldName)) {
          this.discoveredFields.labels.push({ name: fieldName, sample: '' });
        } else if (type === 'annotations' && !this.discoveredFields.annotations.find(f => f.name === fieldName)) {
          this.discoveredFields.annotations.push({ name: fieldName, sample: '' });
        }

        // Insert before 'actions'
        const actionsIdx = this.columns.indexOf('actions');
        if (actionsIdx > -1) {
          this.columns.splice(actionsIdx, 0, colId);
        } else {
          this.columns.push(colId);
        }

        this.currentProfile = 'custom';
        this.profiles.custom = [...this.columns];
        this.renderVisibleColumns();
        this.renderApiFields();
        this.updatePreview();
        this.updateProfileButtons();
      },

      applyProfile(profileName) {
        if (this.profiles[profileName]) {
          this.columns = [...this.profiles[profileName]];
          if (this.columns.length === 0) {
            this.columns = [...this.profiles.default];
          }
        }
        this.currentProfile = profileName;
        this.renderVisibleColumns();
        this.updatePreview();
        this.updateProfileButtons();
      },

      updateProfileButtons() {
        document.querySelectorAll('.profile-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.profile === this.currentProfile);
        });
      },

      updatePreview() {
        const headerRow = document.getElementById('preview-header-row');
        const sampleRow = document.getElementById('preview-sample-row');
        if (!headerRow || !sampleRow) return;

        const allCols = this.getAllColumnDefinitions();
        const visibleCols = this.columns.filter(id => id !== 'checkbox' && id !== 'actions');

        headerRow.innerHTML = visibleCols.map(colId => {
          const col = allCols.find(c => c.id === colId) || { name: colId };
          return `<th>${this.escapeHtml(col.name)}</th>`;
        }).join('');

        // Generate sample data
        const firstRow = document.querySelector('.alert-row');
        sampleRow.innerHTML = visibleCols.map(colId => {
          let value = '—';
          if (firstRow) {
            if (colId === 'uid') value = firstRow.querySelector('.uid-badge')?.textContent || '—';
            else if (colId === 'account') value = firstRow.querySelector('.cell-primary')?.textContent || '—';
            else if (colId === 'hostname') value = firstRow.querySelector('.hostname')?.textContent?.trim() || '—';
            else if (colId === 'time') value = firstRow.querySelector('.time-badge')?.textContent || '—';
            else if (colId === 'services') value = firstRow.querySelector('.service-tags')?.textContent?.trim().substring(0, 20) || '—';
            else if (firstRow.dataset[colId]) value = firstRow.dataset[colId];
            else if (colId.startsWith('label_')) value = firstRow.dataset[colId.replace('label_', '')] || '—';
          }
          return `<td>${this.escapeHtml(value)}</td>`;
        }).join('');
      },

      applyColumns() {
        const tables = ['active-table', 'silenced-table'];
        const allCols = this.getAllColumnDefinitions();

        tables.forEach(tableId => {
          const table = document.getElementById(tableId);
          if (!table) return;

          // Update header visibility
          const headers = table.querySelectorAll('thead th');
          headers.forEach((th, index) => {
            const colId = this.getColumnIdByIndex(index);
            if (colId) {
              th.style.display = this.columns.includes(colId) ? '' : 'none';
            }
          });

          // Update cell visibility
          table.querySelectorAll('tbody tr').forEach(row => {
            row.querySelectorAll('td').forEach((td, index) => {
              const colId = this.getColumnIdByIndex(index);
              if (colId) {
                td.style.display = this.columns.includes(colId) ? '' : 'none';
              }
            });
          });
        });
      },

      getColumnIdByIndex(index) {
        const mapping = ['checkbox', 'uid', 'account', 'hostname', 'datacenter', 'section', 'row', 'rack', 'prom', 'time', 'duration', 'services', 'actions'];
        return mapping[index] || null;
      },

      resetToDefault() {
        this.columns = [...this.profiles.default];
        this.currentProfile = 'default';
        this.renderVisibleColumns();
        this.updatePreview();
        this.updateProfileButtons();
      },

      escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
    };

    // ========================================
    // INITIALIZATION
    // ========================================

    document.addEventListener('DOMContentLoaded', function() {
      ThemeManager.init();
      RefreshManager.init();
      ShortcutsModal.init();
      FilterManager.init();
      ExportManager.init();
      DensityManager.init();
      PresetsManager.init();
      SectionManager.init();
      TimeRangeManager.init();
      IncidentManager.init();
      ColumnManager.init();
      HelpModal.init();
      AlertDrawer.init();
      BulkActions.init();
      NewAlertsIndicator.init();
      URLState.init();
      AlertManagersModal.init();
      ViewPresets.init();
      InsightCards.init();

      // Initialize simplified prom display names
      initPromDisplayNames();

      // Initialize location display columns (DC, Section, Row, Rack)
      initLocationDisplayCells();

      // Close status dropdowns on outside click
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.status-selector')) {
          document.querySelectorAll('.status-dropdown.show').forEach(d => d.classList.remove('show'));
        }
      });

      // Close Alert Managers modal on overlay click
      document.getElementById('alert-managers-modal')?.addEventListener('click', (e) => {
        if (e.target.classList.contains('modal-overlay')) {
          AlertManagersModal.close();
        }
      });

      // Close metric modals on overlay click
      ['avg-duration-modal', 'oldest-alert-modal', 'velocity-modal', 'recurring-modal', 'health-score-modal'].forEach(modalId => {
        document.getElementById(modalId)?.addEventListener('click', (e) => {
          if (e.target.classList.contains('modal-overlay')) {
            const modalName = modalId.replace('-modal', '');
            MetricModals.close(modalName);
          }
        });
      });

      // Close modals on Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          const amModal = document.getElementById('alert-managers-modal');
          if (amModal?.classList.contains('show')) {
            AlertManagersModal.close();
          }
        }
      });

      updateCounts();

      // Calculate and display alert durations
      updateDurations();

      // Update durations every minute
      setInterval(updateDurations, 60000);
    });
  </script>
</body>
</html>
{{ end }}
