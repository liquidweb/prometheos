{{ define "foot" }}
  <style>
    /* ========================================
       DATA TABLE STYLES
       ======================================== */

    .tab-panel {
      animation: fadeIn 0.2s ease;
    }

    .table-container {
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-lg);
      overflow: hidden;
    }

    .data-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    .data-table thead {
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border-default);
    }

    .data-table th {
      padding: 14px 16px;
      text-align: left;
      font-weight: 600;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-secondary);
      white-space: nowrap;
      user-select: none;
    }

    .data-table th.sortable {
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .data-table th.sortable:hover {
      color: var(--text-primary);
      background: var(--bg-elevated);
    }

    .data-table th.sortable span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .sort-icon {
      opacity: 0.4;
      font-size: 12px;
      transition: opacity 0.15s ease;
    }

    .data-table th.sortable:hover .sort-icon,
    .data-table th.sortable.asc .sort-icon,
    .data-table th.sortable.desc .sort-icon {
      opacity: 1;
    }

    .data-table th.sortable.asc .sort-icon::after { content: ' ↑'; }
    .data-table th.sortable.desc .sort-icon::after { content: ' ↓'; }

    .data-table tbody tr {
      border-bottom: 1px solid var(--border-subtle);
      transition: background 0.1s ease;
    }

    .data-table tbody tr:last-child {
      border-bottom: none;
    }

    .data-table tbody tr:hover {
      background: var(--bg-tertiary);
    }

    .data-table tbody tr.selected {
      background: var(--accent-bg);
    }

    .data-table tbody tr.filtered-out {
      display: none;
    }

    .data-table td {
      padding: 14px 16px;
      vertical-align: middle;
    }

    /* Checkbox column */
    .col-checkbox {
      width: 40px;
      text-align: center;
    }

    .cell-checkbox {
      text-align: center;
    }

    .row-checkbox,
    .row-checkbox-header {
      width: 16px;
      height: 16px;
      cursor: pointer;
      accent-color: var(--accent);
    }

    /* Cell types */
    .cell-mono {
      font-family: var(--font-mono);
      font-size: 12px;
    }

    .cell-text {
      color: var(--text-primary);
    }

    .cell-muted {
      color: var(--text-muted);
    }

    .cell-primary {
      font-weight: 500;
    }

    /* UID Badge */
    .uid-badge {
      display: inline-block;
      padding: 4px 8px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-default);
      border-radius: var(--radius-sm);
      font-size: 11px;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .uid-badge.silenced {
      background: var(--silenced-bg);
      border-color: var(--silenced);
      color: var(--silenced);
    }

    /* Hostname with status dot */
    .hostname {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .status-dot.critical {
      background: var(--critical);
      box-shadow: 0 0 8px var(--critical);
      animation: pulse-critical 2s ease-in-out infinite;
    }

    .status-dot.silenced {
      background: var(--silenced);
    }

    @keyframes pulse-critical {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Time badge */
    .time-badge {
      display: inline-block;
      padding: 4px 8px;
      background: var(--bg-tertiary);
      border-radius: var(--radius-sm);
      font-size: 12px;
      color: var(--text-secondary);
    }

    /* Service tags */
    .cell-services {
      max-width: 300px;
    }

    .service-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .service-tag {
      display: inline-block;
      padding: 4px 10px;
      background: var(--critical-bg);
      border: 1px solid rgba(255, 107, 107, 0.3);
      border-radius: 20px;
      font-size: 11px;
      font-weight: 500;
      color: var(--critical);
    }

    .service-tag.silenced {
      background: var(--silenced-bg);
      border-color: rgba(139, 92, 246, 0.3);
      color: var(--silenced);
    }

    /* Actions column */
    .col-actions {
      width: 120px;
      text-align: right !important;
    }

    .cell-actions {
      text-align: right;
    }

    .action-form {
      display: inline;
    }

    .btn-action {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      font-family: var(--font-sans);
      font-size: 12px;
      font-weight: 500;
      border: 1px solid transparent;
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .btn-silence {
      background: var(--silenced-bg);
      border-color: rgba(139, 92, 246, 0.3);
      color: var(--silenced);
    }

    .btn-silence:hover {
      background: var(--silenced);
      color: white;
      transform: translateY(-1px);
    }

    .btn-unsilence {
      background: var(--healthy-bg);
      border-color: rgba(74, 222, 128, 0.3);
      color: var(--healthy);
    }

    .btn-unsilence:hover {
      background: var(--healthy);
      color: var(--bg-primary);
      transform: translateY(-1px);
    }

    /* Silenced row styling */
    .silenced-row {
      opacity: 0.7;
    }

    .silenced-row:hover {
      opacity: 1;
    }

    /* Empty state */
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-lg);
    }

    .empty-icon {
      margin-bottom: 16px;
      color: var(--text-muted);
    }

    .empty-state h3 {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--text-primary);
    }

    .empty-state p {
      color: var(--text-muted);
      font-size: 14px;
    }

    /* ========================================
       SKIP LINK FOR ACCESSIBILITY
       ======================================== */

    .skip-link {
      position: absolute;
      top: -100%;
      left: 16px;
      padding: 8px 16px;
      background: var(--accent);
      color: white;
      border-radius: var(--radius-md);
      z-index: 1000;
      transition: top 0.2s ease;
      text-decoration: none;
    }

    .skip-link:focus {
      top: 16px;
    }

    /* ========================================
       TOAST NOTIFICATIONS
       ======================================== */

    .toast-container {
      position: fixed;
      bottom: 24px;
      right: 24px;
      z-index: 1100;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .toast {
      padding: 12px 20px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-default);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-lg);
      font-size: 13px;
      color: var(--text-primary);
      animation: slideInRight 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .toast.success {
      border-color: var(--healthy);
    }

    .toast.error {
      border-color: var(--critical);
    }

    @keyframes slideInRight {
      from { opacity: 0; transform: translateX(20px); }
      to { opacity: 1; transform: translateX(0); }
    }

    /* ========================================
       RESPONSIVE DESIGN
       ======================================== */

    @media (max-width: 1200px) {
      .status-grid {
        grid-template-columns: repeat(2, 1fr);
      }

      .widgets-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 768px) {
      .dashboard-header {
        padding: 0 16px;
      }

      .header-meta {
        gap: 8px;
      }

      .last-update {
        display: none;
      }

      .status-overview {
        padding: 16px;
      }

      .status-grid {
        grid-template-columns: 1fr;
      }

      .controls-bar {
        flex-direction: column;
        align-items: stretch;
      }

      .search-form {
        min-width: 100%;
      }

      .filter-controls {
        justify-content: space-between;
      }

      .search-hint {
        display: none;
      }

      .main-content {
        padding: 0 16px 16px;
      }

      .table-container {
        overflow-x: auto;
      }

      .data-table {
        min-width: 900px;
      }

      .filters-grid {
        grid-template-columns: 1fr;
      }
    }

    /* ========================================
       KEYBOARD FOCUS STYLES
       ======================================== */

    .search-input:focus,
    .btn:focus,
    .btn-action:focus,
    .tab-btn:focus,
    .header-btn:focus,
    .filter-select:focus {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }
  </style>

  <!-- Toast Container -->
  <div class="toast-container" id="toast-container"></div>

  <script>
    // ========================================
    // THEME MANAGEMENT
    // ========================================

    const ThemeManager = {
      init() {
        const savedTheme = localStorage.getItem('prometheos-theme') || 'dark';
        this.setTheme(savedTheme);

        document.getElementById('theme-toggle').addEventListener('click', () => {
          const currentTheme = document.documentElement.getAttribute('data-theme');
          const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
          this.setTheme(newTheme);
          showToast(`Switched to ${newTheme} mode`, 'success');
        });
      },

      setTheme(theme) {
        document.documentElement.setAttribute('data-theme', theme);
        localStorage.setItem('prometheos-theme', theme);
      },

      toggle() {
        const currentTheme = document.documentElement.getAttribute('data-theme');
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
        this.setTheme(newTheme);
      }
    };

    // ========================================
    // AUTO-REFRESH MANAGEMENT
    // ========================================

    const RefreshManager = {
      interval: null,
      currentInterval: 60,

      init() {
        const savedInterval = localStorage.getItem('prometheos-refresh-interval');
        if (savedInterval !== null) {
          this.currentInterval = parseInt(savedInterval);
        }
        this.updateUI();
        this.startRefresh();

        // Dropdown toggle
        const refreshBtn = document.getElementById('refresh-btn');
        const dropdown = document.getElementById('refresh-dropdown');

        refreshBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          dropdown.classList.toggle('show');
        });

        // Option selection
        document.querySelectorAll('.refresh-option').forEach(option => {
          option.addEventListener('click', () => {
            const interval = parseInt(option.dataset.interval);
            this.setInterval(interval);
            dropdown.classList.remove('show');
          });
        });

        // Close dropdown on outside click
        document.addEventListener('click', () => {
          dropdown.classList.remove('show');
        });
      },

      setInterval(seconds) {
        this.currentInterval = seconds;
        localStorage.setItem('prometheos-refresh-interval', seconds);
        this.updateUI();
        this.startRefresh();

        if (seconds === 0) {
          showToast('Auto-refresh disabled', 'success');
        } else {
          showToast(`Auto-refresh set to ${seconds < 60 ? seconds + ' seconds' : (seconds / 60) + ' minute(s)'}`, 'success');
        }
      },

      updateUI() {
        const refreshBtn = document.getElementById('refresh-btn');
        document.querySelectorAll('.refresh-option').forEach(option => {
          const interval = parseInt(option.dataset.interval);
          option.classList.toggle('selected', interval === this.currentInterval);
        });

        if (this.currentInterval > 0) {
          refreshBtn.classList.add('active');
        } else {
          refreshBtn.classList.remove('active');
        }
      },

      startRefresh() {
        if (this.interval) {
          clearInterval(this.interval);
        }

        if (this.currentInterval > 0) {
          this.interval = setInterval(() => {
            this.refresh();
          }, this.currentInterval * 1000);
        }
      },

      refresh() {
        const indicator = document.getElementById('update-indicator');
        indicator.classList.add('refreshing');

        // Reload the page to get fresh data
        setTimeout(() => {
          window.location.reload();
        }, 500);
      }
    };

    // ========================================
    // SHORTCUTS MODAL
    // ========================================

    const ShortcutsModal = {
      init() {
        const modal = document.getElementById('shortcuts-modal');
        const openBtn = document.getElementById('shortcuts-btn');
        const closeBtn = document.getElementById('modal-close');

        openBtn.addEventListener('click', () => this.open());
        closeBtn.addEventListener('click', () => this.close());

        modal.addEventListener('click', (e) => {
          if (e.target === modal) this.close();
        });
      },

      open() {
        document.getElementById('shortcuts-modal').classList.add('show');
      },

      close() {
        document.getElementById('shortcuts-modal').classList.remove('show');
      },

      toggle() {
        const modal = document.getElementById('shortcuts-modal');
        modal.classList.toggle('show');
      }
    };

    // ========================================
    // HELP MODAL
    // ========================================

    const HelpModal = {
      modal: null,
      currentTab: 'overview',

      init() {
        this.modal = document.getElementById('help-modal');
        const openBtn = document.getElementById('help-btn');

        if (openBtn) {
          openBtn.addEventListener('click', () => this.open());
        }

        if (this.modal) {
          this.modal.addEventListener('click', (e) => {
            if (e.target === this.modal) this.close();
          });
        }
      },

      open() {
        if (this.modal) {
          this.modal.classList.add('show');
        }
      },

      close() {
        if (this.modal) {
          this.modal.classList.remove('show');
        }
      },

      toggle() {
        if (this.modal) {
          this.modal.classList.toggle('show');
        }
      },

      showTab(tabName) {
        this.currentTab = tabName;

        // Update tab buttons
        document.querySelectorAll('.help-tab').forEach(tab => {
          tab.classList.toggle('active', tab.dataset.tab === tabName);
        });

        // Update content visibility
        document.querySelectorAll('.help-content').forEach(content => {
          content.style.display = 'none';
        });

        const activeContent = document.getElementById(`help-content-${tabName}`);
        if (activeContent) {
          activeContent.style.display = 'block';
        }
      }
    };

    // ========================================
    // ALERT DETAILS DRAWER
    // ========================================

    const AlertDrawer = {
      overlay: null,
      currentAlert: null,
      currentIndex: 0,
      alerts: [],

      init() {
        this.overlay = document.getElementById('alert-drawer-overlay');

        // Close on overlay click
        if (this.overlay) {
          this.overlay.addEventListener('click', (e) => {
            if (e.target === this.overlay) this.close();
          });
        }

        // Make alert rows clickable
        this.bindRowClicks();

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
          if (!this.overlay?.classList.contains('show')) return;

          if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
            e.preventDefault();
            this.previous();
          } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
            e.preventDefault();
            this.next();
          }
        });
      },

      bindRowClicks() {
        document.querySelectorAll('.alert-row').forEach(row => {
          row.addEventListener('click', (e) => {
            // Don't open drawer if clicking on checkbox, button, or link
            if (e.target.closest('input, button, a, .row-checkbox')) return;
            this.openFromRow(row);
          });
        });
      },

      openFromRow(row) {
        // Build alerts array from visible rows
        const table = row.closest('table');
        this.alerts = Array.from(table.querySelectorAll('tbody tr:not(.filtered-out)'));
        this.currentIndex = this.alerts.indexOf(row);

        this.populateFromRow(row);
        this.open();
      },

      open() {
        if (this.overlay) {
          this.overlay.classList.add('show');
          this.updateNavigation();
        }
      },

      close() {
        if (this.overlay) {
          this.overlay.classList.remove('show');
        }
      },

      populateFromRow(row) {
        this.currentAlert = {
          uid: row.querySelector('.uid-badge')?.textContent || '',
          account: row.querySelector('.cell-primary')?.textContent || '',
          hostname: row.querySelector('.hostname')?.textContent?.trim() || '',
          location: row.dataset.location || '',
          prom: row.dataset.prom || '',
          time: row.dataset.time || '',
          services: row.dataset.services || '',
          isSilenced: row.closest('#silenced') !== null
        };

        // Populate fields
        document.getElementById('drawer-hostname').textContent = this.currentAlert.hostname;
        document.getElementById('drawer-uid').textContent = this.currentAlert.uid;
        document.getElementById('drawer-account').textContent = this.currentAlert.account;
        document.getElementById('drawer-hostname-full').textContent = this.currentAlert.hostname;
        document.getElementById('drawer-location').textContent = this.currentAlert.location || '—';
        document.getElementById('drawer-prom').textContent = this.currentAlert.prom || '—';
        document.getElementById('drawer-time').textContent = this.currentAlert.time || '—';

        // Calculate duration
        if (this.currentAlert.time) {
          const start = new Date(this.currentAlert.time.replace(' ', 'T'));
          const now = new Date();
          const diffMs = now - start;
          const hours = Math.floor(diffMs / (1000 * 60 * 60));
          const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
          document.getElementById('drawer-duration').textContent =
            hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;
        } else {
          document.getElementById('drawer-duration').textContent = '—';
        }

        // Populate services
        const servicesContainer = document.getElementById('drawer-services');
        const services = this.currentAlert.services.split(',').filter(s => s.trim());
        servicesContainer.innerHTML = services.length > 0
          ? services.map(s => `<span class="drawer-service-tag">${this.escapeHtml(s.trim())}</span>`).join('')
          : '<span class="drawer-info-value">No services</span>';

        // Populate labels from data attributes
        const labelsContainer = document.getElementById('drawer-labels');
        const labels = [];
        Object.keys(row.dataset).forEach(key => {
          if (!['time', 'services', 'location', 'prom', 'uid'].includes(key)) {
            labels.push({ key, value: row.dataset[key] });
          }
        });

        if (labels.length > 0) {
          labelsContainer.innerHTML = labels.map(l => `
            <span class="drawer-label">
              <span class="drawer-label-key">${this.escapeHtml(l.key)}:</span>
              <span class="drawer-label-value">${this.escapeHtml(l.value)}</span>
            </span>
          `).join('');
          document.getElementById('drawer-labels-section').style.display = 'block';
        } else {
          document.getElementById('drawer-labels-section').style.display = 'none';
        }

        // Update silence button
        const silenceBtn = document.getElementById('drawer-silence-btn');
        const silenceText = document.getElementById('drawer-silence-text');
        if (this.currentAlert.isSilenced) {
          silenceBtn.classList.remove('danger');
          silenceBtn.classList.add('secondary');
          silenceText.textContent = 'Unsilence Alert';
        } else {
          silenceBtn.classList.remove('secondary');
          silenceBtn.classList.add('danger');
          silenceText.textContent = 'Silence Alert';
        }
      },

      updateNavigation() {
        const prevBtn = document.getElementById('drawer-prev-btn');
        const nextBtn = document.getElementById('drawer-next-btn');
        const position = document.getElementById('drawer-position');

        prevBtn.disabled = this.currentIndex === 0;
        nextBtn.disabled = this.currentIndex === this.alerts.length - 1;
        position.textContent = `${this.currentIndex + 1} of ${this.alerts.length}`;
      },

      previous() {
        if (this.currentIndex > 0) {
          this.currentIndex--;
          this.populateFromRow(this.alerts[this.currentIndex]);
          this.updateNavigation();
        }
      },

      next() {
        if (this.currentIndex < this.alerts.length - 1) {
          this.currentIndex++;
          this.populateFromRow(this.alerts[this.currentIndex]);
          this.updateNavigation();
        }
      },

      silenceAlert() {
        if (!this.currentAlert) return;

        const form = document.createElement('form');
        form.method = 'POST';
        form.style.display = 'none';

        const input = document.createElement('input');
        input.name = this.currentAlert.isSilenced ? 'remove-silence' : 'silence-alert';
        input.value = this.currentAlert.hostname;
        form.appendChild(input);

        document.body.appendChild(form);
        form.submit();
      },

      copyAsText() {
        if (!this.currentAlert) return;

        const text = `Alert: ${this.currentAlert.hostname}
UID: ${this.currentAlert.uid}
Account: ${this.currentAlert.account}
Location: ${this.currentAlert.location}
Prom Node: ${this.currentAlert.prom}
Started: ${this.currentAlert.time}
Services: ${this.currentAlert.services}`;

        navigator.clipboard.writeText(text).then(() => {
          showToast('Alert details copied to clipboard', 'success');
        }).catch(() => {
          showToast('Failed to copy to clipboard', 'error');
        });
      },

      copyAsJSON() {
        if (!this.currentAlert) return;

        const json = JSON.stringify(this.currentAlert, null, 2);
        navigator.clipboard.writeText(json).then(() => {
          showToast('Alert JSON copied to clipboard', 'success');
        }).catch(() => {
          showToast('Failed to copy to clipboard', 'error');
        });
      },

      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
    };

    // ========================================
    // BULK ACTIONS
    // ========================================

    const BulkActions = {
      selectedRows: new Set(),
      bar: null,

      init() {
        this.bar = document.getElementById('bulk-actions-bar');
        this.bindCheckboxes();
      },

      bindCheckboxes() {
        // Row checkboxes
        document.querySelectorAll('.row-checkbox').forEach(checkbox => {
          checkbox.addEventListener('change', (e) => {
            e.stopPropagation();
            const row = checkbox.closest('tr');
            if (checkbox.checked) {
              this.selectedRows.add(row);
              row.classList.add('selected');
            } else {
              this.selectedRows.delete(row);
              row.classList.remove('selected');
            }
            this.updateBar();
          });
        });

        // Header checkboxes (select all)
        document.querySelectorAll('.row-checkbox-header').forEach(headerCheckbox => {
          headerCheckbox.addEventListener('change', () => {
            const table = headerCheckbox.closest('table');
            const checkboxes = table.querySelectorAll('tbody .row-checkbox');
            checkboxes.forEach(checkbox => {
              const row = checkbox.closest('tr');
              if (!row.classList.contains('filtered-out')) {
                checkbox.checked = headerCheckbox.checked;
                if (headerCheckbox.checked) {
                  this.selectedRows.add(row);
                  row.classList.add('selected');
                } else {
                  this.selectedRows.delete(row);
                  row.classList.remove('selected');
                }
              }
            });
            this.updateBar();
          });
        });
      },

      updateBar() {
        const count = this.selectedRows.size;
        document.getElementById('bulk-count').textContent = count;

        if (count > 0) {
          this.bar.classList.add('show');
        } else {
          this.bar.classList.remove('show');
        }
      },

      clearSelection() {
        this.selectedRows.forEach(row => {
          row.classList.remove('selected');
          const checkbox = row.querySelector('.row-checkbox');
          if (checkbox) checkbox.checked = false;
        });
        this.selectedRows.clear();

        // Uncheck header checkboxes
        document.querySelectorAll('.row-checkbox-header').forEach(cb => cb.checked = false);

        this.updateBar();
      },

      getSelectedData() {
        return Array.from(this.selectedRows).map(row => ({
          uid: row.querySelector('.uid-badge')?.textContent || '',
          account: row.querySelector('.cell-primary')?.textContent || '',
          hostname: row.querySelector('.hostname')?.textContent?.trim() || '',
          location: row.dataset.location || '',
          prom: row.dataset.prom || '',
          time: row.dataset.time || '',
          services: row.dataset.services || ''
        }));
      },

      silenceSelected() {
        const hostnames = this.getSelectedData().map(a => a.hostname);
        if (hostnames.length === 0) return;

        // For now, silence one at a time (could be batched with API)
        const form = document.createElement('form');
        form.method = 'POST';
        form.style.display = 'none';

        hostnames.forEach(hostname => {
          const input = document.createElement('input');
          input.name = 'silence-alert';
          input.value = hostname;
          form.appendChild(input);
        });

        document.body.appendChild(form);
        showToast(`Silencing ${hostnames.length} alert(s)...`, 'success');
        form.submit();
      },

      unsilenceSelected() {
        const hostnames = this.getSelectedData().map(a => a.hostname);
        if (hostnames.length === 0) return;

        const form = document.createElement('form');
        form.method = 'POST';
        form.style.display = 'none';

        hostnames.forEach(hostname => {
          const input = document.createElement('input');
          input.name = 'remove-silence';
          input.value = hostname;
          form.appendChild(input);
        });

        document.body.appendChild(form);
        showToast(`Unsilencing ${hostnames.length} alert(s)...`, 'success');
        form.submit();
      },

      createIncident() {
        const data = this.getSelectedData();
        if (data.length < 2) {
          showToast('Select at least 2 alerts to create an incident', 'error');
          return;
        }

        // Use IncidentManager to create incident
        IncidentManager.createFromAlerts(data);
        this.clearSelection();
        showToast(`Created incident with ${data.length} alerts`, 'success');
      },

      copySelected() {
        const data = this.getSelectedData();
        if (data.length === 0) return;

        const text = data.map(a =>
          `${a.hostname} | ${a.account} | ${a.services} | ${a.time}`
        ).join('\n');

        navigator.clipboard.writeText(text).then(() => {
          showToast(`Copied ${data.length} alert(s) to clipboard`, 'success');
        }).catch(() => {
          showToast('Failed to copy to clipboard', 'error');
        });
      }
    };

    // ========================================
    // NEW ALERTS INDICATOR
    // ========================================

    const NewAlertsIndicator = {
      banner: null,
      knownAlerts: new Set(),
      newAlerts: [],
      storageKey: 'prometheos-known-alerts',

      init() {
        this.banner = document.getElementById('new-alerts-banner');

        // Load known alerts from localStorage
        this.loadKnownAlerts();

        // Check for new alerts on page load
        this.checkForNewAlerts();

        // Save current alerts before page unload
        window.addEventListener('beforeunload', () => this.saveKnownAlerts());
      },

      loadKnownAlerts() {
        try {
          const saved = localStorage.getItem(this.storageKey);
          if (saved) {
            const data = JSON.parse(saved);
            // Only use saved data if it's less than 1 hour old
            if (data.timestamp && (Date.now() - data.timestamp) < 3600000) {
              this.knownAlerts = new Set(data.alerts || []);
              return;
            }
          }
        } catch (e) {
          console.warn('Failed to load known alerts:', e);
        }

        // If no valid saved data, initialize from current alerts (first load)
        this.initializeFromCurrentAlerts();
      },

      initializeFromCurrentAlerts() {
        document.querySelectorAll('#active-table tbody tr').forEach(row => {
          const id = this.getAlertId(row);
          if (id) this.knownAlerts.add(id);
        });
        this.saveKnownAlerts();
      },

      saveKnownAlerts() {
        try {
          // Keep only alerts that still exist in the DOM plus new ones
          const currentIds = new Set();
          document.querySelectorAll('#active-table tbody tr').forEach(row => {
            const id = this.getAlertId(row);
            if (id) currentIds.add(id);
          });

          // Merge with known (in case some alerts were dismissed but still exist)
          const toSave = [...currentIds];

          localStorage.setItem(this.storageKey, JSON.stringify({
            alerts: toSave,
            timestamp: Date.now()
          }));
        } catch (e) {
          console.warn('Failed to save known alerts:', e);
        }
      },

      getAlertId(row) {
        const hostname = row.querySelector('.hostname')?.textContent?.trim();
        const time = row.dataset.time;
        return hostname && time ? `${hostname}-${time}` : null;
      },

      checkForNewAlerts() {
        this.newAlerts = [];

        document.querySelectorAll('#active-table tbody tr').forEach(row => {
          const id = this.getAlertId(row);
          if (id && !this.knownAlerts.has(id)) {
            this.newAlerts.push(row);
            row.classList.add('new-alert');
          }
        });

        if (this.newAlerts.length > 0) {
          this.show();
        }
      },

      show() {
        if (this.banner) {
          document.getElementById('new-alerts-count').textContent = this.newAlerts.length;
          this.banner.classList.add('show');
        }
      },

      dismiss() {
        if (this.banner) {
          this.banner.classList.remove('show');
          // Add new alerts to known set
          this.newAlerts.forEach(row => {
            const id = this.getAlertId(row);
            if (id) this.knownAlerts.add(id);
            row.classList.remove('new-alert');
          });
          this.newAlerts = [];
          this.saveKnownAlerts();
        }
      },

      scrollToNew() {
        if (this.newAlerts.length > 0) {
          this.newAlerts[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
          this.dismiss();
        }
      }
    };

    // ========================================
    // URL STATE MANAGER
    // ========================================

    const URLState = {
      init() {
        // Read state from URL on load
        this.loadFromURL();

        // Update URL when state changes (debounced)
        this.setupListeners();

        // Handle browser back/forward
        window.addEventListener('popstate', () => this.loadFromURL());
      },

      loadFromURL() {
        const params = new URLSearchParams(window.location.search);

        // Tab
        const tab = params.get('tab');
        if (tab === 'silenced') {
          document.querySelectorAll('.tab-btn')[1]?.click();
        }

        // Search
        const search = params.get('q');
        if (search) {
          const searchBox = document.getElementById('search-box');
          if (searchBox) {
            searchBox.value = search;
            searchBox.dispatchEvent(new Event('input'));
          }
        }

        // Time range
        const range = params.get('range');
        if (range && TimeRangeManager.rangeMs[range]) {
          TimeRangeManager.setRange(range);
        }

        // Theme
        const theme = params.get('theme');
        if (theme === 'dark' || theme === 'light') {
          ThemeManager.setTheme(theme);
        }

        // Density
        const density = params.get('density');
        if (['compact', 'comfortable', 'spacious'].includes(density)) {
          DensityManager.setDensity(density);
        }

        // Filters
        const location = params.get('location');
        const account = params.get('account');
        const service = params.get('service');
        const prom = params.get('prom');

        if (location || account || service || prom) {
          // Open filters panel and set values
          if (location) {
            const el = document.getElementById('filter-location');
            if (el) el.value = location;
          }
          if (account) {
            const el = document.getElementById('filter-account');
            if (el) el.value = account;
          }
          if (service) {
            const el = document.getElementById('filter-service');
            if (el) el.value = service;
          }
          if (prom) {
            const el = document.getElementById('filter-prom');
            if (el) el.value = prom;
          }

          // Apply filters
          setTimeout(() => FilterManager.applyFilters(), 100);
        }
      },

      setupListeners() {
        // Search box
        const searchBox = document.getElementById('search-box');
        if (searchBox) {
          searchBox.addEventListener('input', this.debounce(() => this.updateURL(), 500));
        }

        // Tab buttons
        document.querySelectorAll('.tab-btn').forEach(btn => {
          btn.addEventListener('click', () => this.updateURL());
        });

        // Filter changes
        ['filter-location', 'filter-account', 'filter-service', 'filter-prom'].forEach(id => {
          const el = document.getElementById(id);
          if (el) {
            el.addEventListener('change', () => this.updateURL());
          }
        });
      },

      updateURL() {
        const params = new URLSearchParams();

        // Tab
        const activeTab = document.querySelector('.tab-btn.active');
        if (activeTab?.textContent?.toLowerCase().includes('silenced')) {
          params.set('tab', 'silenced');
        }

        // Search
        const search = document.getElementById('search-box')?.value;
        if (search) params.set('q', search);

        // Time range
        if (TimeRangeManager.current !== '24h') {
          params.set('range', TimeRangeManager.current);
        }

        // Filters
        const location = document.getElementById('filter-location')?.value;
        const account = document.getElementById('filter-account')?.value;
        const service = document.getElementById('filter-service')?.value;
        const prom = document.getElementById('filter-prom')?.value;

        if (location) params.set('location', location);
        if (account) params.set('account', account);
        if (service) params.set('service', service);
        if (prom) params.set('prom', prom);

        // Update URL without reload
        const newURL = params.toString()
          ? `${window.location.pathname}?${params.toString()}`
          : window.location.pathname;

        window.history.replaceState({}, '', newURL);
      },

      getShareableURL() {
        this.updateURL();
        return window.location.href;
      },

      copyShareableURL() {
        const url = this.getShareableURL();
        navigator.clipboard.writeText(url).then(() => {
          showToast('Dashboard URL copied to clipboard', 'success');
        }).catch(() => {
          showToast('Failed to copy URL', 'error');
        });
      },

      debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }
    };

    // ========================================
    // TAB SWITCHING
    // ========================================

    function openAlerts(evt, alertType) {
      const panels = document.querySelectorAll('.tab-panel');
      panels.forEach(panel => {
        panel.style.display = 'none';
      });

      const tabs = document.querySelectorAll('.tab-btn');
      tabs.forEach(tab => {
        tab.classList.remove('active');
      });

      document.getElementById(alertType).style.display = 'block';
      evt.currentTarget.classList.add('active');
    }

    // ========================================
    // TABLE SORTING
    // ========================================

    const sortStates = {};

    function sortTable(tableId, columnIndex) {
      const table = document.getElementById(tableId);
      const tbody = table.querySelector('tbody');
      const rows = Array.from(tbody.querySelectorAll('tr:not(.filtered-out)'));
      const th = table.querySelectorAll('th')[columnIndex];

      const stateKey = `${tableId}-${columnIndex}`;
      if (!sortStates[stateKey]) {
        sortStates[stateKey] = 'asc';
      } else {
        sortStates[stateKey] = sortStates[stateKey] === 'asc' ? 'desc' : 'asc';
      }

      const direction = sortStates[stateKey];

      table.querySelectorAll('th').forEach(header => {
        header.classList.remove('asc', 'desc');
      });
      th.classList.add(direction);

      rows.sort((a, b) => {
        const aVal = a.cells[columnIndex].textContent.trim().toLowerCase();
        const bVal = b.cells[columnIndex].textContent.trim().toLowerCase();

        const datePattern = /^\d{4}-\d{2}-\d{2}/;
        if (datePattern.test(aVal) && datePattern.test(bVal)) {
          const aDate = new Date(aVal.replace(' ', 'T'));
          const bDate = new Date(bVal.replace(' ', 'T'));
          return direction === 'asc' ? aDate - bDate : bDate - aDate;
        }

        if (aVal < bVal) return direction === 'asc' ? -1 : 1;
        if (aVal > bVal) return direction === 'asc' ? 1 : -1;
        return 0;
      });

      rows.forEach(row => tbody.appendChild(row));
    }

    // ========================================
    // FILTERING
    // ========================================

    const FilterManager = {
      filters: {
        location: '',
        prom: '',
        time: '',
        service: ''
      },

      init() {
        this.populateFilterOptions();

        document.getElementById('filter-toggle').addEventListener('click', () => {
          this.togglePanel();
        });
      },

      togglePanel() {
        const panel = document.getElementById('filters-panel');
        panel.classList.toggle('show');
      },

      populateFilterOptions() {
        const rows = document.querySelectorAll('#active-table tbody tr, #silenced-table tbody tr');
        const locations = new Set();
        const proms = new Set();
        const services = new Set();

        rows.forEach(row => {
          if (row.dataset.location) locations.add(row.dataset.location);
          if (row.dataset.prom) proms.add(row.dataset.prom);
          if (row.dataset.services) {
            row.dataset.services.split(',').forEach(s => {
              if (s.trim()) services.add(s.trim());
            });
          }
        });

        this.populateSelect('filter-location', Array.from(locations).sort());
        this.populateSelect('filter-prom', Array.from(proms).sort());
        this.populateSelect('filter-service', Array.from(services).sort());
      },

      populateSelect(selectId, options) {
        const select = document.getElementById(selectId);
        const currentValue = select.value;

        // Keep the first "All" option
        while (select.options.length > 1) {
          select.remove(1);
        }

        options.forEach(opt => {
          const option = document.createElement('option');
          option.value = opt;
          option.textContent = opt;
          select.appendChild(option);
        });

        select.value = currentValue;
      },

      apply() {
        this.filters.location = document.getElementById('filter-location').value;
        this.filters.prom = document.getElementById('filter-prom').value;
        this.filters.time = document.getElementById('filter-time').value;
        this.filters.service = document.getElementById('filter-service').value;

        const rows = document.querySelectorAll('#active-table tbody tr, #silenced-table tbody tr');

        rows.forEach(row => {
          let show = true;

          if (this.filters.location && row.dataset.location !== this.filters.location) {
            show = false;
          }

          if (this.filters.prom && row.dataset.prom !== this.filters.prom) {
            show = false;
          }

          if (this.filters.service) {
            const rowServices = row.dataset.services ? row.dataset.services.split(',') : [];
            if (!rowServices.includes(this.filters.service)) {
              show = false;
            }
          }

          if (this.filters.time && row.dataset.time) {
            const alertTime = new Date(row.dataset.time.replace(' ', 'T'));
            const now = new Date();
            let cutoff;

            switch (this.filters.time) {
              case '1h': cutoff = new Date(now - 60 * 60 * 1000); break;
              case '6h': cutoff = new Date(now - 6 * 60 * 60 * 1000); break;
              case '24h': cutoff = new Date(now - 24 * 60 * 60 * 1000); break;
              case '7d': cutoff = new Date(now - 7 * 24 * 60 * 60 * 1000); break;
            }

            if (cutoff && alertTime < cutoff) {
              show = false;
            }
          }

          row.classList.toggle('filtered-out', !show);
        });

        this.updateActiveFilterTags();
        this.updateFilterBadge();
        updateCounts();
      },

      updateActiveFilterTags() {
        const container = document.getElementById('active-filters');
        container.innerHTML = '';

        const activeFilters = [];

        if (this.filters.location) {
          activeFilters.push({ type: 'location', label: `Location: ${this.filters.location}` });
        }
        if (this.filters.prom) {
          activeFilters.push({ type: 'prom', label: `Node: ${this.filters.prom}` });
        }
        if (this.filters.time) {
          const timeLabels = { '1h': 'Last 1 Hour', '6h': 'Last 6 Hours', '24h': 'Last 24 Hours', '7d': 'Last 7 Days' };
          activeFilters.push({ type: 'time', label: timeLabels[this.filters.time] });
        }
        if (this.filters.service) {
          activeFilters.push({ type: 'service', label: `Service: ${this.filters.service}` });
        }

        activeFilters.forEach(filter => {
          const tag = document.createElement('div');
          tag.className = 'active-filter-tag';
          tag.innerHTML = `
            <span>${filter.label}</span>
            <button type="button" onclick="removeFilter('${filter.type}')">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
          `;
          container.appendChild(tag);
        });
      },

      updateFilterBadge() {
        const count = Object.values(this.filters).filter(v => v).length;
        const badge = document.getElementById('filter-badge');
        badge.textContent = count;
        badge.classList.toggle('show', count > 0);
      },

      clearAll() {
        document.getElementById('filter-location').value = '';
        document.getElementById('filter-prom').value = '';
        document.getElementById('filter-time').value = '';
        document.getElementById('filter-service').value = '';

        this.filters = { location: '', prom: '', time: '', service: '' };

        document.querySelectorAll('#active-table tbody tr, #silenced-table tbody tr').forEach(row => {
          row.classList.remove('filtered-out');
        });

        this.updateActiveFilterTags();
        this.updateFilterBadge();
        updateCounts();
        showToast('Filters cleared', 'success');
      }
    };

    function applyFilters() {
      FilterManager.apply();
    }

    function clearAllFilters() {
      FilterManager.clearAll();
    }

    function removeFilter(type) {
      document.getElementById(`filter-${type}`).value = '';
      FilterManager.apply();
    }

    function toggleFiltersPanel() {
      FilterManager.togglePanel();
    }

    // ========================================
    // SELECTION & BULK ACTIONS
    // ========================================

    function updateSelectionCount() {
      const checkboxes = document.querySelectorAll('.row-checkbox:checked');
      const count = checkboxes.length;
      const countEl = document.getElementById('selected-count');
      const bulkBar = document.getElementById('bulk-actions');

      countEl.textContent = count;
      bulkBar.classList.toggle('show', count > 0);
    }

    function toggleAllInTable(tableId, checkbox) {
      const table = document.getElementById(tableId);
      const rowCheckboxes = table.querySelectorAll('tbody tr:not(.filtered-out) .row-checkbox');

      rowCheckboxes.forEach(cb => {
        cb.checked = checkbox.checked;
      });

      updateSelectionCount();
    }

    function toggleSelectAll(checkbox) {
      const activePanel = document.querySelector('.tab-panel[style*="block"]') || document.getElementById('active');
      const table = activePanel.querySelector('.data-table');

      if (table) {
        const rowCheckboxes = table.querySelectorAll('tbody tr:not(.filtered-out) .row-checkbox');
        rowCheckboxes.forEach(cb => {
          cb.checked = checkbox.checked;
        });
      }

      updateSelectionCount();
    }

    function clearSelection() {
      document.querySelectorAll('.row-checkbox').forEach(cb => {
        cb.checked = false;
      });
      document.querySelectorAll('.row-checkbox-header').forEach(cb => {
        cb.checked = false;
      });
      updateSelectionCount();
    }

    function bulkSilence() {
      const checkboxes = document.querySelectorAll('#active-table .row-checkbox:checked');
      const hostnames = [];

      checkboxes.forEach(cb => {
        hostnames.push(cb.dataset.hostname);
      });

      if (hostnames.length === 0) {
        showToast('No alerts selected', 'error');
        return;
      }

      // Create a form and submit for each hostname
      hostnames.forEach((hostname, index) => {
        setTimeout(() => {
          const form = document.createElement('form');
          form.method = 'POST';
          form.style.display = 'none';

          const input = document.createElement('input');
          input.type = 'hidden';
          input.name = 'silence-alert';
          input.value = hostname;

          form.appendChild(input);
          document.body.appendChild(form);

          if (index === hostnames.length - 1) {
            form.submit();
          } else {
            // For multiple, we'd need an API. For now, just submit the last one
            form.remove();
          }
        }, index * 100);
      });

      showToast(`Silencing ${hostnames.length} alert(s)...`, 'success');
    }

    // ========================================
    // EXPORT FUNCTIONALITY
    // ========================================

    const ExportManager = {
      init() {
        const exportBtn = document.getElementById('export-btn');
        const exportMenu = document.getElementById('export-menu');

        exportBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          exportMenu.classList.toggle('show');
        });

        document.addEventListener('click', () => {
          exportMenu.classList.remove('show');
        });
      }
    };

    function exportData(format) {
      const activePanel = document.querySelector('.tab-panel[style*="block"]') || document.getElementById('active');
      const table = activePanel.querySelector('.data-table');

      if (!table) return;

      const rows = table.querySelectorAll('tbody tr:not(.filtered-out)');
      const data = [];

      rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        data.push({
          uid: cells[1]?.textContent.trim() || '',
          account: cells[2]?.textContent.trim() || '',
          hostname: cells[3]?.textContent.trim() || '',
          location: cells[4]?.textContent.trim() || '',
          promNode: cells[5]?.textContent.trim() || '',
          startTime: cells[6]?.textContent.trim() || '',
          services: Array.from(cells[7]?.querySelectorAll('.service-tag') || []).map(t => t.textContent.trim())
        });
      });

      if (format === 'json') {
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        downloadBlob(blob, `prometheos-alerts-${new Date().toISOString().slice(0, 10)}.json`);
        showToast('Exported as JSON', 'success');
      } else if (format === 'csv') {
        let csv = 'UID,Account,Hostname,Location,Prom Node,Start Time,Services\n';
        data.forEach(row => {
          csv += `"${row.uid}","${row.account}","${row.hostname}","${row.location}","${row.promNode}","${row.startTime}","${row.services.join('; ')}"\n`;
        });
        const blob = new Blob([csv], { type: 'text/csv' });
        downloadBlob(blob, `prometheos-alerts-${new Date().toISOString().slice(0, 10)}.csv`);
        showToast('Exported as CSV', 'success');
      }

      document.getElementById('export-menu').classList.remove('show');
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // ========================================
    // DASHBOARD WIDGETS
    // ========================================

    function updateDashboardWidgets() {
      const rows = document.querySelectorAll('#active-table tbody tr:not(.filtered-out)');

      // Severity distribution (simulated based on service names)
      let critical = 0, warning = 0, info = 0;
      const serviceCounts = {};
      const locationCounts = {};

      rows.forEach(row => {
        const services = row.dataset.services ? row.dataset.services.split(',') : [];
        const location = row.dataset.location || 'Unknown';

        services.forEach(service => {
          if (service.trim()) {
            serviceCounts[service.trim()] = (serviceCounts[service.trim()] || 0) + 1;

            // Categorize by service name
            const s = service.toLowerCase();
            if (s.includes('critical') || s.includes('down') || s.includes('fail')) {
              critical++;
            } else if (s.includes('warn') || s.includes('high') || s.includes('load')) {
              warning++;
            } else {
              info++;
            }
          }
        });

        locationCounts[location] = (locationCounts[location] || 0) + 1;
      });

      // If no categorization, count all as critical
      if (critical === 0 && warning === 0 && info === 0) {
        critical = rows.length;
      }

      const total = critical + warning + info || 1;

      // Update severity bars
      document.getElementById('severity-critical').style.width = `${(critical / total) * 100}%`;
      document.getElementById('severity-warning').style.width = `${(warning / total) * 100}%`;
      document.getElementById('severity-info').style.width = `${(info / total) * 100}%`;

      document.getElementById('severity-critical-count').textContent = critical;
      document.getElementById('severity-warning-count').textContent = warning;
      document.getElementById('severity-info-count').textContent = info;

      // Update top services
      const topServices = Object.entries(serviceCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);

      const servicesContainer = document.getElementById('top-services');
      if (topServices.length > 0) {
        servicesContainer.innerHTML = topServices.map(([name, count]) => `
          <div class="service-row">
            <span class="service-name">${name}</span>
            <span class="service-count-badge">${count}</span>
          </div>
        `).join('');
      } else {
        servicesContainer.innerHTML = `
          <div class="service-row">
            <span class="service-name">No active alerts</span>
            <span class="service-count-badge">0</span>
          </div>
        `;
      }

      // Update top locations
      const topLocations = Object.entries(locationCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);

      const locationsContainer = document.getElementById('top-locations');
      if (topLocations.length > 0) {
        locationsContainer.innerHTML = topLocations.map(([name, count]) => `
          <div class="location-row" onclick="filterByLocation('${name}')">
            <span class="location-name">${name}</span>
            <span class="location-count-badge">${count}</span>
          </div>
        `).join('');
      } else {
        locationsContainer.innerHTML = `
          <div class="location-row">
            <span class="location-name">No locations</span>
            <span class="location-count-badge">0</span>
          </div>
        `;
      }

      // Update advanced analytics
      updateAdvancedAnalytics();
    }

    function filterByLocation(location) {
      document.getElementById('filter-location').value = location;
      FilterManager.apply();

      // Open filters panel if not open
      const panel = document.getElementById('filters-panel');
      if (!panel.classList.contains('show')) {
        panel.classList.add('show');
      }

      showToast(`Filtered by location: ${location}`, 'success');
    }

    // ========================================
    // ADVANCED ANALYTICS
    // ========================================

    function updateAdvancedAnalytics() {
      const rows = document.querySelectorAll('#active-table tbody tr:not(.filtered-out)');
      const now = new Date();

      // Collect alert data
      const alertData = [];
      rows.forEach(row => {
        const timeStr = row.dataset.time;
        if (timeStr) {
          const alertTime = new Date(timeStr.replace(' ', 'T'));
          const hostname = row.querySelector('.hostname')?.textContent.trim() || '';
          const account = row.querySelector('.cell-primary')?.textContent.trim() || '';
          const services = row.dataset.services || '';

          alertData.push({
            time: alertTime,
            hostname,
            account,
            services,
            duration: now - alertTime
          });
        }
      });

      // Update Quick Stats
      updateQuickStats(alertData, now);

      // Update Oldest Alert
      updateOldestAlert(alertData);

      // Update Alert Velocity
      updateAlertVelocity(alertData, now);

      // Update Recurring Systems
      updateRecurringSystems(alertData);

      // Update Recurring Accounts
      updateRecurringAccounts(alertData);

      // Update Timeline
      updateAlertTimeline(alertData, now);
    }

    function formatDuration(ms) {
      const seconds = Math.floor(ms / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);

      if (days > 0) {
        return `${days}d ${hours % 24}h`;
      } else if (hours > 0) {
        return `${hours}h ${minutes % 60}m`;
      } else if (minutes > 0) {
        return `${minutes}m`;
      } else {
        return `${seconds}s`;
      }
    }

    function updateQuickStats(alertData, now) {
      // Average time open
      if (alertData.length > 0) {
        const avgDuration = alertData.reduce((sum, a) => sum + a.duration, 0) / alertData.length;
        document.getElementById('avg-alert-time').textContent = formatDuration(avgDuration);
      } else {
        document.getElementById('avg-alert-time').textContent = '--';
      }

      // Oldest alert time
      if (alertData.length > 0) {
        const oldest = alertData.reduce((max, a) => a.duration > max.duration ? a : max);
        document.getElementById('oldest-alert-time').textContent = formatDuration(oldest.duration);
      } else {
        document.getElementById('oldest-alert-time').textContent = '--';
      }

      // Alert velocity (alerts in selected time range)
      const rangeMs = TimeRangeManager.getRangeMs();
      const rangeStart = new Date(now - rangeMs);
      const recentAlerts = alertData.filter(a => a.time >= rangeStart).length;
      document.getElementById('alert-velocity').textContent = recentAlerts;

      // Recurring systems count (systems with 2+ services alerting)
      const systemServices = {};
      alertData.forEach(a => {
        if (!systemServices[a.hostname]) {
          systemServices[a.hostname] = new Set();
        }
        a.services.split(',').forEach(s => {
          if (s.trim()) systemServices[a.hostname].add(s.trim());
        });
      });
      const recurringCount = Object.values(systemServices).filter(s => s.size >= 2).length;
      document.getElementById('recurring-count').textContent = recurringCount;

      // Health Score
      const healthScore = calculateHealthScore(alertData);
      const healthEl = document.getElementById('health-score');
      if (healthEl) {
        healthEl.textContent = healthScore;
        // Color based on score
        const parentIcon = healthEl.closest('.quick-stat')?.querySelector('.quick-stat-icon');
        if (parentIcon) {
          if (healthScore >= 80) {
            parentIcon.style.background = 'var(--healthy-bg)';
            parentIcon.style.color = 'var(--healthy)';
          } else if (healthScore >= 50) {
            parentIcon.style.background = 'var(--warning-bg)';
            parentIcon.style.color = 'var(--warning)';
          } else {
            parentIcon.style.background = 'var(--critical-bg)';
            parentIcon.style.color = 'var(--critical)';
          }
        }
      }

      // Alert Trend indicator
      const trendEl = document.getElementById('alert-trend');
      if (trendEl) {
        // Compare current period vs previous period
        const halfRange = rangeMs / 2;
        const midPoint = new Date(now - halfRange);
        const currentPeriod = alertData.filter(a => a.time >= midPoint).length;
        const previousPeriod = alertData.filter(a => a.time < midPoint && a.time >= rangeStart).length;

        if (previousPeriod === 0) {
          trendEl.className = 'trend-indicator stable';
          trendEl.textContent = '—';
        } else {
          const changePercent = Math.round(((currentPeriod - previousPeriod) / previousPeriod) * 100);
          if (changePercent > 10) {
            trendEl.className = 'trend-indicator up';
            trendEl.textContent = `↑ ${changePercent}%`;
          } else if (changePercent < -10) {
            trendEl.className = 'trend-indicator down';
            trendEl.textContent = `↓ ${Math.abs(changePercent)}%`;
          } else {
            trendEl.className = 'trend-indicator stable';
            trendEl.textContent = '— stable';
          }
        }
      }

      // Update export counts
      IncidentManager.updateExportCounts();
    }

    function updateOldestAlert(alertData) {
      const card = document.getElementById('oldest-alert-card');

      if (alertData.length === 0) {
        card.classList.remove('show');
        return;
      }

      const oldest = alertData.reduce((max, a) => a.duration > max.duration ? a : max);

      // Only show if older than 1 hour
      if (oldest.duration < 60 * 60 * 1000) {
        card.classList.remove('show');
        return;
      }

      card.classList.add('show');
      document.getElementById('oldest-hostname').textContent = oldest.hostname;
      document.getElementById('oldest-account').textContent = oldest.account;
      document.getElementById('oldest-started').textContent = oldest.time.toLocaleString();
      document.getElementById('oldest-duration').textContent = formatDuration(oldest.duration);
    }

    function updateAlertVelocity(alertData, now) {
      const chartContainer = document.getElementById('velocity-chart');
      const rangeMs = TimeRangeManager.getRangeMs();
      const range = TimeRangeManager.current;

      // Determine bucket count and size based on range
      let bucketCount, bucketMs, labelInterval;
      if (range === '1h') {
        bucketCount = 12; // 5-minute buckets
        bucketMs = 5 * 60 * 1000;
        labelInterval = 3;
      } else if (range === '6h') {
        bucketCount = 12; // 30-minute buckets
        bucketMs = 30 * 60 * 1000;
        labelInterval = 2;
      } else if (range === '7d') {
        bucketCount = 14; // 12-hour buckets
        bucketMs = 12 * 60 * 60 * 1000;
        labelInterval = 2;
      } else {
        // 24h default
        bucketCount = 24; // 1-hour buckets
        bucketMs = 60 * 60 * 1000;
        labelInterval = 4;
      }

      // Generate buckets
      const buckets = [];
      for (let i = bucketCount - 1; i >= 0; i--) {
        const bucketStart = new Date(now - (i + 1) * bucketMs);
        const bucketEnd = new Date(now - i * bucketMs);
        const count = alertData.filter(a => a.time >= bucketStart && a.time < bucketEnd).length;

        let label = '';
        if (i % labelInterval === 0) {
          if (range === '7d') {
            label = bucketEnd.toLocaleDateString('en-US', { weekday: 'short' });
          } else {
            label = `${bucketEnd.getHours()}:00`;
          }
        }

        buckets.push({ label, count });
      }

      const maxCount = Math.max(...buckets.map(b => b.count), 1);
      const totalAlerts = buckets.reduce((sum, b) => sum + b.count, 0);
      const avgAlerts = (totalAlerts / bucketCount).toFixed(1);
      const peakAlerts = maxCount;

      // Update legend
      document.getElementById('velocity-peak').textContent = peakAlerts;
      document.getElementById('velocity-avg').textContent = avgAlerts;
      document.getElementById('velocity-total').textContent = totalAlerts;

      // Generate bars
      chartContainer.innerHTML = buckets.map((bucket, i) => {
        const height = (bucket.count / maxCount) * 100;
        return `
          <div class="velocity-bar-wrapper">
            <div class="velocity-bar" style="height: ${Math.max(height, 4)}%" data-count="${bucket.count}"></div>
            <span class="velocity-label">${bucket.label}</span>
          </div>
        `;
      }).join('');
    }

    function updateRecurringSystems(alertData) {
      const container = document.getElementById('recurring-systems');

      // Count services per system
      const systemData = {};
      alertData.forEach(a => {
        if (!systemData[a.hostname]) {
          systemData[a.hostname] = {
            hostname: a.hostname,
            account: a.account,
            services: new Set(),
            alertCount: 0
          };
        }
        systemData[a.hostname].alertCount++;
        a.services.split(',').forEach(s => {
          if (s.trim()) systemData[a.hostname].services.add(s.trim());
        });
      });

      // Filter to recurring (2+ services) and sort
      const recurring = Object.values(systemData)
        .filter(s => s.services.size >= 2)
        .sort((a, b) => b.services.size - a.services.size)
        .slice(0, 5);

      if (recurring.length === 0) {
        container.innerHTML = `
          <div class="widget-empty">
            <div class="widget-empty-icon">
              <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                <polyline points="22 4 12 14.01 9 11.01"></polyline>
              </svg>
            </div>
            <span class="widget-empty-text">No recurring patterns detected</span>
          </div>
        `;
        return;
      }

      container.innerHTML = recurring.map((sys, i) => {
        const severity = sys.services.size >= 4 ? '' : sys.services.size >= 3 ? 'warning' : 'info';
        return `
          <div class="recurring-item ${severity}" onclick="filterByHostname('${sys.hostname}')">
            <span class="recurring-rank">${i + 1}</span>
            <div class="recurring-info">
              <div class="recurring-name">${sys.hostname}</div>
              <div class="recurring-meta">${sys.account}</div>
            </div>
            <div class="recurring-count">
              <span class="recurring-count-value">${sys.services.size}</span>
              <span class="recurring-count-label">services</span>
            </div>
          </div>
        `;
      }).join('');
    }

    function updateRecurringAccounts(alertData) {
      const container = document.getElementById('recurring-accounts');

      // Count alerts per account
      const accountData = {};
      alertData.forEach(a => {
        if (!accountData[a.account]) {
          accountData[a.account] = {
            account: a.account,
            hosts: new Set(),
            alertCount: 0
          };
        }
        accountData[a.account].alertCount++;
        accountData[a.account].hosts.add(a.hostname);
      });

      // Filter to accounts with 2+ hosts and sort
      const recurring = Object.values(accountData)
        .filter(a => a.hosts.size >= 2)
        .sort((a, b) => b.hosts.size - a.hosts.size)
        .slice(0, 5);

      if (recurring.length === 0) {
        container.innerHTML = `
          <div class="widget-empty">
            <div class="widget-empty-icon">
              <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                <polyline points="22 4 12 14.01 9 11.01"></polyline>
              </svg>
            </div>
            <span class="widget-empty-text">No recurring patterns detected</span>
          </div>
        `;
        return;
      }

      container.innerHTML = recurring.map((acct, i) => {
        const severity = acct.hosts.size >= 5 ? '' : acct.hosts.size >= 3 ? 'warning' : 'info';
        return `
          <div class="recurring-item ${severity}" onclick="filterByAccount('${acct.account}')">
            <span class="recurring-rank">${i + 1}</span>
            <div class="recurring-info">
              <div class="recurring-name">${acct.account}</div>
              <div class="recurring-meta">${acct.alertCount} total alerts</div>
            </div>
            <div class="recurring-count">
              <span class="recurring-count-value">${acct.hosts.size}</span>
              <span class="recurring-count-label">hosts</span>
            </div>
          </div>
        `;
      }).join('');
    }

    function updateAlertTimeline(alertData, now) {
      const timeline = document.getElementById('alert-timeline');
      const timelineWidth = timeline.offsetWidth;

      if (alertData.length === 0) {
        timeline.innerHTML = '';
        return;
      }

      // Use selected time range
      const rangeMs = TimeRangeManager.getRangeMs();
      const startTime = new Date(now - rangeMs);

      const markers = alertData
        .filter(a => a.time >= startTime)
        .map(a => {
          const position = ((a.time - startTime) / rangeMs) * 100;
          return `
            <div class="timeline-marker" style="left: ${position}%">
              <div class="timeline-tooltip">
                <strong>${a.hostname}</strong><br>
                ${a.time.toLocaleTimeString()}<br>
                ${a.services.split(',').slice(0, 2).join(', ')}
              </div>
            </div>
          `;
        }).join('');

      timeline.innerHTML = markers;
    }

    function filterByHostname(hostname) {
      document.getElementById('search-box').value = hostname;
      document.getElementById('search-form').submit();
    }

    function filterByAccount(account) {
      document.getElementById('search-box').value = account;
      document.getElementById('search-form').submit();
    }

    // ========================================
    // COUNT BADGES & EMPTY STATES
    // ========================================

    function updateCounts() {
      const activeTable = document.getElementById('active-table');
      const silencedTable = document.getElementById('silenced-table');

      const activeCount = activeTable ? activeTable.querySelectorAll('tbody tr:not(.filtered-out)').length : 0;
      const silencedCount = silencedTable ? silencedTable.querySelectorAll('tbody tr:not(.filtered-out)').length : 0;

      const activeBadge = document.getElementById('active-badge');
      const silencedBadge = document.getElementById('silenced-badge');
      const silencedCardCount = document.getElementById('silenced-count');

      if (activeBadge) activeBadge.textContent = activeCount;
      if (silencedBadge) silencedBadge.textContent = silencedCount;
      if (silencedCardCount) silencedCardCount.textContent = silencedCount;

      const activeEmpty = document.getElementById('active-empty');
      const silencedEmpty = document.getElementById('silenced-empty');
      const activeTableContainer = activeTable ? activeTable.closest('.table-container') : null;
      const silencedTableContainer = silencedTable ? silencedTable.closest('.table-container') : null;

      if (activeCount === 0) {
        if (activeTableContainer) activeTableContainer.style.display = 'none';
        if (activeEmpty) activeEmpty.style.display = 'block';
      } else {
        if (activeTableContainer) activeTableContainer.style.display = 'block';
        if (activeEmpty) activeEmpty.style.display = 'none';
      }

      if (silencedCount === 0) {
        if (silencedTableContainer) silencedTableContainer.style.display = 'none';
        if (silencedEmpty) silencedEmpty.style.display = 'block';
      } else {
        if (silencedTableContainer) silencedTableContainer.style.display = 'block';
        if (silencedEmpty) silencedEmpty.style.display = 'none';
      }

      // Update widgets
      updateDashboardWidgets();
    }

    // ========================================
    // TOAST NOTIFICATIONS
    // ========================================

    function showToast(message, type = 'success') {
      const container = document.getElementById('toast-container');
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          ${type === 'success' ?
            '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline>' :
            '<circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>'
          }
        </svg>
        <span>${message}</span>
      `;

      container.appendChild(toast);

      setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transform = 'translateX(20px)';
        setTimeout(() => toast.remove(), 200);
      }, 3000);
    }

    // ========================================
    // KEYBOARD NAVIGATION
    // ========================================

    document.addEventListener('keydown', function(e) {
      // Don't trigger shortcuts when typing in inputs
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
        if (e.key === 'Escape') {
          e.target.blur();
        }
        return;
      }

      // Alt+1 = Active tab, Alt+2 = Silenced tab
      if (e.altKey && e.key === '1') {
        e.preventDefault();
        document.querySelector('.tab-btn').click();
      }
      if (e.altKey && e.key === '2') {
        e.preventDefault();
        document.querySelectorAll('.tab-btn')[1].click();
      }

      // / to focus search
      if (e.key === '/' && !e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        document.getElementById('search-box').focus();
      }

      // ? to show shortcuts
      if (e.key === '?' || (e.shiftKey && e.key === '/')) {
        e.preventDefault();
        ShortcutsModal.toggle();
      }

      // F to toggle filters
      if (e.key === 'f' || e.key === 'F') {
        e.preventDefault();
        FilterManager.togglePanel();
      }

      // T to toggle theme
      if (e.key === 't' || e.key === 'T') {
        e.preventDefault();
        ThemeManager.toggle();
        showToast(`Switched to ${document.documentElement.getAttribute('data-theme')} mode`, 'success');
      }

      // R to refresh
      if (e.key === 'r' || e.key === 'R') {
        e.preventDefault();
        RefreshManager.refresh();
      }

      // Escape to close modals
      if (e.key === 'Escape') {
        ShortcutsModal.close();
        HelpModal.close();
        ColumnManager.close();
        AlertDrawer.close();
        document.getElementById('filters-panel').classList.remove('show');
        document.getElementById('refresh-dropdown').classList.remove('show');
        document.getElementById('export-menu').classList.remove('show');
      }

      // Ctrl+A to select all in current table
      if (e.ctrlKey && e.key === 'a') {
        e.preventDefault();
        const activePanel = document.querySelector('.tab-panel[style*="block"]') || document.getElementById('active');
        const headerCheckbox = activePanel.querySelector('.row-checkbox-header');
        if (headerCheckbox) {
          headerCheckbox.checked = true;
          headerCheckbox.dispatchEvent(new Event('change'));
        }
      }

      // D to cycle through density modes
      if (e.key === 'd' || e.key === 'D') {
        e.preventDefault();
        const densities = ['compact', 'comfortable', 'spacious'];
        const currentIndex = densities.indexOf(DensityManager.current);
        const nextIndex = (currentIndex + 1) % densities.length;
        DensityManager.setDensity(densities[nextIndex]);
        showToast(`Switched to ${densities[nextIndex]} view`, 'success');
      }

      // C to open column configuration
      if (e.key === 'c' || e.key === 'C') {
        e.preventDefault();
        ColumnManager.open();
      }

      // H to open help
      if (e.key === 'h' || e.key === 'H') {
        e.preventDefault();
        HelpModal.toggle();
      }
    });

    // ========================================
    // SECTION COLLAPSE MANAGER
    // ========================================

    const SectionManager = {
      collapsed: {},
      // Sections that should be collapsed by default
      defaultCollapsed: ['distribution', 'metrics', 'charts', 'incidents'],

      init() {
        const saved = localStorage.getItem('prometheos-collapsed-sections');

        if (saved) {
          // Use saved preferences
          this.collapsed = JSON.parse(saved);
        } else {
          // First load: collapse all analytics sections by default
          this.defaultCollapsed.forEach(section => {
            this.collapsed[section] = true;
          });
        }

        // Apply states
        Object.keys(this.collapsed).forEach(section => {
          if (this.collapsed[section]) {
            this.setCollapsed(section, true, false);
          }
        });

        // Save initial state if first load
        if (!saved) {
          localStorage.setItem('prometheos-collapsed-sections', JSON.stringify(this.collapsed));
        }
      },

      toggle(section) {
        const isCollapsed = this.collapsed[section] || false;
        this.setCollapsed(section, !isCollapsed, true);
      },

      setCollapsed(section, collapsed, save = true) {
        const header = document.querySelector(`#${section}-section .section-header`);
        const content = document.getElementById(`${section}-content`);

        if (header && content) {
          header.classList.toggle('collapsed', collapsed);
          content.classList.toggle('collapsed', collapsed);
        }

        this.collapsed[section] = collapsed;

        if (save) {
          localStorage.setItem('prometheos-collapsed-sections', JSON.stringify(this.collapsed));
        }
      }
    };

    // ========================================
    // TIME RANGE MANAGER
    // ========================================

    const TimeRangeManager = {
      current: '24h',
      rangeMs: {
        '1h': 60 * 60 * 1000,
        '6h': 6 * 60 * 60 * 1000,
        '24h': 24 * 60 * 60 * 1000,
        '7d': 7 * 24 * 60 * 60 * 1000
      },

      init() {
        const saved = localStorage.getItem('prometheos-analytics-range');
        if (saved && this.rangeMs[saved]) {
          this.current = saved;
        }

        this.updateUI();
        this.bindEvents();
      },

      bindEvents() {
        document.querySelectorAll('.time-range-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const range = btn.dataset.range;
            this.setRange(range);
          });
        });
      },

      setRange(range) {
        this.current = range;
        localStorage.setItem('prometheos-analytics-range', range);
        this.updateUI();
        updateAdvancedAnalytics();
        showToast(`Analytics range set to ${this.getRangeLabel(range)}`, 'success');
      },

      updateUI() {
        document.querySelectorAll('.time-range-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.range === this.current);
        });

        // Update labels
        const velocityLabel = document.getElementById('velocity-range-label');
        if (velocityLabel) {
          velocityLabel.textContent = this.getRangeLabel(this.current);
        }

        const timelineStart = document.getElementById('timeline-start');
        if (timelineStart) {
          timelineStart.textContent = this.getRangeLabel(this.current) + ' ago';
        }
      },

      getRangeLabel(range) {
        const labels = { '1h': '1 hour', '6h': '6 hours', '24h': '24 hours', '7d': '7 days' };
        return labels[range] || range;
      },

      getRangeMs() {
        return this.rangeMs[this.current] || this.rangeMs['24h'];
      }
    };

    // ========================================
    // INCIDENT MANAGER
    // ========================================

    const IncidentManager = {
      incidents: [],
      selectedAlerts: new Set(),
      windowMinutes: 5,
      CLUSTER_WINDOW_MS: 5 * 60 * 1000, // 5 minutes (default)
      minAlerts: 3,  // Minimum alerts to form an incident
      minHosts: 2,   // Minimum unique hosts to form an incident

      init() {
        // Load saved window setting
        const savedWindow = localStorage.getItem('prometheos-incident-window');
        if (savedWindow) {
          this.windowMinutes = parseInt(savedWindow) || 5;
          this.CLUSTER_WINDOW_MS = this.windowMinutes * 60 * 1000;
        }

        // Load saved threshold settings
        const savedMinAlerts = localStorage.getItem('prometheos-incident-min-alerts');
        const savedMinHosts = localStorage.getItem('prometheos-incident-min-hosts');
        if (savedMinAlerts) this.minAlerts = parseInt(savedMinAlerts) || 3;
        if (savedMinHosts) this.minHosts = parseInt(savedMinHosts) || 2;

        // Update select elements
        const windowSelect = document.getElementById('incident-window-select');
        if (windowSelect) windowSelect.value = this.windowMinutes.toString();

        const minAlertsSelect = document.getElementById('incident-min-alerts');
        if (minAlertsSelect) minAlertsSelect.value = this.minAlerts.toString();

        const minHostsSelect = document.getElementById('incident-min-hosts');
        if (minHostsSelect) minHostsSelect.value = this.minHosts.toString();

        const saved = localStorage.getItem('prometheos-incidents');
        this.incidents = saved ? JSON.parse(saved) : [];
        this.detectIncidents();
        this.render();
        this.updateExportCounts();
      },

      setWindow(minutes) {
        this.windowMinutes = parseInt(minutes) || 5;
        this.CLUSTER_WINDOW_MS = this.windowMinutes * 60 * 1000;
        localStorage.setItem('prometheos-incident-window', this.windowMinutes.toString());
        showToast(`Incident window set to ${this.windowMinutes} minutes`, 'success');
      },

      setMinAlerts(count) {
        this.minAlerts = parseInt(count) || 3;
        localStorage.setItem('prometheos-incident-min-alerts', this.minAlerts.toString());
        showToast(`Minimum alerts set to ${this.minAlerts}`, 'success');
      },

      setMinHosts(count) {
        this.minHosts = parseInt(count) || 2;
        localStorage.setItem('prometheos-incident-min-hosts', this.minHosts.toString());
        showToast(`Minimum hosts set to ${this.minHosts}`, 'success');
      },

      rescan() {
        // Preserve only "saved" incidents (ones with custom names or notes)
        const savedIncidents = this.incidents.filter(inc => this.isIncidentSaved(inc));
        this.incidents = savedIncidents;

        // Re-detect and merge
        this.detectIncidents();

        const newCount = this.incidents.length - savedIncidents.length;
        showToast(`Rescanned: found ${newCount} new incident(s), preserved ${savedIncidents.length} saved`, 'success');
      },

      isIncidentSaved(incident) {
        // An incident is considered "saved" if:
        // 1. It has notes
        // 2. Its name was manually changed (not an auto-generated name)
        // 3. Its status was changed from 'investigating'
        const autoGeneratedPrefixes = [
          'Incident ',
          'Incident (',
          'Multi-Location Incident',
          'Multi-Account Incident',
          'Major Incident',
          'Manual Incident'
        ];
        const isAutoName = autoGeneratedPrefixes.some(prefix => incident.name.startsWith(prefix));

        return (
          (incident.notes && incident.notes.length > 0) ||
          !isAutoName ||
          incident.status !== 'investigating'
        );
      },

      detectIncidents() {
        const rows = document.querySelectorAll('#active-table tbody tr:not(.filtered-out)');
        const alerts = [];

        rows.forEach(row => {
          const timeStr = row.dataset.time;
          if (timeStr) {
            alerts.push({
              id: row.dataset.hostname + '-' + timeStr,
              hostname: row.querySelector('.hostname')?.textContent.trim() || '',
              account: row.querySelector('.cell-primary')?.textContent.trim() || '',
              time: new Date(timeStr.replace(' ', 'T')),
              timeStr: timeStr,
              services: row.dataset.services || '',
              location: row.dataset.location || ''
            });
          }
        });

        // Sort by time
        alerts.sort((a, b) => a.time - b.time);

        // Cluster alerts within CLUSTER_WINDOW_MS
        const newIncidents = [];
        let currentCluster = [];

        alerts.forEach((alert, i) => {
          if (currentCluster.length === 0) {
            currentCluster.push(alert);
          } else {
            const lastAlert = currentCluster[currentCluster.length - 1];
            const timeDiff = alert.time - lastAlert.time;

            if (timeDiff <= this.CLUSTER_WINDOW_MS) {
              currentCluster.push(alert);
            } else {
              // Check if cluster meets incident criteria
              if (this.meetsIncidentCriteria(currentCluster)) {
                newIncidents.push(this.createIncidentFromCluster(currentCluster));
              }
              currentCluster = [alert];
            }
          }
        });

        // Don't forget the last cluster
        if (this.meetsIncidentCriteria(currentCluster)) {
          newIncidents.push(this.createIncidentFromCluster(currentCluster));
        }

        // Merge with existing incidents (preserve names and notes)
        this.mergeIncidents(newIncidents);
        this.save();
        this.render();
        this.updateIncidentCounts();
      },

      meetsIncidentCriteria(cluster) {
        // Minimum 3 alerts required (configurable)
        const minAlerts = this.minAlerts || 3;
        if (cluster.length < minAlerts) return false;

        // Must involve at least 2 unique hosts (configurable)
        const minHosts = this.minHosts || 2;
        const uniqueHosts = new Set(cluster.map(a => a.hostname)).size;
        if (uniqueHosts < minHosts) return false;

        return true;
      },

      getClusterStats(cluster) {
        const uniqueHosts = new Set(cluster.map(a => a.hostname));
        const uniqueAccounts = new Set(cluster.map(a => a.account));
        const uniqueLocations = new Set(cluster.map(a => a.location).filter(l => l));

        return {
          alertCount: cluster.length,
          hostCount: uniqueHosts.size,
          accountCount: uniqueAccounts.size,
          locationCount: uniqueLocations.size,
          hosts: [...uniqueHosts],
          accounts: [...uniqueAccounts],
          locations: [...uniqueLocations]
        };
      },

      createIncidentFromCluster(cluster) {
        const firstAlert = cluster[0];
        const lastAlert = cluster[cluster.length - 1];
        const stats = this.getClusterStats(cluster);

        // Generate a more descriptive name
        let name;
        if (stats.locationCount > 1) {
          name = `Multi-Location Incident (${stats.hostCount} hosts, ${stats.locationCount} locations)`;
        } else if (stats.accountCount > 1) {
          name = `Multi-Account Incident (${stats.hostCount} hosts, ${stats.accountCount} accounts)`;
        } else if (stats.hostCount > 3) {
          name = `Major Incident (${stats.hostCount} hosts affected)`;
        } else {
          name = `Incident (${stats.hostCount} hosts, ${cluster.length} alerts)`;
        }

        return {
          id: Date.now() + Math.random().toString(36).substr(2, 9),
          name: name,
          status: 'investigating',
          alerts: cluster,
          stats: stats,
          startTime: firstAlert.time.toISOString(),
          endTime: lastAlert.time.toISOString(),
          notes: [],
          createdAt: new Date().toISOString()
        };
      },

      createFromAlerts(alertsData) {
        // Create incident from bulk-selected alerts
        const alerts = alertsData.map(a => ({
          id: a.hostname + '-' + a.time,
          hostname: a.hostname,
          account: a.account,
          time: new Date(a.time?.replace(' ', 'T') || Date.now()),
          timeStr: a.time,
          services: a.services,
          location: a.location
        }));

        alerts.sort((a, b) => a.time - b.time);

        const incident = {
          id: Date.now() + Math.random().toString(36).substr(2, 9),
          name: `Manual Incident ${new Date().toLocaleString()}`,
          status: 'investigating',
          alerts: alerts,
          startTime: alerts[0]?.time?.toISOString() || new Date().toISOString(),
          endTime: alerts[alerts.length - 1]?.time?.toISOString() || new Date().toISOString(),
          notes: [],
          createdAt: new Date().toISOString()
        };

        this.incidents.push(incident);
        this.save();
        this.render();
        this.updateIncidentCounts();

        // Expand incidents section
        SectionManager.setCollapsed('incidents', false);
      },

      mergeIncidents(newIncidents) {
        // Simple merge: keep existing incident data if alert IDs overlap
        const existingById = {};
        this.incidents.forEach(inc => {
          const alertIds = inc.alerts.map(a => a.id).join(',');
          existingById[alertIds] = inc;
        });

        this.incidents = newIncidents.map(newInc => {
          const alertIds = newInc.alerts.map(a => a.id).join(',');
          if (existingById[alertIds]) {
            // Preserve name, status, and notes from existing
            return {
              ...newInc,
              id: existingById[alertIds].id,
              name: existingById[alertIds].name,
              status: existingById[alertIds].status,
              notes: existingById[alertIds].notes
            };
          }
          return newInc;
        });
      },

      updateIncidentCounts() {
        const countEl = document.getElementById('incidents-count');
        const badgeEl = document.getElementById('incidents-badge');

        if (countEl) countEl.textContent = this.incidents.length;
        if (badgeEl) badgeEl.textContent = `${this.incidents.length} groups`;
      },

      updateExportCounts() {
        const activeRows = document.querySelectorAll('#active-table tbody tr:not(.filtered-out)');
        const csvCount = document.getElementById('export-csv-count');
        const jsonCount = document.getElementById('export-json-count');
        const incidentsCount = document.getElementById('export-incidents-count');

        if (csvCount) csvCount.textContent = `${activeRows.length} rows`;
        if (jsonCount) jsonCount.textContent = `${activeRows.length} rows`;
        if (incidentsCount) incidentsCount.textContent = `${this.incidents.length} incidents`;
      },

      render() {
        const container = document.getElementById('incidents-list');
        if (!container) return;

        if (this.incidents.length === 0) {
          container.innerHTML = `
            <div class="widget-empty">
              <div class="widget-empty-icon">
                <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                  <path d="M12 2L2 7l10 5 10-5-10-5z"></path>
                  <path d="M2 17l10 5 10-5"></path>
                  <path d="M2 12l10 5 10-5"></path>
                </svg>
              </div>
              <span class="widget-empty-text">No incidents detected. Requires ${this.minAlerts}+ alerts across ${this.minHosts}+ hosts within ${this.windowMinutes} min.</span>
            </div>
          `;
          return;
        }

        container.innerHTML = this.incidents.map(incident => this.renderIncident(incident)).join('');
      },

      renderIncident(incident) {
        const alertCount = incident.alerts.length;
        const duration = new Date(incident.endTime) - new Date(incident.startTime);
        const durationStr = formatDuration(duration);

        // Get stats (either from stored stats or calculate)
        const stats = incident.stats || this.getClusterStats(incident.alerts);
        const hostCount = stats.hostCount || new Set(incident.alerts.map(a => a.hostname)).size;

        // Severity based on host count for multi-system outages
        const severityClass = hostCount >= 5 ? '' : hostCount >= 3 ? 'warning' : 'info';

        return `
          <div class="incident-group" id="incident-${incident.id}" data-id="${incident.id}">
            <div class="incident-header" onclick="IncidentManager.toggleExpand('${incident.id}')">
              <div class="incident-expand-icon">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <polyline points="9 18 15 12 9 6"></polyline>
                </svg>
              </div>
              <div class="incident-color-bar ${severityClass}"></div>
              <div class="incident-info">
                <div class="incident-name-row">
                  <span class="incident-name" id="incident-name-${incident.id}">${this.escapeHtml(incident.name)}</span>
                  <button type="button" class="incident-edit-btn" onclick="event.stopPropagation(); IncidentManager.editName('${incident.id}')" title="Edit name">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                      <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                    </svg>
                  </button>
                  <span class="incident-status-badge ${incident.status}">${incident.status}</span>
                </div>
                <div class="incident-meta">
                  Started ${new Date(incident.startTime).toLocaleString()} &bull; Span: ${durationStr}
                </div>
              </div>
              <div class="incident-stats">
                <div class="incident-stat">
                  <div class="incident-stat-value">${hostCount}</div>
                  <div class="incident-stat-label">Hosts</div>
                </div>
                <div class="incident-stat">
                  <div class="incident-stat-value">${alertCount}</div>
                  <div class="incident-stat-label">Alerts</div>
                </div>
              </div>
              <div class="incident-actions">
                <div class="status-selector">
                  <button type="button" class="incident-action-btn" onclick="event.stopPropagation(); IncidentManager.toggleStatusDropdown('${incident.id}')" title="Change status">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <circle cx="12" cy="12" r="10"></circle>
                      <polyline points="12 6 12 12 16 14"></polyline>
                    </svg>
                  </button>
                  <div class="status-dropdown" id="status-dropdown-${incident.id}">
                    <div class="status-option" onclick="event.stopPropagation(); IncidentManager.setStatus('${incident.id}', 'investigating')">
                      <span class="status-dot investigating"></span>
                      <span>Investigating</span>
                    </div>
                    <div class="status-option" onclick="event.stopPropagation(); IncidentManager.setStatus('${incident.id}', 'identified')">
                      <span class="status-dot identified"></span>
                      <span>Identified</span>
                    </div>
                    <div class="status-option" onclick="event.stopPropagation(); IncidentManager.setStatus('${incident.id}', 'monitoring')">
                      <span class="status-dot monitoring"></span>
                      <span>Monitoring</span>
                    </div>
                    <div class="status-option" onclick="event.stopPropagation(); IncidentManager.setStatus('${incident.id}', 'resolved')">
                      <span class="status-dot resolved"></span>
                      <span>Resolved</span>
                    </div>
                  </div>
                </div>
                <button type="button" class="incident-action-btn" onclick="event.stopPropagation(); IncidentManager.deleteIncident('${incident.id}')" title="Delete incident">
                  <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                  </svg>
                </button>
              </div>
            </div>
            <div class="incident-body">
              <div class="incident-alerts">
                ${incident.alerts.map(alert => `
                  <div class="incident-alert-item">
                    <div class="incident-alert-info">
                      <div class="incident-alert-hostname">${this.escapeHtml(alert.hostname)}</div>
                      <div class="incident-alert-meta">${this.escapeHtml(alert.account)} &bull; ${this.escapeHtml(alert.services.split(',').slice(0, 2).join(', '))}</div>
                    </div>
                    <div class="incident-alert-time">${alert.timeStr}</div>
                  </div>
                `).join('')}
              </div>
              <div class="incident-notes">
                <div class="incident-notes-header">
                  <span class="incident-notes-title">Notes & Annotations</span>
                </div>
                <div class="incident-notes-list" id="notes-list-${incident.id}">
                  ${incident.notes.length === 0 ? '' : incident.notes.map(note => `
                    <div class="incident-note">
                      <div class="incident-note-header">
                        <span class="incident-note-author">${this.escapeHtml(note.author || 'User')}</span>
                        <span class="incident-note-time">${new Date(note.createdAt).toLocaleString()}</span>
                      </div>
                      <div class="incident-note-text">${this.escapeHtml(note.text)}</div>
                    </div>
                  `).join('')}
                </div>
                <div class="incident-note-input">
                  <textarea class="incident-note-textarea" id="note-input-${incident.id}" placeholder="Add a note about this incident..."></textarea>
                  <button type="button" class="btn btn-sm btn-primary" onclick="IncidentManager.addNote('${incident.id}')">Add</button>
                </div>
              </div>
            </div>
          </div>
        `;
      },

      toggleExpand(id) {
        const el = document.getElementById(`incident-${id}`);
        if (el) {
          el.classList.toggle('expanded');
        }
      },

      toggleStatusDropdown(id) {
        // Close all other dropdowns first
        document.querySelectorAll('.status-dropdown.show').forEach(d => d.classList.remove('show'));

        const dropdown = document.getElementById(`status-dropdown-${id}`);
        if (dropdown) {
          dropdown.classList.toggle('show');
        }
      },

      setStatus(id, status) {
        const incident = this.incidents.find(i => i.id === id);
        if (incident) {
          incident.status = status;
          this.save();
          this.render();
          showToast(`Incident status set to ${status}`, 'success');
        }
      },

      editName(id) {
        const nameEl = document.getElementById(`incident-name-${id}`);
        if (!nameEl) return;

        const currentName = nameEl.textContent;
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'incident-name-input';
        input.value = currentName;

        const saveName = () => {
          const newName = input.value.trim() || currentName;
          const incident = this.incidents.find(i => i.id === id);
          if (incident) {
            incident.name = newName;
            this.save();
            this.render();
          }
        };

        input.addEventListener('blur', saveName);
        input.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            saveName();
          }
        });

        nameEl.replaceWith(input);
        input.focus();
        input.select();
      },

      addNote(id) {
        const input = document.getElementById(`note-input-${id}`);
        if (!input || !input.value.trim()) return;

        const incident = this.incidents.find(i => i.id === id);
        if (incident) {
          incident.notes.push({
            id: Date.now(),
            text: input.value.trim(),
            author: 'User',
            createdAt: new Date().toISOString()
          });
          this.save();
          this.render();
          showToast('Note added', 'success');

          // Re-expand the incident
          setTimeout(() => {
            const el = document.getElementById(`incident-${id}`);
            if (el) el.classList.add('expanded');
          }, 10);
        }
      },

      deleteIncident(id) {
        if (!confirm('Delete this incident grouping? The alerts will remain but the grouping and notes will be lost.')) {
          return;
        }

        this.incidents = this.incidents.filter(i => i.id !== id);
        this.save();
        this.render();
        this.updateIncidentCounts();
        showToast('Incident deleted', 'success');
      },

      save() {
        localStorage.setItem('prometheos-incidents', JSON.stringify(this.incidents));
      },

      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      },

      // Selection for manual incident creation
      toggleAlertSelection(alertId) {
        if (this.selectedAlerts.has(alertId)) {
          this.selectedAlerts.delete(alertId);
        } else {
          this.selectedAlerts.add(alertId);
        }
        this.updateSelectionUI();
      },

      updateSelectionUI() {
        const bar = document.getElementById('create-incident-bar');
        const countEl = document.getElementById('selected-for-incident');

        if (this.selectedAlerts.size > 0) {
          bar.classList.add('show');
          countEl.textContent = this.selectedAlerts.size;
        } else {
          bar.classList.remove('show');
        }
      },

      clearSelection() {
        this.selectedAlerts.clear();
        this.updateSelectionUI();
      },

      createFromSelection() {
        // Implementation for manual incident creation from selected alerts
        showToast('Manual incident creation - select alerts from the table first', 'info');
      }
    };

    // ========================================
    // ENHANCED EXPORT MANAGER
    // ========================================

    const ExportManagerEnhanced = {
      exportWithAnnotations(format) {
        const activePanel = document.querySelector('.tab-panel[style*="block"]') || document.getElementById('active');
        const table = activePanel.querySelector('.data-table');

        if (!table) return;

        const rows = table.querySelectorAll('tbody tr:not(.filtered-out)');
        const data = [];

        rows.forEach(row => {
          const cells = row.querySelectorAll('td');
          const hostname = cells[3]?.textContent.trim() || '';

          // Find if this alert is part of any incident
          let incidentName = '';
          let incidentStatus = '';
          let incidentNotes = [];

          IncidentManager.incidents.forEach(incident => {
            incident.alerts.forEach(alert => {
              if (alert.hostname === hostname) {
                incidentName = incident.name;
                incidentStatus = incident.status;
                incidentNotes = incident.notes.map(n => n.text);
              }
            });
          });

          data.push({
            uid: cells[1]?.textContent.trim() || '',
            account: cells[2]?.textContent.trim() || '',
            hostname: hostname,
            location: cells[4]?.textContent.trim() || '',
            promNode: cells[5]?.textContent.trim() || '',
            startTime: cells[6]?.textContent.trim() || '',
            services: Array.from(cells[7]?.querySelectorAll('.service-tag') || []).map(t => t.textContent.trim()),
            incidentName: incidentName,
            incidentStatus: incidentStatus,
            notes: incidentNotes
          });
        });

        if (format === 'json') {
          const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
          downloadBlob(blob, `prometheos-alerts-annotated-${new Date().toISOString().slice(0, 10)}.json`);
          showToast('Exported with annotations as JSON', 'success');
        } else if (format === 'csv') {
          let csv = 'UID,Account,Hostname,Location,Prom Node,Start Time,Services,Incident,Status,Notes\n';
          data.forEach(row => {
            csv += `"${row.uid}","${row.account}","${row.hostname}","${row.location}","${row.promNode}","${row.startTime}","${row.services.join('; ')}","${row.incidentName}","${row.incidentStatus}","${row.notes.join(' | ')}"\n`;
          });
          const blob = new Blob([csv], { type: 'text/csv' });
          downloadBlob(blob, `prometheos-alerts-annotated-${new Date().toISOString().slice(0, 10)}.csv`);
          showToast('Exported with annotations as CSV', 'success');
        }

        document.getElementById('export-menu').classList.remove('show');
      },

      exportIncidents(format) {
        const incidents = IncidentManager.incidents;

        if (incidents.length === 0) {
          showToast('No incidents to export', 'error');
          return;
        }

        const data = incidents.map(incident => ({
          id: incident.id,
          name: incident.name,
          status: incident.status,
          startTime: incident.startTime,
          endTime: incident.endTime,
          alertCount: incident.alerts.length,
          alerts: incident.alerts.map(a => ({
            hostname: a.hostname,
            account: a.account,
            time: a.timeStr,
            services: a.services
          })),
          notes: incident.notes.map(n => ({
            text: n.text,
            author: n.author,
            time: n.createdAt
          })),
          createdAt: incident.createdAt
        }));

        if (format === 'json') {
          const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
          downloadBlob(blob, `prometheos-incidents-${new Date().toISOString().slice(0, 10)}.json`);
          showToast('Incidents exported as JSON', 'success');
        } else if (format === 'csv') {
          let csv = 'Incident ID,Name,Status,Start Time,End Time,Alert Count,Hostnames,Notes\n';
          data.forEach(inc => {
            const hostnames = inc.alerts.map(a => a.hostname).join('; ');
            const notes = inc.notes.map(n => n.text).join(' | ');
            csv += `"${inc.id}","${inc.name}","${inc.status}","${inc.startTime}","${inc.endTime}","${inc.alertCount}","${hostnames}","${notes}"\n`;
          });
          const blob = new Blob([csv], { type: 'text/csv' });
          downloadBlob(blob, `prometheos-incidents-${new Date().toISOString().slice(0, 10)}.csv`);
          showToast('Incidents exported as CSV', 'success');
        }

        document.getElementById('export-menu').classList.remove('show');
      }
    };

    // Attach to ExportManager for button onclick handlers
    if (typeof ExportManager !== 'undefined') {
      ExportManager.exportWithAnnotations = ExportManagerEnhanced.exportWithAnnotations;
      ExportManager.exportIncidents = ExportManagerEnhanced.exportIncidents;
    }

    // ========================================
    // HEALTH SCORE CALCULATOR
    // ========================================

    function calculateHealthScore(alertData) {
      if (alertData.length === 0) return 100;

      const now = new Date();
      let score = 100;

      // Deduct points based on various factors
      // Alert count penalty (max -30)
      score -= Math.min(alertData.length * 2, 30);

      // Long-running alerts penalty (max -20)
      const longRunning = alertData.filter(a => a.duration > 60 * 60 * 1000).length;
      score -= Math.min(longRunning * 5, 20);

      // Recurring systems penalty (max -20)
      const systemCounts = {};
      alertData.forEach(a => {
        systemCounts[a.hostname] = (systemCounts[a.hostname] || 0) + 1;
      });
      const recurringCount = Object.values(systemCounts).filter(c => c >= 2).length;
      score -= Math.min(recurringCount * 5, 20);

      // Recent velocity penalty (max -15)
      const oneHourAgo = new Date(now - 60 * 60 * 1000);
      const recentAlerts = alertData.filter(a => a.time >= oneHourAgo).length;
      score -= Math.min(recentAlerts * 3, 15);

      // Incident count penalty (max -15)
      score -= Math.min(IncidentManager.incidents.length * 3, 15);

      return Math.max(0, Math.round(score));
    }

    // ========================================
    // DENSITY/VIEW MODE MANAGER
    // ========================================

    const DensityManager = {
      current: 'comfortable',

      init() {
        // Load saved density preference
        const savedDensity = localStorage.getItem('prometheos-density') || 'comfortable';
        this.setDensity(savedDensity);

        // Toggle dropdown
        const toggleBtn = document.getElementById('view-toggle-btn');
        const dropdown = document.getElementById('view-dropdown');

        if (toggleBtn && dropdown) {
          toggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            dropdown.classList.toggle('show');
          });

          // Option selection
          document.querySelectorAll('.view-option').forEach(option => {
            option.addEventListener('click', () => {
              const density = option.dataset.density;
              this.setDensity(density);
              dropdown.classList.remove('show');
              showToast(`Switched to ${density} view`, 'success');
            });
          });

          // Close on outside click
          document.addEventListener('click', () => {
            dropdown.classList.remove('show');
          });
        }
      },

      setDensity(density) {
        this.current = density;
        document.documentElement.setAttribute('data-density', density);
        localStorage.setItem('prometheos-density', density);

        // Update UI
        document.querySelectorAll('.view-option').forEach(option => {
          option.classList.toggle('selected', option.dataset.density === density);
        });
      }
    };

    // ========================================
    // SAVED FILTER PRESETS MANAGER
    // ========================================

    const PresetsManager = {
      presets: [],

      init() {
        // Load saved presets from localStorage
        const saved = localStorage.getItem('prometheos-filter-presets');
        this.presets = saved ? JSON.parse(saved) : [];

        this.render();
        this.bindEvents();
      },

      bindEvents() {
        const presetsBtn = document.getElementById('presets-btn');
        const presetsDropdown = document.getElementById('presets-dropdown');
        const presetNameInput = document.getElementById('preset-name-input');
        const savePresetBtn = document.getElementById('save-preset-btn');

        if (!presetsBtn || !presetsDropdown) return;

        // Toggle dropdown
        presetsBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          presetsDropdown.classList.toggle('show');
        });

        // Close on outside click
        document.addEventListener('click', (e) => {
          if (!presetsDropdown.contains(e.target)) {
            presetsDropdown.classList.remove('show');
          }
        });

        // Prevent dropdown from closing when clicking inside
        presetsDropdown.addEventListener('click', (e) => {
          e.stopPropagation();
        });

        // Enable/disable save button based on input
        if (presetNameInput && savePresetBtn) {
          presetNameInput.addEventListener('input', () => {
            const hasFilters = this.hasActiveFilters();
            const hasName = presetNameInput.value.trim().length > 0;
            savePresetBtn.disabled = !(hasFilters && hasName);
          });

          // Save preset on button click
          savePresetBtn.addEventListener('click', () => {
            this.saveCurrentFilters(presetNameInput.value.trim());
            presetNameInput.value = '';
            savePresetBtn.disabled = true;
          });

          // Save on Enter key
          presetNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !savePresetBtn.disabled) {
              this.saveCurrentFilters(presetNameInput.value.trim());
              presetNameInput.value = '';
              savePresetBtn.disabled = true;
            }
          });
        }
      },

      hasActiveFilters() {
        const location = document.getElementById('filter-location')?.value || '';
        const prom = document.getElementById('filter-prom')?.value || '';
        const time = document.getElementById('filter-time')?.value || '';
        const service = document.getElementById('filter-service')?.value || '';
        const search = document.getElementById('search-box')?.value || '';

        return location || prom || time || service || search;
      },

      getCurrentFilters() {
        return {
          location: document.getElementById('filter-location')?.value || '',
          prom: document.getElementById('filter-prom')?.value || '',
          time: document.getElementById('filter-time')?.value || '',
          service: document.getElementById('filter-service')?.value || '',
          search: document.getElementById('search-box')?.value || ''
        };
      },

      saveCurrentFilters(name) {
        if (!name || !this.hasActiveFilters()) return;

        const preset = {
          id: Date.now(),
          name: name,
          filters: this.getCurrentFilters(),
          createdAt: new Date().toISOString()
        };

        this.presets.unshift(preset);

        // Limit to 10 presets
        if (this.presets.length > 10) {
          this.presets = this.presets.slice(0, 10);
        }

        this.save();
        this.render();
        showToast(`Saved preset: ${name}`, 'success');
      },

      applyPreset(id) {
        const preset = this.presets.find(p => p.id === id);
        if (!preset) return;

        const filters = preset.filters;

        // Apply filter values
        if (document.getElementById('filter-location')) {
          document.getElementById('filter-location').value = filters.location || '';
        }
        if (document.getElementById('filter-prom')) {
          document.getElementById('filter-prom').value = filters.prom || '';
        }
        if (document.getElementById('filter-time')) {
          document.getElementById('filter-time').value = filters.time || '';
        }
        if (document.getElementById('filter-service')) {
          document.getElementById('filter-service').value = filters.service || '';
        }
        if (document.getElementById('search-box') && filters.search) {
          document.getElementById('search-box').value = filters.search;
        }

        // Apply the filters
        FilterManager.apply();

        // Close dropdown
        document.getElementById('presets-dropdown').classList.remove('show');

        showToast(`Applied preset: ${preset.name}`, 'success');
      },

      deletePreset(id) {
        this.presets = this.presets.filter(p => p.id !== id);
        this.save();
        this.render();
        showToast('Preset deleted', 'success');
      },

      save() {
        localStorage.setItem('prometheos-filter-presets', JSON.stringify(this.presets));
      },

      getFilterSummary(filters) {
        const parts = [];
        if (filters.location) parts.push(`Location: ${filters.location}`);
        if (filters.prom) parts.push(`Node: ${filters.prom}`);
        if (filters.time) parts.push(`Time: ${filters.time}`);
        if (filters.service) parts.push(`Service: ${filters.service}`);
        if (filters.search) parts.push(`Search: "${filters.search}"`);
        return parts.join(' | ') || 'No filters';
      },

      render() {
        const list = document.getElementById('presets-list');
        if (!list) return;

        if (this.presets.length === 0) {
          list.innerHTML = '<div class="presets-empty">No saved presets yet</div>';
          return;
        }

        list.innerHTML = this.presets.map(preset => `
          <div class="preset-item" data-id="${preset.id}">
            <div class="preset-info" onclick="PresetsManager.applyPreset(${preset.id})">
              <div class="preset-name">${this.escapeHtml(preset.name)}</div>
              <div class="preset-filters">${this.escapeHtml(this.getFilterSummary(preset.filters))}</div>
            </div>
            <div class="preset-actions">
              <button type="button" class="preset-action-btn delete" onclick="PresetsManager.deletePreset(${preset.id})" title="Delete preset">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <line x1="18" y1="6" x2="6" y2="18"></line>
                  <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
              </button>
            </div>
          </div>
        `).join('');
      },

      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
    };

    // ========================================
    // COLUMN MANAGER
    // ========================================

    const ColumnManager = {
      modal: null,
      columns: [],
      discoveredFields: { labels: [], annotations: [], core: [] },
      profiles: {
        default: ['checkbox', 'uid', 'account', 'hostname', 'location', 'prom', 'time', 'services', 'actions'],
        compact: ['checkbox', 'hostname', 'account', 'services', 'time', 'actions'],
        detailed: ['checkbox', 'uid', 'account', 'hostname', 'location', 'prom', 'time', 'services', 'actions'],
        custom: []
      },
      currentProfile: 'default',

      init() {
        this.modal = document.getElementById('column-config-modal');
        this.loadConfig();
        this.applyColumns();

        // Close modal on overlay click
        if (this.modal) {
          this.modal.addEventListener('click', (e) => {
            if (e.target === this.modal) this.close();
          });
        }

        // Keyboard shortcut
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && this.modal?.classList.contains('show')) {
            this.close();
          }
        });
      },

      loadConfig() {
        const saved = localStorage.getItem('prometheos_column_config');
        if (saved) {
          try {
            const config = JSON.parse(saved);
            this.columns = config.columns || this.profiles.default;
            this.currentProfile = config.profile || 'default';
            this.profiles.custom = config.customProfile || [];
            this.discoveredFields = config.discoveredFields || { labels: [], annotations: [], core: [] };
          } catch (e) {
            this.columns = [...this.profiles.default];
          }
        } else {
          this.columns = [...this.profiles.default];
        }
      },

      saveConfig() {
        localStorage.setItem('prometheos_column_config', JSON.stringify({
          columns: this.columns,
          profile: this.currentProfile,
          customProfile: this.profiles.custom,
          discoveredFields: this.discoveredFields
        }));
      },

      open() {
        if (!this.modal) return;
        this.renderVisibleColumns();
        this.renderApiFields();
        this.updatePreview();
        this.updateProfileButtons();
        this.modal.classList.add('show');
      },

      close() {
        if (this.modal) {
          this.modal.classList.remove('show');
        }
      },

      applyAndClose() {
        this.applyColumns();
        this.saveConfig();
        this.close();
      },

      renderVisibleColumns() {
        const list = document.getElementById('visible-columns-list');
        const countBadge = document.getElementById('visible-columns-count');
        if (!list) return;

        const allColumns = this.getAllColumnDefinitions();

        list.innerHTML = this.columns
          .filter(colId => colId !== 'checkbox' && colId !== 'actions')
          .map((colId, index) => {
            const col = allColumns.find(c => c.id === colId) || { id: colId, name: colId, source: 'custom' };
            return `
              <div class="column-item selected" data-column-id="${col.id}" draggable="true">
                <input type="checkbox" class="column-checkbox" checked onchange="ColumnManager.toggleColumn('${col.id}')">
                <div class="column-info">
                  <div class="column-name">${this.escapeHtml(col.name)}</div>
                  <div class="column-source">${col.source}</div>
                </div>
                <div class="column-drag-handle">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="8" y1="6" x2="16" y2="6"></line>
                    <line x1="8" y1="12" x2="16" y2="12"></line>
                    <line x1="8" y1="18" x2="16" y2="18"></line>
                  </svg>
                </div>
              </div>
            `;
          }).join('');

        // Add available but not visible columns
        const availableCols = allColumns.filter(col =>
          !this.columns.includes(col.id) && col.id !== 'checkbox' && col.id !== 'actions'
        );

        if (availableCols.length > 0) {
          list.innerHTML += availableCols.map(col => `
            <div class="column-item" data-column-id="${col.id}">
              <input type="checkbox" class="column-checkbox" onchange="ColumnManager.toggleColumn('${col.id}')">
              <div class="column-info">
                <div class="column-name">${this.escapeHtml(col.name)}</div>
                <div class="column-source">${col.source}</div>
              </div>
              <div class="column-drag-handle">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <line x1="8" y1="6" x2="16" y2="6"></line>
                  <line x1="8" y1="12" x2="16" y2="12"></line>
                  <line x1="8" y1="18" x2="16" y2="18"></line>
                </svg>
              </div>
            </div>
          `).join('');
        }

        if (countBadge) {
          countBadge.textContent = `${this.columns.length - 2} columns`; // -2 for checkbox and actions
        }

        this.initDragDrop();
      },

      getAllColumnDefinitions() {
        const defaultCols = [
          { id: 'uid', name: 'UID', source: 'core' },
          { id: 'account', name: 'Account', source: 'core' },
          { id: 'hostname', name: 'Hostname', source: 'core' },
          { id: 'location', name: 'Location', source: 'core' },
          { id: 'prom', name: 'Prom Node', source: 'core' },
          { id: 'time', name: 'Start Time', source: 'core' },
          { id: 'services', name: 'Services', source: 'core' }
        ];

        // Add discovered fields
        const labelCols = this.discoveredFields.labels.map(f => ({
          id: `label_${f.name}`, name: f.name, source: 'label'
        }));
        const annotationCols = this.discoveredFields.annotations.map(f => ({
          id: `annotation_${f.name}`, name: f.name, source: 'annotation'
        }));

        return [...defaultCols, ...labelCols, ...annotationCols];
      },

      toggleColumn(colId) {
        const idx = this.columns.indexOf(colId);
        if (idx > -1) {
          this.columns.splice(idx, 1);
        } else {
          // Insert before 'actions'
          const actionsIdx = this.columns.indexOf('actions');
          if (actionsIdx > -1) {
            this.columns.splice(actionsIdx, 0, colId);
          } else {
            this.columns.push(colId);
          }
        }
        this.currentProfile = 'custom';
        this.profiles.custom = [...this.columns];
        this.renderVisibleColumns();
        this.updatePreview();
        this.updateProfileButtons();
      },

      initDragDrop() {
        const list = document.getElementById('visible-columns-list');
        if (!list) return;

        const items = list.querySelectorAll('.column-item[draggable="true"]');
        items.forEach(item => {
          item.addEventListener('dragstart', (e) => {
            item.classList.add('dragging');
            e.dataTransfer.setData('text/plain', item.dataset.columnId);
          });
          item.addEventListener('dragend', () => {
            item.classList.remove('dragging');
          });
          item.addEventListener('dragover', (e) => {
            e.preventDefault();
            const dragging = list.querySelector('.dragging');
            if (dragging && item !== dragging) {
              const rect = item.getBoundingClientRect();
              const midY = rect.top + rect.height / 2;
              if (e.clientY < midY) {
                item.parentNode.insertBefore(dragging, item);
              } else {
                item.parentNode.insertBefore(dragging, item.nextSibling);
              }
            }
          });
          item.addEventListener('drop', () => {
            this.updateColumnOrder();
          });
        });
      },

      updateColumnOrder() {
        const list = document.getElementById('visible-columns-list');
        if (!list) return;

        const newOrder = ['checkbox'];
        list.querySelectorAll('.column-item.selected').forEach(item => {
          newOrder.push(item.dataset.columnId);
        });
        newOrder.push('actions');

        this.columns = newOrder;
        this.currentProfile = 'custom';
        this.profiles.custom = [...this.columns];
        this.updatePreview();
        this.updateProfileButtons();
      },

      renderApiFields() {
        // Update field grids
        ['labels', 'annotations', 'core'].forEach(type => {
          const grid = document.getElementById(`${type === 'labels' ? 'label' : type === 'annotations' ? 'annotation' : type}-fields-grid`);
          const count = document.getElementById(`${type === 'labels' ? 'label' : type === 'annotations' ? 'annotation' : type}-fields-count`);

          if (!grid) return;

          const fields = type === 'core' ? this.getCoreFields() : this.discoveredFields[type];

          if (count) count.textContent = fields.length;

          if (fields.length === 0) {
            grid.innerHTML = '<div class="api-fields-empty">Click "Discover Fields" to scan for available fields</div>';
            return;
          }

          grid.innerHTML = fields.map(field => {
            const colId = type === 'core' ? field.id : `${type === 'labels' ? 'label' : 'annotation'}_${field.name}`;
            const isAdded = this.columns.includes(colId);
            return `
              <div class="api-field-card ${isAdded ? 'added' : ''}" data-field-id="${colId}">
                <div class="api-field-header">
                  <span class="api-field-name">${this.escapeHtml(field.name)}</span>
                  <span class="api-field-type ${type === 'labels' ? 'label' : type === 'annotations' ? 'annotation' : 'core'}">${type === 'labels' ? 'Label' : type === 'annotations' ? 'Ann.' : 'Core'}</span>
                </div>
                ${field.sample ? `<div class="api-field-sample" title="${this.escapeHtml(field.sample)}">${this.escapeHtml(field.sample.substring(0, 40))}${field.sample.length > 40 ? '...' : ''}</div>` : ''}
                <div class="api-field-actions">
                  <button type="button" class="btn-add-column" ${isAdded ? 'disabled' : ''} onclick="ColumnManager.addFieldAsColumn('${colId}', '${this.escapeHtml(field.name)}', '${type}')">
                    ${isAdded ? 'Added' : 'Add Column'}
                  </button>
                </div>
              </div>
            `;
          }).join('');
        });
      },

      getCoreFields() {
        return [
          { id: 'uid', name: 'UID', sample: 'ABC123' },
          { id: 'account', name: 'Account', sample: 'Production' },
          { id: 'hostname', name: 'Hostname', sample: 'web-server-01' },
          { id: 'location', name: 'Location', sample: 'US-East' },
          { id: 'prom', name: 'Prom Node', sample: 'prometheus-1' },
          { id: 'time', name: 'Start Time', sample: '2024-01-15 10:30' },
          { id: 'services', name: 'Services', sample: 'nginx, php-fpm' }
        ];
      },

      async discoverFields() {
        const statusDot = document.getElementById('api-status-dot');
        const statusText = document.getElementById('api-status-text');
        const endpointInput = document.getElementById('api-endpoint');

        if (statusDot) statusDot.classList.add('loading');
        if (statusText) statusText.textContent = 'Scanning...';

        try {
          // Discover fields from current table data
          const labels = new Map();
          const annotations = new Map();

          // Scan table rows for data attributes
          document.querySelectorAll('.alert-row').forEach(row => {
            // Get all data attributes
            Object.keys(row.dataset).forEach(key => {
              const value = row.dataset[key];
              if (value && key !== 'uid') {
                if (!labels.has(key)) {
                  labels.set(key, { name: key, sample: value, count: 1 });
                } else {
                  labels.get(key).count++;
                }
              }
            });
          });

          // Check for additional fields in cells
          document.querySelectorAll('.alert-row td[data-field]').forEach(cell => {
            const field = cell.dataset.field;
            const value = cell.textContent.trim();
            if (field && value) {
              if (!labels.has(field)) {
                labels.set(field, { name: field, sample: value, count: 1 });
              }
            }
          });

          // Simulated additional AlertManager fields that might be available
          const commonLabels = [
            { name: 'alertname', sample: 'HighCPUUsage' },
            { name: 'severity', sample: 'critical' },
            { name: 'instance', sample: '10.0.0.1:9090' },
            { name: 'job', sample: 'node_exporter' },
            { name: 'env', sample: 'production' },
            { name: 'team', sample: 'infrastructure' },
            { name: 'datacenter', sample: 'dc1' }
          ];

          const commonAnnotations = [
            { name: 'summary', sample: 'High CPU usage detected' },
            { name: 'description', sample: 'CPU usage is above 80% for 5 minutes' },
            { name: 'runbook_url', sample: 'https://runbooks.example.com/high-cpu' },
            { name: 'dashboard_url', sample: 'https://grafana.example.com/d/xyz' }
          ];

          // Merge discovered with common
          commonLabels.forEach(l => {
            if (!labels.has(l.name)) {
              labels.set(l.name, l);
            }
          });

          this.discoveredFields.labels = Array.from(labels.values());
          this.discoveredFields.annotations = commonAnnotations;
          this.discoveredFields.core = this.getCoreFields();

          if (statusDot) statusDot.classList.remove('loading');
          if (statusText) statusText.textContent = `Found ${this.discoveredFields.labels.length + this.discoveredFields.annotations.length} fields`;
          if (endpointInput) endpointInput.value = window.location.origin + '/api/v1/alerts';

          this.saveConfig();
          this.renderApiFields();

        } catch (error) {
          if (statusDot) {
            statusDot.classList.remove('loading');
            statusDot.classList.add('error');
          }
          if (statusText) statusText.textContent = 'Error scanning fields';
          console.error('Field discovery error:', error);
        }
      },

      addFieldAsColumn(colId, fieldName, type) {
        if (this.columns.includes(colId)) return;

        // Add to discovered fields if not present
        if (type === 'labels' && !this.discoveredFields.labels.find(f => f.name === fieldName)) {
          this.discoveredFields.labels.push({ name: fieldName, sample: '' });
        } else if (type === 'annotations' && !this.discoveredFields.annotations.find(f => f.name === fieldName)) {
          this.discoveredFields.annotations.push({ name: fieldName, sample: '' });
        }

        // Insert before 'actions'
        const actionsIdx = this.columns.indexOf('actions');
        if (actionsIdx > -1) {
          this.columns.splice(actionsIdx, 0, colId);
        } else {
          this.columns.push(colId);
        }

        this.currentProfile = 'custom';
        this.profiles.custom = [...this.columns];
        this.renderVisibleColumns();
        this.renderApiFields();
        this.updatePreview();
        this.updateProfileButtons();
      },

      applyProfile(profileName) {
        if (this.profiles[profileName]) {
          this.columns = [...this.profiles[profileName]];
          if (this.columns.length === 0) {
            this.columns = [...this.profiles.default];
          }
        }
        this.currentProfile = profileName;
        this.renderVisibleColumns();
        this.updatePreview();
        this.updateProfileButtons();
      },

      updateProfileButtons() {
        document.querySelectorAll('.profile-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.profile === this.currentProfile);
        });
      },

      updatePreview() {
        const headerRow = document.getElementById('preview-header-row');
        const sampleRow = document.getElementById('preview-sample-row');
        if (!headerRow || !sampleRow) return;

        const allCols = this.getAllColumnDefinitions();
        const visibleCols = this.columns.filter(id => id !== 'checkbox' && id !== 'actions');

        headerRow.innerHTML = visibleCols.map(colId => {
          const col = allCols.find(c => c.id === colId) || { name: colId };
          return `<th>${this.escapeHtml(col.name)}</th>`;
        }).join('');

        // Generate sample data
        const firstRow = document.querySelector('.alert-row');
        sampleRow.innerHTML = visibleCols.map(colId => {
          let value = '—';
          if (firstRow) {
            if (colId === 'uid') value = firstRow.querySelector('.uid-badge')?.textContent || '—';
            else if (colId === 'account') value = firstRow.querySelector('.cell-primary')?.textContent || '—';
            else if (colId === 'hostname') value = firstRow.querySelector('.hostname')?.textContent?.trim() || '—';
            else if (colId === 'time') value = firstRow.querySelector('.time-badge')?.textContent || '—';
            else if (colId === 'services') value = firstRow.querySelector('.service-tags')?.textContent?.trim().substring(0, 20) || '—';
            else if (firstRow.dataset[colId]) value = firstRow.dataset[colId];
            else if (colId.startsWith('label_')) value = firstRow.dataset[colId.replace('label_', '')] || '—';
          }
          return `<td>${this.escapeHtml(value)}</td>`;
        }).join('');
      },

      applyColumns() {
        const tables = ['active-table', 'silenced-table'];
        const allCols = this.getAllColumnDefinitions();

        tables.forEach(tableId => {
          const table = document.getElementById(tableId);
          if (!table) return;

          // Update header visibility
          const headers = table.querySelectorAll('thead th');
          headers.forEach((th, index) => {
            const colId = this.getColumnIdByIndex(index);
            if (colId) {
              th.style.display = this.columns.includes(colId) ? '' : 'none';
            }
          });

          // Update cell visibility
          table.querySelectorAll('tbody tr').forEach(row => {
            row.querySelectorAll('td').forEach((td, index) => {
              const colId = this.getColumnIdByIndex(index);
              if (colId) {
                td.style.display = this.columns.includes(colId) ? '' : 'none';
              }
            });
          });
        });
      },

      getColumnIdByIndex(index) {
        const mapping = ['checkbox', 'uid', 'account', 'hostname', 'location', 'prom', 'time', 'services', 'actions'];
        return mapping[index] || null;
      },

      resetToDefault() {
        this.columns = [...this.profiles.default];
        this.currentProfile = 'default';
        this.renderVisibleColumns();
        this.updatePreview();
        this.updateProfileButtons();
      },

      escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
    };

    // ========================================
    // INITIALIZATION
    // ========================================

    document.addEventListener('DOMContentLoaded', function() {
      ThemeManager.init();
      RefreshManager.init();
      ShortcutsModal.init();
      FilterManager.init();
      ExportManager.init();
      DensityManager.init();
      PresetsManager.init();
      SectionManager.init();
      TimeRangeManager.init();
      IncidentManager.init();
      ColumnManager.init();
      HelpModal.init();
      AlertDrawer.init();
      BulkActions.init();
      NewAlertsIndicator.init();
      URLState.init();

      // Close status dropdowns on outside click
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.status-selector')) {
          document.querySelectorAll('.status-dropdown.show').forEach(d => d.classList.remove('show'));
        }
      });

      updateCounts();
    });
  </script>
</body>
</html>
{{ end }}
